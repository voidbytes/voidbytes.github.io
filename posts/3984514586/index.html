<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>读 MySQL 源码再看 INSERT 加锁流程 | 小白的编程札记</title><meta name="author" content=" 小白 "><meta name="copyright" content=" 小白 "><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="读 MySQL 源码再看 INSERT 加锁流程有一个问题，我还是彻底被问蒙了。他的问题是这样的：  加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？  这个问题初"><meta property="og:type" content="article"><meta property="og:title" content="读 MySQL 源码再看 INSERT 加锁流程"><meta property="og:url" content="https://voidbytes.com/posts/3984514586/index.html"><meta property="og:site_name" content="小白的编程札记"><meta property="og:description" content="读 MySQL 源码再看 INSERT 加锁流程有一个问题，我还是彻底被问蒙了。他的问题是这样的：  加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？  这个问题初"><meta property="og:locale"><meta property="og:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><meta property="article:published_time" content="2023-08-24T08:00:00.000Z"><meta property="article:modified_time" content="2023-08-24T08:00:00.000Z"><meta property="article:author" content=" 小白 "><meta property="article:tag" content="转载"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "读 MySQL 源码再看 INSERT 加锁流程",
  "url": "https://voidbytes.com/posts/3984514586/",
  "image": "https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg",
  "datePublished": "2023-08-24T08:00:00.000Z",
  "dateModified": "2023-08-24T08:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": " 小白 ",
      "url": "https://voidbytes.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://voidbytes.com/posts/3984514586/index.html"><link rel="preconnect"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2253275085764952",enable_page_level_ads:"true"})</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3d9a712cb35c03011599a3cbebc08968";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-TPPKTP3FCP"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-TPPKTP3FCP')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-TPPKTP3FCP', {'page_path': window.location.pathname})
}, 'google_analytics')</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;038395b9390c4140975c022799210743&quot;}"></script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"读 MySQL 源码再看 INSERT 加锁流程",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="小白的编程札记" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="小白的编程札记" type="application/rss+xml"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fas fa-comment-dots"></i><span> Guestbook</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://today.voidbytes.com/pic/today.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小白的编程札记</span></a><a class="nav-page-title" href="/"><span class="site-name">读 MySQL 源码再看 INSERT 加锁流程</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div><div class="menus_item"><a class="site-page" href="/guestbook/"><i class="fa-fw fas fa-comment-dots"></i><span> Guestbook</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">读 MySQL 源码再看 INSERT 加锁流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-24T08:00:00.000Z" title="Updated 2023-08-24 00:00:00">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>19mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-08-24 00:00:00&quot;}" hidden></div><h1 id="读-MySQL-源码再看-INSERT-加锁流程"><a href="#读-MySQL-源码再看-INSERT-加锁流程" class="headerlink" title="读 MySQL 源码再看 INSERT 加锁流程"></a>读 MySQL 源码再看 INSERT 加锁流程</h1><p>有一个问题，我还是彻底被问蒙了。他的问题是这样的：</p><blockquote><p>加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？</p></blockquote><p>这个问题初看上去很简单，在 RR 隔离级别下，假设要插入的记录不存在，如果先执行select…lock in share mode 语句，很显然会在记录间隙之间加上 GAP 锁，而 insert 语句首先会对记录加插入意向锁，插入意向锁和 GAP 锁冲突，所以不存在幻读；如果先执行 insert 语句后执行 select…lock in share mode 语句，由于 insert 语句在插入记录之后，会对记录加 X 锁，它会阻止 select…lock in share mode 对记录加 S 锁，所以也不存在幻读。两种情况如下所示：</p><p>先执行 INSERT 后执行 SELECT：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826918.jpeg" alt="Image">先执行 SELECT 后执行 INSERT：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826856.jpeg" alt="Image"></p><p>但是我们仔细想一想就会发现哪里有点不对劲，我们知道 insert 语句会先在插入间隙上加上插入意向锁，然后开始写数据，写完数据之后再对记录加上 X 记录锁（这里简化了，关于insert 语句的加锁流程，可以参考我之前写的常见 SQL 语句的加锁分析）。那么问题就来了，如果在 insert 语句加插入意向锁之后，写数据之前，执行了 select…lock in share mode语句，这个时候 GAP 锁和插入意向锁是不冲突的，查询出来的记录数为 0，然后insert 语句写数据，加 X 记录锁，因为记录锁和 GAP 锁也是不冲突的，所以 insert 成功插入了一条数据，这个时候如果事务提交，select…lock in share mode 语句再次执行查询出来的记录数就是 1，岂不是就出现了幻读？</p><p>整个流程如下所示（我们把 insert 语句的执行分成两个阶段，INSERT 1 加插入意向锁，还没写数据，INSERT 2 写数据，加记录锁）：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826953.jpeg" alt="Image"></p><p><strong>一、INSERT 加锁的困惑</strong></p><p>在得出上面的结论时，我也感到很惊讶。按理是不可能出现这种情况的，只可能是我对这两个语句的加锁过程还没有想明白。于是我又去复习了一遍 MySQL 官方文档，Locks Set by Different SQL Statements in InnoDB 这篇文档对各个语句的加锁有详细的描述，其中对insert 的加锁过程是这样说的（这应该是网络上介绍 MySQL 加锁机制被引用最多的文档，估计也是被误解最多的文档）：</p><blockquote><p>INSERT sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.<br>Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6 each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.<br>If a duplicate-key error occurs, a shared lock on the duplicate index record is set. This use of a shared lock can result in deadlock should there be multiple sessions trying to insert the same row if another session already has an exclusive lock. This can occur if another session deletes the row.</p></blockquote><p>讲到了 insert 会对插入的这条记录加排他记录锁，在加记录锁之前还会加一种 GAP 锁，叫做插入意向锁，如果出现唯一键冲突，还会加一个共享记录锁。这和我之前的理解是完全一样的，那么究竟是怎么回事呢？难道 MySQL 的 RR 真的会出现幻读现象？</p><p>在 Google 上搜索了很久，并没有找到 MySQL 幻读的问题，百思不得其解之际，遂决定从 MySQL 的源码中一探究竟。</p><h2 id="二、编译-MySQL-源码"><a href="#二、编译-MySQL-源码" class="headerlink" title="二、编译 MySQL 源码"></a><strong>二、编译 MySQL 源码</strong></h2><p>编译 MySQL 的源码非常简单，但是中间也有几个坑，如果能绕过这几个坑，在本地调试 MySQL 是一件很容易的事（当然能调试源码是一回事，能看懂源码又是另一回事了）。</p><p>我的环境是 Windows 10 x64，系统上安装了 Visual Studio 2012，如果你的开发环境和我不一样，编译步骤可能也会不同。</p><p>在开始之前，首先要从官网下载 MySQL 源码：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826818.jpeg" alt="Image"></p><p>这里我选择的是 5.6.40 版本，操作系统下拉列表里选 Source Code，OS Version 选择 Windows（Architecture Independent），然后就可以下载打包好的 zip 源码了。</p><p>将源码解压缩到 D:\mysql-5.6.40 目录，在编译之前，还需要再安装几个必要软件：</p><ul><li><strong>CMake</strong>：CMake 本身并不是编译工具，它是通过编写一种平台无关的 CMakeList.txt 文件来定制编译流程的，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程；</li><li><strong>Bison</strong>：MySQL 在执行 SQL 语句时，必然要对 SQL 语句进行解析，一般来说语法解析器会包含两个模块：词法分析和语法规则。词法分析和语法规则模块有两个较成熟的开源工具 Flex 和 Bison 分别用来解决这两个问题。MySQL 出于性能和灵活考虑，选择了自己完成词法解析部分，语法规则部分使用了 Bison，所以这里我们还要先安装 Bison。Bison 的默认安装路径为 C:\Program Files\GnuWin32，但是千万不要这样，一定要记得选择一个不带空格的目录，譬如 C:\GnuWin32 要不然在后面使用 Visual Studio 编译 MySQL 时会卡死；</li><li>Visual Studio：没什么好说的，Windows 环境下估计没有比它更好的开发工具了吧。</li></ul><p>安装好 CMake 和 Bison 之后，记得要把它们都加到 PATH 环境变量中。做好准备工作，我们就可以开始编译了，首先用 CMake 生成 Visual Studio 的工程文件:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1D:\mysql-5.6.40&gt; mkdir project</span><br><span class="line">2D:\mysql-5.6.40&gt; cd project</span><br><span class="line">3D:\mysql-5.6.40\project&gt; cmake -G "Visual Studio 11 2012 Win64" ..</span><br></pre></td></tr></tbody></table></figure><p>cmake 的-G 参数用于指定生成哪种类型的工程文件，这里是 Visual Studio 2012，可以直接输入 cmake -G 查看支持的工程类型。如果没问题，会在 project 目录下生成一堆文件，其中 MySQL.sln 就是我们要用的工程文件，使用 Visual Studio 打开它。</p><p>打开 MySQL.sln 文件，会在 Solution Explorer 看到 130 个项目，其中有一个叫 ALL_BUILD，这个时候如果直接编译，编译会失败，在这之前，我们还要对代码做点修改：</p><ul><li>首先是 sql\sql_locale.cc 文件，看名字就知道这个文件用于国际化与本土化，这个文件里有各个国家的语言字符，但是这个文件却是 ANSI 编码，所以要将其改成 Unicode 编码；</li><li>打开 sql\mysqld.cc 文件的第 5239 行，将 DBUG_ASSERT(0) 改成DBUG_ASSERT(1)，要不然调试时会触发断言；</li></ul><p>现在我们可以编译整个工程了，选中 ALL_BUILD 项目，Build，然后静静的等待 5 到 10 分钟，如果出现了 Build: 130 succeeded, 0 failed 这样的提示，那么恭喜，你现在可以尽情的调试 MySQL 了。</p><p>我们将 mysqld 设置为 Startup Project，然后加个命令行参数 –console，这样可以在控制台里查看打印的调试信息：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826853.jpeg" alt="Image"></p><p>另外， client\Debug\mysql.exe 这个文件是对应的 MySQL 的客户端，可以直接双击运行，默认使用的用户为 ODBC@localhost，如果要以 root 用户登录，可以执行 mysql.exe -u root，不需要密码。</p><h2 id="三、调试-INSERT-加锁流程"><a href="#三、调试-INSERT-加锁流程" class="headerlink" title="三、调试 INSERT 加锁流程"></a><strong>三、调试 INSERT 加锁流程</strong></h2><p>首先我们创建一个数据库 test，然后创建一个测试表 t，主键为 id，并插入测试数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1use test;</span><br><span class="line">2create table t(id int NOT NULL AUTO_INCREMENT , PRIMARY KEY (id));</span><br><span class="line">3insert into t(id) values(1),(10),(20),(50);</span><br></pre></td></tr></tbody></table></figure><p>然后我们开两个客户端会话，一个会话执行 insert into t(id) value(30)，另一个会话执行select * from t where id = 30 lock in share mode。很显然，如果我们能在 insert 语句加插入意向锁之后写数据之前下个断点，再在另一个会话中执行 select 就可以模拟出这种场景了。</p><p>那么我们来找下 insert 语句是在哪加插入意向锁的。第一次看 MySQL 源码可能会有些不知所措，调着调着就会迷失在深深的调用层级中，我们看 insert 语句的调用堆栈，一开始时还比较容易理解，从 <em>mysql_parse -&gt; mysql_execute_command -&gt; mysql_insert -&gt; write_record -&gt; handler::ha_write_row -&gt; innobase::write_row -&gt; row_insert_for_mysql</em>，这里就进入 InnoDb 引擎了。</p><p>然后继续往下跟：<em>row_ins_step -&gt; row_ins -&gt; row_ins_index_entry_step -&gt; row_ins_index_entry -&gt; row_ins_clust_index_entry -&gt; row_ins_clust_index_entry_low -&gt; btr_cur_optimistic_insert -&gt; btr_cur_ins_lock_and_undo -&gt; lock_rec_insert_check_and_lock。</em></p><p>一路跟下来，都没有发现插入意向锁的踪迹，直到 lock_rec_insert_check_and_lock 这里：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1if (lock_rec_other_has_conflicting(</span><br><span class="line"> 2        static_cast&lt;enum lock_mode&gt;(</span><br><span class="line"> 3            LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION),</span><br><span class="line"> 4        block, next_rec_heap_no, trx)) {</span><br><span class="line"> 5</span><br><span class="line"> 6    /* Note that we may get DB_SUCCESS also here! */</span><br><span class="line"> 7    trx_mutex_enter(trx);</span><br><span class="line"> 8</span><br><span class="line"> 9    err = lock_rec_enqueue_waiting(</span><br><span class="line">10        LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION,</span><br><span class="line">11        block, next_rec_heap_no, index, thr);</span><br><span class="line">12</span><br><span class="line">13    trx_mutex_exit(trx);</span><br><span class="line">14} else {</span><br><span class="line">15    err = DB_SUCCESS;</span><br><span class="line">16}</span><br></pre></td></tr></tbody></table></figure><p>这里是检查是否有和插入意向锁冲突的其他锁，如果有冲突，就将插入意向锁加到锁等待队列中。这很显然是先执行 select … lock in share mode 语句再执行 insert 语句时的情景，插入意向锁和 GAP 冲突。但这不是我们要找的点，于是继续探索，但是可惜的是，直到 insert 执行结束，我都没有找到加插入意向锁的地方。</p><p>跟代码非常辛苦，我担心是因为我跟丢了某块的逻辑导致没看到加锁，于是我看了看加其他锁的地方，发现在 InnoDb 里行锁都是通过调 lock_rec_add_to_queue（没有锁冲突） 或者 lock_rec_enqueue_waiting（有锁冲突，需要等待其他事务释放锁） 来实现的，于是在这两个函数上下断点，执行一条 insert 语句，依然没有断下来，说明 insert 语句没有加任何锁！</p><p>到这里我突然想起之前做过的 insert 加锁的实验，执行 insert 之后，如果没有任何冲突，在show engine innodb status 命令中是看不到任何锁的，这是因为 insert 加的是隐式锁。<strong>什么是隐式锁？隐式锁的意思就是没有锁！</strong></p><p>所以，根本就不存在之前说的先加插入意向锁，再加排他记录锁的说法，在执行 insert 语句时，什么锁都不会加。这就有点意思了，如果 insert 什么锁都不加，那么如果其他事务执行select … lock in share mode，它是如何阻止其他事务加锁的呢？</p><p>答案就在于隐式锁的转换。</p><p>InnoDb 在插入记录时，是不加锁的。如果事务 A 插入记录且未提交，这时事务 B 尝试对这条记录加锁，事务 B 会先去判断记录上保存的事务 id 是否活跃，如果活跃的话，那么就帮助事务 A 去建立一个锁对象，然后自身进入等待事务 A 状态，这就是所谓的隐式锁转换为显式锁。</p><p>我们跟一下执行 select 时的流程，如果 select 需要加锁，则会走：<em>sel_set_rec_lock -&gt; lock_clust_rec_read_check_and_lock -&gt; lock_rec_convert_impl_to_expl，lock_rec_convert_impl_to_expl</em> 函数的核心代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1impl_trx = trx_rw_is_active(trx_id, NULL);</span><br><span class="line"> 2</span><br><span class="line"> 3if (impl_trx != NULL</span><br><span class="line"> 4    &amp;&amp; !lock_rec_has_expl(LOCK_X | LOCK_REC_NOT_GAP, block,</span><br><span class="line"> 5              heap_no, impl_trx)) {</span><br><span class="line"> 6    ulint    type_mode = (LOCK_REC | LOCK_X</span><br><span class="line"> 7                 | LOCK_REC_NOT_GAP);</span><br><span class="line"> 8</span><br><span class="line"> 9    lock_rec_add_to_queue(</span><br><span class="line">10        type_mode, block, heap_no, index,</span><br><span class="line">11        impl_trx, FALSE);</span><br><span class="line">12}</span><br></pre></td></tr></tbody></table></figure><p>首先判断事务是否活跃，然后检查是否已存在排他记录锁，如果事务活跃且不存在锁，则为该事务加上排他记录锁。而本事务的锁是通过 lock_rec_convert_impl_to_expl 之后的lock_rec_lock 函数来加的。</p><p>到这里，这个问题的脉络已经很清晰了：</p><ol><li>执行 insert 语句，判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁；</li><li>执行 select … lock in share mode 语句，判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列；</li></ol><p>所以不存在网友所说的幻读问题。那么事情到此结束了么？并没有。</p><p>细心的你会发现，执行 insert 语句时，从判断是否有锁冲突，到写数据，这两个操作之间还是有时间差的，如果在这之间执行 select … lock in share mode 语句，由于此时记录还不存在，所以也不存在活跃事务，不会触发隐式锁转换，这条语句会返回 0 条记录，并加上 GAP 锁；而 insert 语句继续写数据，不加任何锁，在 insert 事务提交之后，select … lock in share mode 就能查到 1 条记录，这岂不是还有幻读问题吗？</p><p>为了彻底搞清楚这中间的细节，我们在 lock_rec_insert_check_and_lock 检查完锁冲突之后下个断点，然后在另一个事务中执行 select … lock in share mode，如果它能成功返回 0 条记录，加上 GAP 锁，说明就存在幻读。不过事实上，这条 SQL 语句执行的时候卡住了，并不会返回 0 条记录。从 show engine innodb status 的 TRANSACTIONS 里我们看不到任何行锁冲突的信息，但是我们从 RW-LATCH INFO 中却可以看出一些端倪：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 15    </span><br><span class="line"> 2-------------</span><br><span class="line"> 3RW-LATCH INFO</span><br><span class="line"> 4-------------</span><br><span class="line"> 5RW-LOCK: 000002C97F62FC70</span><br><span class="line"> 6Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 879  S-LOCK</span><br><span class="line"> 7RW-LOCK: 000002C976A3B998</span><br><span class="line"> 8Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line"> 9Locked: thread 10304 file d:\mysql-5.6.40\storage\innobase\include\btr0pcur.ic line 518  S-LOCK</span><br><span class="line">10Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line">11Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\row\row0ins.cc line 2339  S-LOCK</span><br><span class="line">12RW-LOCK: 000002C976A3B8A8  Waiters for the lock exist</span><br><span class="line">13Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  X-LOCK</span><br><span class="line">14Total number of rw-locks 16434</span><br><span class="line">15OS WAIT ARRAY INFO: reservation count 10</span><br><span class="line">16--Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore:</span><br><span class="line">17S-lock on RW-latch at 000002C976A3B8A8 created in file buf0buf.cc line 1069</span><br><span class="line">18a writer (thread id 2820) has reserved it in mode  exclusive</span><br><span class="line">19number of readers 0, waiters flag 1, lock_word: 0</span><br><span class="line">20Last time read locked in file btr0cur.cc line 256</span><br><span class="line">21Last time write locked in file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256</span><br><span class="line">22OS WAIT ARRAY INFO: signal count 8</span><br><span class="line">23Mutex spin waits 44, rounds 336, OS waits 7</span><br><span class="line">24RW-shared spins 3, rounds 90, OS waits 3</span><br><span class="line">25RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">26Spin rounds per wait: 7.64 mutex, 30.00 RW-shared, 0.00 RW-excl</span><br><span class="line">27</span><br></pre></td></tr></tbody></table></figure><p>这里列出了 3 个 RW-LOCK：000002C97F62FC70、000002C976A3B998、000002C976A3B8A8。其中可以看到最后一个 RW-LOCK 有其他线程在等待其释放（Waiters for the lock exist）。下面列出了所有等待该锁的线程，Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore，这里的 Thread 10304 就是我们正在执行 select 语句的线程，它卡在了 btr0cur.cc 的 256 行，我们查看 Thread 10304 的堆栈：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826932.jpeg" alt="Image"></p><p>btr0cur.cc 的 256 行位于 btr_cur_latch_leaves 函数，如下所示，通过 btr_block_get 来加锁，看起来像是在访问 InnoDb B+ 树的叶子节点时卡住了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1case BTR_MODIFY_LEAF:</span><br><span class="line">2    mode = latch_mode == BTR_SEARCH_LEAF ? RW_S_LATCH : RW_X_LATCH;</span><br><span class="line">3    get_block = btr_block_get(</span><br><span class="line">4        space, zip_size, page_no, mode, cursor-&gt;index, mtr);</span><br></pre></td></tr></tbody></table></figure><p>这里latch_mode==BTR_SEARCH_LEAF，所以加锁的mode为 RW_S_LATCH。</p><p>这里要介绍一个新的概念，叫做 <strong>Latch</strong>，一般也把它翻译成 “锁”，但它和我们之前接触的行锁表锁（<strong>Lock</strong>）是有区别的。这是一种轻量级的锁，锁定时间一般非常短，它是用来保证并发线程可以安全的操作临界资源，通常没有死锁检测机制。Latch 可以分为两种：MUTEX（互斥量）和 RW-LOCK（读写锁），很显然，这里我们看到的是 RW-LOCK。</p><p>我们回溯一下 select 语句的调用堆栈：<em>ha_innobase::index_read -&gt; row_search_for_mysql -&gt; btr_pcur_open_at_index_side -&gt; btr_cur_latch_leaves</em>，从调用堆栈可以看出 select … lock in share mode 语句在访问索引，那么为什么访问索引会被卡住呢？</p><p>接下来我们看看这个 RW-LOCK 是在哪里加上的？从日志里可以看到 Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256 X-LOCK，所以这个锁是线程 2820 加上的，加锁的位置也在 btr0cur.cc 的 256 行，查看函数引用，很快我们就查到这个锁是在执行 insert 时加上的，函数堆栈为：<em>row_ins_clust_index_entry_low -&gt; btr_cur_search_to_nth_level -&gt; btr_cur_latch_leaves</em>。</p><p>我们看这里的 row_ins_clust_index_entry_low 函数（无关代码已省略）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> 1UNIV_INTERN</span><br><span class="line"> 2dberr_t</span><br><span class="line"> 3row_ins_clust_index_entry_low(</span><br><span class="line"> 4/*==========================*/</span><br><span class="line"> 5    ulint        flags,    /*!&lt; in: undo logging and locking flags */</span><br><span class="line"> 6    ulint        mode,    /*!&lt; in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE,</span><br><span class="line"> 7                depending on whether we wish optimistic or</span><br><span class="line"> 8                pessimistic descent down the index tree */</span><br><span class="line"> 9    dict_index_t*    index,    /*!&lt; in: clustered index */</span><br><span class="line">10    ulint        n_uniq,    /*!&lt; in: 0 or index-&gt;n_uniq */</span><br><span class="line">11    dtuple_t*    entry,    /*!&lt; in/out: index entry to insert */</span><br><span class="line">12    ulint        n_ext,    /*!&lt; in: number of externally stored columns */</span><br><span class="line">13    que_thr_t*    thr)    /*!&lt; in: query thread */</span><br><span class="line">14{</span><br><span class="line">15    /* 开启一个 mini-transaction */</span><br><span class="line">16    mtr_start(&amp;mtr);</span><br><span class="line">17</span><br><span class="line">18    /* 调用 btr_cur_latch_leaves -&gt; btr_block_get 加 RW_X_LATCH */</span><br><span class="line">19    btr_cur_search_to_nth_level(index, 0, entry, PAGE_CUR_LE, mode,</span><br><span class="line">20                    &amp;cursor, 0, __FILE__, __LINE__, &amp;mtr);</span><br><span class="line">21</span><br><span class="line">22    if (mode != BTR_MODIFY_TREE) {</span><br><span class="line">23        /* 不需要修改 BTR_TREE，乐观插入 */</span><br><span class="line">24        err = btr_cur_optimistic_insert(</span><br><span class="line">25            flags, &amp;cursor, &amp;offsets, &amp;offsets_heap,</span><br><span class="line">26            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">27            n_ext, thr, &amp;mtr);</span><br><span class="line">28    } else {</span><br><span class="line">29        /* 需要修改 BTR_TREE，先乐观插入，乐观插入失败则进行悲观插入 */</span><br><span class="line">30        err = btr_cur_optimistic_insert(</span><br><span class="line">31            flags, &amp;cursor,</span><br><span class="line">32            &amp;offsets, &amp;offsets_heap,</span><br><span class="line">33            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">34            n_ext, thr, &amp;mtr);</span><br><span class="line">35        if (err == DB_FAIL) {</span><br><span class="line">36            err = btr_cur_pessimistic_insert(</span><br><span class="line">37                flags, &amp;cursor,</span><br><span class="line">38                &amp;offsets, &amp;offsets_heap,</span><br><span class="line">39                entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">40                n_ext, thr, &amp;mtr);</span><br><span class="line">41        }</span><br><span class="line">42    }</span><br><span class="line">43</span><br><span class="line">44    /* 提交 mini-transaction */</span><br><span class="line">45    mtr_commit(&amp;mtr);</span><br><span class="line">46}</span><br></pre></td></tr></tbody></table></figure><p>这里是执行 insert 语句的关键，可以发现执行插入操作的前后分别有一行代码：mtr_start() 和 mtr_commit()。这被称为 <strong>迷你事务（mini-transaction）</strong>，既然叫做事务，那这个函数的操作肯定是原子性的，事实上确实如此，insert 会在检查锁冲突和写数据之前，会对记录所在的页加一个 RW-X-LATCH 锁，执行完写数据之后再释放该锁（实际上写数据的操作就是写 redo log（重做日志），将脏页加入 flush list，这个后面有时间再深入分析了）。这个锁的释放非常快，但是这个锁足以保证在插入数据的过程中其他事务无法访问记录所在的页。mini-transaction 也可以包含子事务，实际上在 insert 的执行过程中就会加多个 mini-transaction。</p><p>每个 mini-transaction 会遵守下面的几个规则：</p><ul><li>修改一个页需要获得该页的 X-LATCH；</li><li>访问一个页需要获得该页的 S-LATCH 或 X-LATCH；</li><li>持有该页的 LATCH 直到修改或者访问该页的操作完成。</li></ul><p>所以，最后的最后，真相只有一个：insert 和 select … lock in share mode 不会发生幻读。整个流程如下：</p><ol><li>执行 insert 语句，对要操作的页加 RW-X-LATCH，然后判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁，结束后释放 RW-X-LATCH；</li><li>执行 select … lock in share mode 语句，对要操作的页加 RW-S-LATCH，如果页面上存在 RW-X-LATCH 会被阻塞，没有的话则判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列，最后也会释放 RW-S-LATCH；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol><li>Locks Set by Different SQL Statements in InnoDB</li><li>Installing MySQL from Source</li><li>CMake 入门实战</li><li>MySQL源代码：从SQL语句到MySQL内部对象</li><li>MySQL · 源码分析 · 一条insert语句的执行过程</li><li>[MySQL源码] 一条简单insert语句的调用栈</li><li>MySQL5.7 : 对隐式锁转换的优化</li><li>[MySQL学习] Innodb锁系统(4) Insert/Delete 锁处理及死锁示例分析</li><li>InnoDB事务锁之行锁-insert加锁-隐式锁加锁原理</li><li>InnoDB事务锁之行锁-判断是否有隐式锁原理图</li><li>InnoDB事务锁之行锁-隐式锁转换显示锁举例理解原理</li><li>MySQL系列：innodb源码分析之mini transaction</li><li>MySQL - InnoDB mini transation</li><li>MySQL · 引擎特性 · InnoDB redo log漫游</li></ol><h1 id="原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql"><a href="#原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql" class="headerlink" title="原文：https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-"></a>原文：<a target="_blank" rel="noopener" href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-">https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-</a></h1><h1 id="source-code-html"><a href="#source-code-html" class="headerlink" title="source-code.html"></a>source-code.html</h1></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><div class="post-share"><div class="social-share" data-image="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/3795959674/" title="高并发场景下，到底先更新缓存还是先更新数据库？"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">高并发场景下，到底先更新缓存还是先更新数据库？</div></div><div class="info-2"><div class="info-item-1">高并发场景下，到底先更新缓存还是先更新数据库？1 在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。 为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。 Cache asideCache aside也就是旁路缓存，是比较常用的缓存策略。 （1）读请求常见流程 Cache aside 读请求 应用首先会判断缓存是否有该数据，缓存命中直接返回数据，缓存未命中即缓存穿透到数据库，从数据库查询数据然后回写到缓存中，最后返回数据给客户端。 （2）写请求常见流程 Cache aside 写请求 首先更新数据库，然后从缓存中删除该数据。 看了写请求的图之后，有些同学可能要问了：为什么要删除缓存，直接更新不就行了？这里涉及到几个坑，我们一步一步踩下去。 Cache aside踩坑Cache aside策略如果用错就会遇到深坑，下面我们来逐个踩。 踩坑一：先更新数据库，再更新缓存 如果同时有两个写请求需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。...</div></div></div></a><a class="pagination-related" href="/posts/3216271943/" title="消息队列中如何保证消息的顺序性"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">消息队列中如何保证消息的顺序性</div></div><div class="info-2"><div class="info-item-1">本文选自：advanced-java 作者：yanglbme 问：如何保证消息的顺序性？ 面试官心理分析其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。 面试题剖析我举个例子，我们以前做过一个 mysql binlog 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。 你在 mysql 里增删改一条数据，对应出来了增删改 3 条 binlog 日志，接着这三条 binlog 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。 本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。 先看看顺序会错乱的...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/3028893647/" title="SpringBoot 参数校验组件"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">SpringBoot 参数校验组件</div></div><div class="info-2"><div class="info-item-1">一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。 最普通的做法就像下面这样。我们通过 if/else 语句对请求的每一个参数一一校验。 这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。 但是，不太建议这样来写，这样的代码明显违背了 单一职责原则。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！ 实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！ 废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。 不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。 并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-...</div></div></div></a><a class="pagination-related" href="/posts/1696090382/" title="Java后端线上问题排查常用命令收藏"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">Java后端线上问题排查常用命令收藏</div></div><div class="info-2"><div class="info-item-1">作者：xiaolyuh 本文来源：http://r6d.cn/b97q7 内存瓶颈freefree是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。 free -h -s 3表示每隔三秒输出一次内存情况，命令如下 123456789101112[1014154@cc69dd4c5-4tdb5 ~]$ free total used free shared buff/cache availableMem: 119623656 43052220 45611364 4313760 30960072 70574408Swap: 0 0 0[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3 total used free shared buff/cache availableMem: ...</div></div></div></a><a class="pagination-related" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">Spring 事务失效的 12 种场景</div></div><div class="info-2"><div class="info-item-1">太坑了！聊聊 Spring 事务失效的 12 种场景前言 对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。 在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。 确实，spring事务用起来贼爽，就用一个简单的注解：@Transactional，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。 但如果你使用不当，它也会坑你于无形。 今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。 一 事务不生效1.访问权限问题众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。 但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如： 123456789@Servicepublic class UserService { @Transactional private...</div></div></div></a><a class="pagination-related" href="/posts/312572753/" title="如何彻底理解红黑树"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何彻底理解红黑树</div></div><div class="info-2"><div class="info-item-1">作者**：linzworld cnblogs.com/linzworld/p/13720477.html 前言本文主要讲解下最近一直听到的红黑树，看看究竟是什么神仙鬼怪。 二叉树满足以下两个条件的树就是二叉树： 本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 简单地理解，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。 二叉查找树要了解红黑树之前，免不了先看下二叉查找树是什么。 维基百科上的定义二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节...</div></div></div></a><a class="pagination-related" href="/posts/2853285209/" title="为什么要用消息队列？你项目中是怎么用的"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">为什么要用消息队列？你项目中是怎么用的</div></div><div class="info-2"><div class="info-item-1">为什么要用消息队列？你项目中是怎么用的？包含原理+BAT案例实践，看完需要5分钟 本文内容预览： 是什么？为什么？1.1 什么是消息队列1.2 为什么要使用消息队列1.3 引入消息队列的带来了哪些问题 怎么样？2.1 支撑七年双11零故障的RocketMQ2.2 快手万亿级kafka集群的平滑扩容2.3 快手/美团对kafka缓存污染的优化2.4 CMQ在微信红包支付场景下的应用 Part1是什么？为什么？1什么是消息队列说到Java中的队列应该都不会陌生。其具有通过先进先出，或者双端进出的方式进行数据管理；通过阻塞以达到自动平衡负载的功能。 消息队列之所以以队列命名，起初也是因为其功能和操作，和java的本地队列有相似之处。所以，我们可以简单的认为消息队列就是为了满足分布式下各服务之间的数据传输、管理和消费的一种中间服务。 2为什么要使用消息队列问：你们的系统中为什么要引入消息队列？ 我们总归需要知晓消息队列的使用价值，以及自己的业务场景下的实际痛点才能回答为什么要用消息队列这个问题，才能回答系统引入消息队列的价值所在。 系统间解耦以前几天在后台和关注公号的一个大佬讨论...</div></div></div></a><a class="pagination-related" href="/posts/209595582/" title="如何使错误日志更加方便排查问题"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何使错误日志更加方便排查问题</div></div><div class="info-2"><div class="info-item-1">作者 | 琴水玉 来源 | https://cnblogs.com/lovesqcc/p/4319594.html 在程序中打错误日志的主要目标是为更好地排查问题和解决问题提供重要线索和指导。但是在实际中打的错误日志内容和格式变化多样，错误提示上可能残缺不全、没有相关背景、不明其义，使得排查解决问题成为非常不方便或者耗时的操作。而实际上，如果编程的时候稍加用心，就会减少排查问题的很多无用功。 在阐述如何编写有效的错误日志之前， 了解错误是怎么产生的， 非常重要。 错误是如何炼成的 对于当前系统来说， 错误的产生由三个地方引入： 1.上层系统引入的非法参数。对于非法参数引入的错误， 可以通过参数校验和前置条件校验来截获错误； 2.与下层系统交互产生的错误。与下层交互产生的错误， 有两种： a.下层系统处理成功了，但是通信出错了， 这样会导致子系统之间的数据不一致； 对于这种情况， 可以采用超时补偿机制，预先将任务记录下来，通过定时任务在后续将数据订正过来。 更好的设计方案 ？ b.通信成功了，但是下层处理出错了。 对于这种情况， 需要与下层开发人员沟通， 协调子系统之间的交互； ...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小白</div><div class="author-info-description">这里是小白的小天地，简单记录自己的编程笔记、学习心得和日常点滴，分享一路成长的思考与收获。</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB-MySQL-%E6%BA%90%E7%A0%81%E5%86%8D%E7%9C%8B-INSERT-%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">读 MySQL 源码再看 INSERT 加锁流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BC%96%E8%AF%91-MySQL-%E6%BA%90%E7%A0%81"><span class="toc-number">1.1.</span> <span class="toc-text">二、编译 MySQL 源码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%B0%83%E8%AF%95-INSERT-%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">三、调试 INSERT 加锁流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.3.</span> <span class="toc-text">参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E6%96%87%EF%BC%9Ahttps-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql"><span class="toc-number">2.</span> <span class="toc-text">原文：https:&#x2F;&#x2F;www.aneasystone.com&#x2F;archives&#x2F;2018&#x2F;06&#x2F;insert-locks-via-mysql-</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#source-code-html"><span class="toc-number">3.</span> <span class="toc-text">source-code.html</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/187821551/" title="SSH问题经验">SSH问题经验</a><time datetime="2025-08-10T07:58:13.000Z" title="Created 2025-08-09 23:58:13">2025-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3028893647/" title="SpringBoot 参数校验组件">SpringBoot 参数校验组件</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1696090382/" title="Java后端线上问题排查常用命令收藏">Java后端线上问题排查常用命令收藏</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景">Spring 事务失效的 12 种场景</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/312572753/" title="如何彻底理解红黑树">如何彻底理解红黑树</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 小白 </span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">京ICP备2023004911号-1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>