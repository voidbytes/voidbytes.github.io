<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Java后端线上问题排查常用命令收藏 | 小白的编程札记</title><meta name="author" content=" 小白 "><meta name="copyright" content=" 小白 "><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="作者：xiaolyuh 本文来源：http:&#x2F;&#x2F;r6d.cn&#x2F;b97q7  内存瓶颈freefree是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。 free -h -s 3表示每隔三秒输出一次内存情况，命令如下 123456789101112[1014154@cc69dd4c5-4tdb5 ~]$ free              total        used"><meta property="og:type" content="article"><meta property="og:title" content="Java后端线上问题排查常用命令收藏"><meta property="og:url" content="https://voidbytes.com/posts/1696090382/index.html"><meta property="og:site_name" content="小白的编程札记"><meta property="og:description" content="作者：xiaolyuh 本文来源：http:&#x2F;&#x2F;r6d.cn&#x2F;b97q7  内存瓶颈freefree是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。 free -h -s 3表示每隔三秒输出一次内存情况，命令如下 123456789101112[1014154@cc69dd4c5-4tdb5 ~]$ free              total        used"><meta property="og:locale"><meta property="og:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><meta property="article:published_time" content="2023-08-24T08:00:00.000Z"><meta property="article:modified_time" content="2023-08-24T08:00:00.000Z"><meta property="article:author" content=" 小白 "><meta property="article:tag" content="转载"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java后端线上问题排查常用命令收藏",
  "url": "https://voidbytes.com/posts/1696090382/",
  "image": "https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg",
  "datePublished": "2023-08-24T08:00:00.000Z",
  "dateModified": "2023-08-24T08:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": " 小白 ",
      "url": "https://voidbytes.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://voidbytes.com/posts/1696090382/index.html"><link rel="preconnect"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2253275085764952",enable_page_level_ads:"true"})</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3d9a712cb35c03011599a3cbebc08968";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DNRXCK1KS8"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-DNRXCK1KS8')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-DNRXCK1KS8', {'page_path': window.location.pathname})
}, 'google_analytics')</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;038395b9390c4140975c022799210743&quot;}"></script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Java后端线上问题排查常用命令收藏",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="小白的编程札记" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="小白的编程札记" type="application/rss+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://today.voidbytes.com/pic/today.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小白的编程札记</span></a><a class="nav-page-title" href="/"><span class="site-name">Java后端线上问题排查常用命令收藏</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java后端线上问题排查常用命令收藏</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-24T08:00:00.000Z" title="Updated 2023-08-24 00:00:00">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">9.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>40mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-08-24 00:00:00&quot;}" hidden></div><blockquote><p>作者：xiaolyuh</p><p>本文来源：<a target="_blank" rel="noopener" href="http://r6d.cn/b97q7">http://r6d.cn/b97q7</a></p></blockquote><h1 id="内存瓶颈"><a href="#内存瓶颈" class="headerlink" title="内存瓶颈"></a>内存瓶颈</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>free</code>是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p><p><code>free -h -s 3</code>表示每隔三秒输出一次内存情况，命令如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      119623656    43052220    45611364     4313760    30960072    70574408</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Mem</code>：是内存的使用情况。</li><li><code>Swap</code>：是交换空间的使用情况。</li><li><code>total</code>：系统总的可用物理内存和交换空间大小。</li><li><code>used</code>：已经被使用的物理内存和交换空间。</li><li><code>free</code>：还有多少物理内存和交换空间可用使用，是真正尚未被使用的物理内存数量。</li><li><code>shared</code>：被共享使用的物理内存大小。</li><li><code>buff/cache</code>：被 buffer（缓冲区） 和 cache（缓存） 使用的物理内存大小。</li><li><code>available</code>：还可以被应用程序使用的物理内存大小，它是从应用程序的角度看到的可用内存数量，available ≈ free + buffer + cache。</li></ul><h3 id="交换空间-swap-space"><a href="#交换空间-swap-space" class="headerlink" title="交换空间(swap space)"></a>交换空间(swap space)</h3><p>swap space 是磁盘上的一块区域，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p><h2 id="vmstat（推荐）"><a href="#vmstat（推荐）" class="headerlink" title="vmstat（推荐）"></a>vmstat（推荐）</h2><p>vmstat（VirtualMeomoryStatistics，虚拟内存统计）是Linux中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视，推荐使用。</p><p><code>vmstat 5 3</code>表示每隔5秒统计一次，一共统计三次。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ vmstat 5 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 8  0      0 45453212 374768 30763728    0    0    14    99    1    1 11 10 78  0  1</span><br><span class="line">10  0      0 45489232 374768 30763360    0    0     2  1275 95118 97908 13 11 75  0  1</span><br><span class="line"> 6  0      0 45452908 374768 30765148    0    0     0  3996 89924 92073 12 10 78  0  1</span><br></pre></td></tr></tbody></table></figure><h3 id="procs"><a href="#procs" class="headerlink" title="procs"></a>procs</h3><p><code>r</code>：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU。<code>b</code>：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p><code>swpd</code>：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。<code>free</code>：表示当前空闲的物理内存。<code>buff</code>：表示缓冲大小，一般对块设备的读写才需要缓冲 <code>Cache</code>：表示缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><code>si</code>：表示数据由磁盘读入内存；通俗的讲就是每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。<code>so</code>：表示由内存写入磁盘，也就是由内存交换区进入内存的数据大小。</p><blockquote><p><strong>!!</strong> 注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</p></blockquote><h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><p><code>bi</code>：表示由块设备读入数据的总量，即读磁盘，单位kb/s <code>bo</code>：表示写到块设备数据的总量，即写磁盘，单位kb/s</p><blockquote><p><strong>!!</strong> 注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈。</p></blockquote><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>in</code>：表示某一时间间隔内观测到的每秒设备终端数。<code>cs</code>：表示每秒产生的上下文切换次数，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p><blockquote><p><strong>!!</strong> 注意：这两个值越大，则由内核消耗的CPU就越多。</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><code>us</code>：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法。<code>sy</code>：表示系统内核进程消耗的CPU时间百分比，一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈。<code>id</code>：表示CPU处在空间状态的时间百分比。<code>wa</code>：表示IP等待所占用的CPU时间百分比，wa值越高，说明I/O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I/O等待严重，引起I/O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的。</p><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>sar和free类似<code>sar -r 3</code>每隔三秒输出一次内存信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -r 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年04月28日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时40分10秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">15时40分13秒    106800   1314960     92.49      2144    573248   4110864    116.82    563664    498888        36</span><br><span class="line">15时40分16秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br><span class="line">15时40分19秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br></pre></td></tr></tbody></table></figure><h1 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h1><h2 id="查看机器cpu核数"><a href="#查看机器cpu核数" class="headerlink" title="查看机器cpu核数"></a>查看机器cpu核数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </span><br><span class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</span><br></pre></td></tr></tbody></table></figure><h3 id="查看CPU信息（型号）"><a href="#查看CPU信息（型号）" class="headerlink" title="查看CPU信息（型号）"></a>查看CPU信息（型号）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">     32  Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz</span><br></pre></td></tr></tbody></table></figure><h3 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure><h3 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "cpu cores"| uniq</span><br><span class="line">cpu cores       : 2</span><br></pre></td></tr></tbody></table></figure><h3 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "processor"| wc -l</span><br><span class="line">32</span><br></pre></td></tr></tbody></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>在Linux内核的操作系统中，进程是根据虚拟运行时间（由进程优先级、nice值加上实际占用的CPU时间进行动态计算得出）进行动态调度的。在执行进程时，需要从用户态转换到内核态，用户空间不能直接操作内核空间的函数。通常要利用系统调用来完成进程调度，而用户空间到内核空间的转换通常是通过软中断来完成的。例如要进行磁盘操作，用户态需要通过系统调用内核的磁盘操作指令，所以CPU消耗的时间被切分成用户态CPU消耗、系统（内核） CPU 消耗，以及磁盘操作 CPU 消耗。执行进程时，需要经过一系列的操作，进程首先在用户态执行，在执行过程中会进行进程优先级的调整（nice），通过系统调用到内核，再通过内核调用，硬中断、软中断，让硬件执行任务。执行完成之后，再从内核态返回给系统调用，最后系统调用将结果返回给用户态的进程。</p><p>top可以查看CPU总体消耗，包括分项消耗，如User，System，Idle，nice等。<code>Shift + H</code>显示java线程；<code>Shift + M</code>按照内存使用排序；<code>Shift + P</code>按照CPU使用时间（使用率）排序；<code>Shift + T</code>按照CPU累积使用时间排序；多核CPU，进入top视图<code>1</code>，可以看到各各CPU的负载情况。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">top - 15:24:11 up 8 days,  7:52,  1 user,  load average: 5.73, 6.85, 7.33</span><br><span class="line">Tasks:  17 total,   1 running,  16 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 13.9 us,  9.2 sy,  0.0 ni, 76.1 id,  0.1 wa,  0.0 hi,  0.1 si,  0.7 st</span><br><span class="line">KiB Mem : 11962365+total, 50086832 free, 38312808 used, 31224016 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 75402760 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">   300 ymmapp    20   0 17.242g 1.234g  14732 S   2.3  1.1   9:40.38 java</span><br><span class="line">     1 root      20   0   15376   1988   1392 S   0.0  0.0   0:00.06 sh</span><br><span class="line">    11 root      20   0  120660  11416   1132 S   0.0  0.0   0:04.94 python</span><br><span class="line">    54 root      20   0   85328   2240   1652 S   0.0  0.0   0:00.00 su</span><br><span class="line">    55 ymmapp    20   0   17432   1808   1232 S   0.0  0.0   0:00.00 bash</span><br><span class="line">    56 ymmapp    20   0   17556   2156   1460 S   0.0  0.0   0:00.03 control.sh</span><br><span class="line">    57 ymmapp    20   0   11880    740    576 S   0.0  0.0   0:00.00 tee</span><br><span class="line">   115 ymmapp    20   0   17556   2112   1464 S   0.0  0.0   0:00.02 control_new_war</span><br><span class="line">   133 root      20   0  106032   4240   3160 S   0.0  0.0   0:00.03 sshd</span><br><span class="line">   134 ymmapp    20   0   17080   6872   3180 S   0.0  0.0   0:01.82 ops-updater</span><br><span class="line">   147 ymmapp    20   0   17956   2636   1544 S   0.0  0.0   0:00.07 control.sh</span><br><span class="line">  6538 ymmapp    20   0  115656  10532   3408 S   0.0  0.0   0:00.46 beidou-agent</span><br><span class="line">  6785 ymmapp    20   0 2572996  22512   2788 S   0.0  0.0   0:03.44 gatherinfo4dock</span><br><span class="line"> 29241 root      20   0  142148   5712   4340 S   0.0  0.0   0:00.04 sshd</span><br><span class="line"> 29243 1014154   20   0  142148   2296    924 S   0.0  0.0   0:00.00 sshd</span><br><span class="line"> 29244 1014154   20   0   15208   2020   1640 S   0.0  0.0   0:00.00 bash</span><br><span class="line"> 32641 1014154   20   0   57364   2020   1480 R   0.0  0.0   0:00.00 top</span><br></pre></td></tr></tbody></table></figure><p>第一行：<code>15:24:11 up 8 days, 7:52, 1 user, load average: 5.73, 6.85, 7.33</code>：15:24:11 系统时间，up 8 days 运行时间，1 user 当前登录用户数，load average 负载均衡情况，分别表示1分钟，5分钟，15分钟负载情况。</p><p>第二行：<code>Tasks: 17 total, 1 running, 16 sleeping, 0 stopped, 0 zombie</code>：总进程数17，运行数1，休眠 16，停止0，僵尸进程0。</p><p>第三行：<code>%Cpu(s): 13.9 us, 9.2 sy, 0.0 ni, 76.1 id, 0.1 wa, 0.0 hi, 0.1 si, 0.7 st</code>：用户空间CPU占比13.9%，内核空间CPU占比9.2%，改变过优先级的进程CPU占比0%，空闲CPU占比76.1，IO等待占用CPU占比0.1%，硬中断占用CPU占比0%，软中断占用CPU占比0.1%,当前VM中的cpu 时钟被虚拟化偷走的比例0.7%。</p><p>第四和第五行表示内存和swap区域的使用情况。</p><p>第七行表示：</p><ul><li><code>PID</code>: 进程id</li><li><code>USER</code>:进程所有者</li><li><code>PR</code>:进程优先级</li><li><code>NI</code>:nice值。负值表示高优先级，正值表示低优先级</li><li><code>VIRT</code>:虚拟内存，进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li><code>RES</code>:常驻内存，进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li><code>SHR</code>:共享内存，共享内存大小，单位kb</li><li><code>S</code>:进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li><code>%CPU</code>:上次更新到现在的CPU时间占用百分比</li><li><code>%MEM</code>:进程使用的物理内存百分比</li><li><code>TIME+</code>:进程使用的CPU时间总计，单位1/100秒</li><li><code>COMMAND</code>:进程名称（命令名/命令行）</li></ul><h3 id="计算在cpu-load里面的uninterruptedsleep的任务数量"><a href="#计算在cpu-load里面的uninterruptedsleep的任务数量" class="headerlink" title="计算在cpu load里面的uninterruptedsleep的任务数量"></a>计算在cpu load里面的uninterruptedsleep的任务数量</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">[root@localhost ~]# top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">top - 15:35:05 up 1 day, 26 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us, 10.0 sy,  0.0 ni, 87.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   104516 free,   777344 used,   539900 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2071152 free,    25996 used.   456028 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">Total status D:</span><br></pre></td></tr></tbody></table></figure><h2 id="sar-1"><a href="#sar-1" class="headerlink" title="sar"></a>sar</h2><p>通过<code>sar -u 3</code>可以查看CUP总体消耗占比：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -u 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月01日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时18分03秒     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">15时18分06秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分09秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分12秒     all      0.17      0.00      0.17      0.00      0.00     99.66</span><br><span class="line">15时18分15秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">15时18分18秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br></pre></td></tr></tbody></table></figure><ul><li><code>%user</code>：用户空间的CPU使用。</li><li><code>%nice</code>：改变过优先级的进程的CPU使用率。</li><li><code>%system</code>：内核空间的CPU使用率。</li><li><code>%iowait</code>：CPU等待IO的百分比 。</li><li><code>%steal</code>：虚拟机的虚拟机CPU使用的CPU。</li><li><code>%idle</code>：空闲的CPU。</li></ul><p>在以上的显示当中，主要看<code>%iowait</code>和<code>%idle</code>：</p><ul><li>若 <code>%iowait</code>的值过高，表示硬盘存在I/O瓶颈；</li><li>若 <code>%idle</code>的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量；</li><li>若 <code>%idle</code>的值持续低于 10，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</li></ul><h2 id="定位线上最耗CPU的线程"><a href="#定位线上最耗CPU的线程" class="headerlink" title="定位线上最耗CPU的线程"></a>定位线上最耗CPU的线程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>启动一个程序。<code>arthas-demo</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br><span class="line">[root@localhost ~]# curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  3743  100  3743    0     0   3022      0  0:00:01  0:00:01 --:--:--  3023</span><br><span class="line">[root@localhost ~]# java -jar arthas-demo.jar</span><br><span class="line">1813=7*7*37</span><br><span class="line">illegalArgumentCount:  1, number is: -180005, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -111175, need &gt;= 2</span><br><span class="line">18505=5*3701</span><br><span class="line">166691=7*23813</span><br><span class="line">105787=11*59*163</span><br><span class="line">60148=2*2*11*1367</span><br><span class="line">196983=3*3*43*509</span><br><span class="line">illegalArgumentCount:  3, number is: -173479, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  4, number is: -112840, need &gt;= 2</span><br><span class="line">39502=2*19751</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><h3 id="通过top命令找到最耗时的进程"><a href="#通过top命令找到最耗时的进程" class="headerlink" title="通过top命令找到最耗时的进程"></a>通过<code>top</code>命令找到最耗时的进程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 11:11:05 up 20:02,  3 users,  load average: 0.09, 0.07, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.7 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   135868 free,   758508 used,   527384 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2070640 free,    26508 used.   475852 avail Mem</span><br><span class="line">Change delay from 3.0 to</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 98344 root      20   0 2422552  23508  12108 S   0.7  1.7   0:00.32 java</span><br><span class="line">     1 root      20   0  194100   6244   3184 S   0.0  0.4   0:20.41 systemd</span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kthreadd</span><br><span class="line">     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">     6 root      20   0       0      0      0 S   0.0  0.0   0:20.25 ksoftirqd/0</span><br></pre></td></tr></tbody></table></figure><p>找到进程号是98344。</p><h3 id="找到进程中最耗CUP的线程"><a href="#找到进程中最耗CUP的线程" class="headerlink" title="找到进程中最耗CUP的线程"></a>找到进程中最耗CUP的线程</h3><p>使用<code>ps -Lp #pid cu</code>命令，查看某个进程中的线程CPU消耗排序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 98344 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      98344  98344  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 java</span><br><span class="line">root      98344  98345  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:04 java</span><br><span class="line">root      98344  98346  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:01 VM Thread</span><br><span class="line">root      98344  98347  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Reference Handl</span><br><span class="line">root      98344  98348  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Finalizer</span><br><span class="line">root      98344  98349  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Signal Dispatch</span><br><span class="line">root      98344  98350  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:05 C2 CompilerThre</span><br><span class="line">root      98344  98351  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 C1 CompilerThre</span><br><span class="line">root      98344  98352  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Service Thread</span><br><span class="line">root      98344  98353  0.1   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:19 VM Periodic Tas</span><br></pre></td></tr></tbody></table></figure><p>看<code>TIME</code>列可以看出那个线程耗费CUP多，根据<code>LWP</code>列可以看到线程的ID号，但是需要转换成16进制才可以查询线程堆栈信息。</p><h3 id="获取线程id的十六进制码"><a href="#获取线程id的十六进制码" class="headerlink" title="获取线程id的十六进制码"></a>获取线程id的十六进制码</h3><p>使用<code>printf '%x\n' 98345</code>命令做进制转换：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf '%x\n' 98345</span><br><span class="line">18029</span><br></pre></td></tr></tbody></table></figure><h3 id="查看线程堆栈信息"><a href="#查看线程堆栈信息" class="headerlink" title="查看线程堆栈信息"></a>查看线程堆栈信息</h3><p>使用jstack获取堆栈信息<code>jstack 98344 | grep -A 10 18029</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack 98344 | grep -A 10 18029</span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fb88404b800 nid=0x18029 waiting on condition [0x00007fb88caab000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=0 tid=0x00007fb8840f2800 nid=0x1802a runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=0 tid=0x00007fb884154000 nid=0x18031 waiting on condition</span><br></pre></td></tr></tbody></table></figure><p>通过命令我们可以看到这个线程的对应的耗时代码是在<code>demo.MathGame.main(MathGame.java:17)</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">grep -B 5 foo file 显示foo及前5行</span><br><span class="line">grep -A 5 foo file 显示foo及后5行</span><br></pre></td></tr></tbody></table></figure><h1 id="网络瓶颈"><a href="#网络瓶颈" class="headerlink" title="网络瓶颈"></a>网络瓶颈</h1><h2 id="定位丢包，错包情况"><a href="#定位丢包，错包情况" class="headerlink" title="定位丢包，错包情况"></a>定位丢包，错包情况</h2><p><code>watch more /proc/net/dev</code>用于定位丢包，错包情况，以便看网络瓶颈，重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# watch -n 2 more /proc/net/dev</span><br><span class="line">Every 2.0s: more /proc/net/dev                                                                                                                                                   Fri May  1 17:16:55 2020</span><br><span class="line"></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   10025     130    0    0    0     0          0         0    10025     130    0    0    0     0       0          0</span><br><span class="line"> ens33: 759098071  569661    0    0    0     0          0         0 19335572  225551    0    0    0     0       0          0</span><br></pre></td></tr></tbody></table></figure><ul><li>最左边的表示接口的名字，Receive表示收包，Transmit表示发送包；</li><li><code>bytes</code>：表示收发的字节数；</li><li><code>packets</code>：表示收发正确的包量；</li><li><code>errs</code>：表示收发错误的包量；</li><li><code>drop</code>：表示收发丢弃的包量；</li></ul><h2 id="查看路由经过的地址"><a href="#查看路由经过的地址" class="headerlink" title="查看路由经过的地址"></a>查看路由经过的地址</h2><p><code>traceroute ip</code>可以查看路由经过的地址，常用来统计网络在各个路由区段的耗时，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# traceroute 14.215.177.38</span><br><span class="line">traceroute to 14.215.177.38 (14.215.177.38), 30 hops max, 60 byte packets</span><br><span class="line"> 1  CD-HZTK5H2.mshome.net (192.168.137.1)  0.126 ms * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  10.250.112.3 (10.250.112.3)  12.587 ms  12.408 ms  12.317 ms</span><br><span class="line"> 4  172.16.227.230 (172.16.227.230)  2.152 ms  2.040 ms  1.956 ms</span><br><span class="line"> 5  172.16.227.202 (172.16.227.202)  11.884 ms  11.746 ms  12.692 ms</span><br><span class="line"> 6  172.16.227.65 (172.16.227.65)  2.665 ms  3.143 ms  2.923 ms</span><br><span class="line"> 7  171.223.206.217 (171.223.206.217)  2.834 ms  2.752 ms  2.654 ms</span><br><span class="line"> 8  182.150.18.205 (182.150.18.205)  5.145 ms  5.815 ms  5.542 ms</span><br><span class="line"> 9  110.188.6.33 (110.188.6.33)  3.514 ms 171.208.199.185 (171.208.199.185)  3.431 ms 171.208.199.181 (171.208.199.181)  10.768 ms</span><br><span class="line">10  202.97.29.17 (202.97.29.17)  29.574 ms 202.97.30.146 (202.97.30.146)  32.619 ms *</span><br><span class="line">11  113.96.5.126 (113.96.5.126)  36.062 ms 113.96.5.70 (113.96.5.70)  35.940 ms 113.96.4.42 (113.96.4.42)  45.859 ms</span><br><span class="line">12  90.96.135.219.broad.fs.gd.dynamic.163data.com.cn (219.135.96.90)  35.680 ms  35.468 ms  35.304 ms</span><br><span class="line">13  14.215.32.102 (14.215.32.102)  35.135 ms 14.215.32.110 (14.215.32.110)  35.613 ms 14.29.117.242 (14.29.117.242)  54.712 ms</span><br><span class="line">14  * 14.215.32.134 (14.215.32.134)  49.518 ms 14.215.32.122 (14.215.32.122)  47.652 ms</span><br><span class="line">15  * * *</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看网络错误"><a href="#查看网络错误" class="headerlink" title="查看网络错误"></a>查看网络错误</h2><p><code>netstat -i</code>可以查看网络错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33            1500   570291      0      0 0        225897      0      0      0 BMRU</span><br><span class="line">lo              65536      130      0      0 0           130      0      0      0 LRU</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Iface</code>: 网络接口名称;</li><li><code>MTU</code>: 最大传输单元，它限制了数据帧的最大长度，不同的网络类型都有一个上限值，如：以太网的MTU是1500；</li><li><code>RX-OK</code>：接收时，正确的数据包数。</li><li><code>RX-ERR</code>：接收时，产生错误的数据包数。</li><li><code>RX-DRP</code>：接收时，丢弃的数据包数。</li><li><code>RX-OVR</code>：接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</li><li><code>TX-OK</code>：发送时，正确的数据包数。</li><li><code>TX-ERR</code>：发送时，产生错误的数据包数。</li><li><code>TX-DRP</code>：发送时，丢弃的数据包数。</li><li><code>TX-OVR</code>：发送时，由于过速而丢失的数据包数。</li><li><code>Flg</code>：标志，B 已经设置了一个广播地址。L 该接口是一个回送设备。M 接收所有数据包（混乱模式）。N 避免跟踪。O 在该接口上，禁用ARP。P 这是一个点到点链接。R 接口正在运行。U 接口处于“活动”状态。</li></ul><h2 id="包的重传率"><a href="#包的重传率" class="headerlink" title="包的重传率"></a>包的重传率</h2><p><code>cat /proc/net/snmp</code>用来查看和分析240秒内网络包量，流量，错包，丢包。通过<code>RetransSegs</code>和<code>OutSegs</code>来计算重传率<code>tcpetr=RetransSegs/OutSegs</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/net/snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 241708 0 0 0 0 0 238724 225517 15 0 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 149 0 0 50 99 0 0 0 0 0 0 0 0 0 147 0 147 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType11 OutType3</span><br><span class="line">IcmpMsg: 50 99 147</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 376 6 0 0 4 236711 223186 292 0 4 0</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">Udp: 1405 438 0 1896 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0</span><br></pre></td></tr></tbody></table></figure><p>重传率=292/223186≈0.13%</p><ul><li>平均每秒新增TCP连接数：通过/proc/net/snmp文件得到最近240秒内PassiveOpens的增量，除以240得到每秒的平均增量；</li><li>机器的TCP连接数 ：通过/proc/net/snmp文件的CurrEstab得到TCP连接数；</li><li>平均每秒的UDP接收数据报：通过/proc/net/snmp文件得到最近240秒内InDatagrams的增量，除以240得到平均每秒的UDP接收数据报；</li><li>平均每秒的UDP发送数据报：通过/proc/net/snmp文件得到最近240秒内OutDatagrams的增量，除以240得到平均每秒的UDP发送数据报；</li></ul><h1 id="磁盘瓶颈"><a href="#磁盘瓶颈" class="headerlink" title="磁盘瓶颈"></a>磁盘瓶颈</h1><h2 id="查磁盘空间"><a href="#查磁盘空间" class="headerlink" title="查磁盘空间"></a>查磁盘空间</h2><h3 id="查看磁盘剩余空间"><a href="#查看磁盘剩余空间" class="headerlink" title="查看磁盘剩余空间"></a>查看磁盘剩余空间</h3><p>查看磁盘剩余空间使用<code>df -hl</code>命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -hl</span><br><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                       678M     0  678M    0% /dev</span><br><span class="line">tmpfs                          695M     0  695M    0% /dev/shm</span><br><span class="line">tmpfs                          695M   28M  667M    4% /run</span><br><span class="line">tmpfs                          695M     0  695M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos_aubin-root   27G  5.6G   22G   21% /</span><br><span class="line">/dev/sda1                     1014M  211M  804M   21% /boot</span><br></pre></td></tr></tbody></table></figure><h3 id="查看磁盘已使用空间"><a href="#查看磁盘已使用空间" class="headerlink" title="查看磁盘已使用空间"></a>查看磁盘已使用空间</h3><p><code>du -sh</code>命令是查看磁盘已使用空间的情况，这里的“已使用的磁盘空间”意思是指定的文件下的整个文件层次结构所使用的空间，在没给定参数的情况下，<code>du</code>报告当前目录所使用的磁盘空间。其实就是显示文件或目录所占用的磁盘空间的情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -sh</span><br><span class="line">64K  </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-h</code>：输出文件系统分区使用的情况，例如：10KB，10MB，10GB等。</li><li><code>-s</code>：显示文件或整个目录的大小，默认单位是KB。</li></ul><blockquote><p><strong>!!</strong> <code>du</code>的详细信息可以通过 <code>man du</code>查看。</p></blockquote><h2 id="查看磁盘读写情况"><a href="#查看磁盘读写情况" class="headerlink" title="查看磁盘读写情况"></a>查看磁盘读写情况</h2><h3 id="查看磁盘总体读写情况"><a href="#查看磁盘总体读写情况" class="headerlink" title="查看磁盘总体读写情况"></a>查看磁盘总体读写情况</h3><p>通<code>iostat</code>查看磁盘总体的读写情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.17</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda               1.56        30.45        39.61    4659620    6060644</span><br><span class="line">scd0              0.00         0.02         0.00       3102          0</span><br><span class="line">dm-0              1.96        30.01        38.42    4591998    5878155</span><br><span class="line">dm-1              0.09         0.09         0.30      13840      45328</span><br></pre></td></tr></tbody></table></figure><ul><li><code>tps</code>：该设备每秒的传输次数。</li><li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li><li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li><li><code>kB_read</code>：读取的总数据量；</li><li><code>kB_wrtn</code>：写入的总数量数据量；</li></ul><h3 id="查看磁盘详细读写情况"><a href="#查看磁盘详细读写情况" class="headerlink" title="查看磁盘详细读写情况"></a>查看磁盘详细读写情况</h3><p>通过<code>iostat -x 1 3</code>可以看到磁盘详细读写情况，没隔一秒输出一次一共输出3次，当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注<code>iowait</code>占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注<code>await</code>，表示磁盘的响应时间以便小于5ms：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat -x 1 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.16</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01     0.49    0.63    0.95    30.59    39.78    89.58     0.34  214.23   49.16  323.48   8.55   1.34</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.02     0.00    98.48     0.00    1.21    1.21    0.00   0.95   0.00</span><br><span class="line">dm-0              0.00     0.00    0.62    1.35    30.15    38.59    69.70     0.91  460.67   49.12  648.54   6.66   1.31</span><br><span class="line">dm-1              0.00     0.00    0.02    0.07     0.09     0.30     8.52     0.04  442.74   95.43  521.17   6.91   0.06</span><br></pre></td></tr></tbody></table></figure><p><code>avg-cpu</code>表示总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值：</p><ul><li><code>%user</code>：CPU处在用户模式下的时间百分比。</li><li><code>%nice</code>：CPU处在带NICE值的用户模式下的时间百分比。</li><li><code>%system</code>：CPU处在系统模式下的时间百分比。</li><li><code>%iowait</code>：CPU等待输入输出完成时间的百分比，如果%iowait的值过高，表示硬盘存在I/O瓶颈。</li><li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li><code>%idle</code>：CPU空闲时间百分比，如果%idle值高，表示CPU较空闲；如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量；如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。。</li></ul><p><code>Device</code>表示设备信息：</p><ul><li><code>rrqm/s</code>：每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li><li><code>wrqm/s</code>：每秒对该设备的写请求被合并次数</li><li><code>r/s</code>：每秒完成的读次数</li><li><code>w/s</code>：每秒完成的写次数</li><li><code>rkB/s</code>：每秒读数据量(kB为单位)</li><li><code>wkB/s</code>：每秒写数据量(kB为单位)</li><li><code>avgrq-sz</code>：平均每次IO操作的数据量(扇区数为单位)</li><li><code>avgqu-sz</code>：平均等待处理的IO请求队列长度</li><li><code>await</code>：平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li><li><code>svctm</code>：平均每次IO请求的处理时间(毫秒为单位)</li><li><code>%util</code>：一秒中有百分之多少的时间用于 I/O如果%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷。<code>idle</code>小于70% IO压力就较大了，一般读取速度有较多的wait。</li></ul><blockquote><p><strong>!!</strong> <code>iostat -xmd 1 3</code>：新增<code>m</code>选项可以在输出是使用<code>M</code>为单位。</p></blockquote><h2 id="查看最耗IO的进程"><a href="#查看最耗IO的进程" class="headerlink" title="查看最耗IO的进程"></a>查看最耗IO的进程</h2><p>一般先通过<code>iostat</code>查看是否存在io瓶颈，再使用<code>iotop</code>命令来定位那个进程最耗费IO：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">123931 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.02 % [kworker/1:30]</span><br><span class="line"> 94208 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % nautilus-desktop --force [gmain]</span><br><span class="line">     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --system --deserialize 62</span><br><span class="line">     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line"> 94211 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % gvfsd-trash --spawner :1.4 /org/gtk/gvfs/exec_spaw/0</span><br><span class="line">     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line">     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">     7 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]</span><br><span class="line">     9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]</span><br><span class="line">    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>通过<code>iotop -p pid</code>可以查看单个进程的IO情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop -p 124146</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">124146 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % java -jar arthas-demo.jar</span><br></pre></td></tr></tbody></table></figure><h1 id="应用瓶颈"><a href="#应用瓶颈" class="headerlink" title="应用瓶颈"></a>应用瓶颈</h1><h2 id="查看某个进程的PID"><a href="#查看某个进程的PID" class="headerlink" title="查看某个进程的PID"></a>查看某个进程的PID</h2><p>如查看java的进程的pid，<code>ps -ef | grep java</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java</span><br><span class="line">root     124146   1984  0 09:13 pts/0    00:00:06 java -jar arthas-demo.jar</span><br><span class="line">root     125210  98378  0 10:07 pts/1    00:00:00 grep --color=auto java</span><br></pre></td></tr></tbody></table></figure><h2 id="查看特定进程的数量"><a href="#查看特定进程的数量" class="headerlink" title="查看特定进程的数量"></a>查看特定进程的数量</h2><p>如查看java进程的数量,<code>ps -ef | grep java| wc -l</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java| wc -l</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h2 id="查看线程是否存在死锁"><a href="#查看线程是否存在死锁" class="headerlink" title="查看线程是否存在死锁"></a>查看线程是否存在死锁</h2><p>查看线程是否存在死锁，<code>jstack -l pid</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack -l 124146</span><br><span class="line">2020-05-02 10:13:38</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f27f013c000 nid=0x1e4f9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f27f012d000 nid=0x1e4f8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007f27f004b800 nid=0x1e4f3 waiting on condition [0x00007f27f7274000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看某个进程的线程数"><a href="#查看某个进程的线程数" class="headerlink" title="查看某个进程的线程数"></a>查看某个进程的线程数</h2><p><code>ps -efL | grep [PID] | wc -l</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -efL | grep 124146 | wc -l</span><br><span class="line">12</span><br></pre></td></tr></tbody></table></figure><p>查看具体有哪些线程用<code>ps -Lp [pid] cu</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 124146 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     124146 124146  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 java</span><br><span class="line">root     124146 124147  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:01 java</span><br><span class="line">root     124146 124148  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 VM Thread</span><br><span class="line">root     124146 124149  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Reference Handl</span><br><span class="line">root     124146 124150  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Finalizer</span><br><span class="line">root     124146 124151  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Signal Dispatch</span><br><span class="line">root     124146 124152  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C2 CompilerThre</span><br><span class="line">root     124146 124153  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C1 CompilerThre</span><br><span class="line">root     124146 124154  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Service Thread</span><br><span class="line">root     124146 124155  0.1   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:05 VM Periodic Tas</span><br><span class="line">root     124146 125362  0.0   11  2.5 2489116 35724 pts/0   Sl+  10:13   0:00 Attach Listener</span><br></pre></td></tr></tbody></table></figure><h2 id="统计所有的log文件中，包含Error字符的行"><a href="#统计所有的log文件中，包含Error字符的行" class="headerlink" title="统计所有的log文件中，包含Error字符的行"></a>统计所有的log文件中，包含Error字符的行</h2><p><code>find / -type f -name "*.log" | xargs grep "ERROR"</code>，这个在排查问题过程中比较有用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -type f -name "*.log" | xargs grep "ERROR"</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,857 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,859 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 15:23:19,037 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="应用启动时指定JVM参数"><a href="#应用启动时指定JVM参数" class="headerlink" title="应用启动时指定JVM参数"></a>应用启动时指定JVM参数</h2><p><code>java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m arthas-demo.jar</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m  arthas-demo.jar</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=64m; support was removed in 8.0</span><br><span class="line">157518=2*3*3*3*2917</span><br><span class="line">illegalArgumentCount:  1, number is: -187733, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -102156, need &gt;= 2</span><br><span class="line">173379=3*57793</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用linux命令时，如果想看帮助可以使用<code>--help</code>或者<code>man</code>查看帮助信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep --help</span><br><span class="line">用法: grep [选项]... PATTERN [FILE]...</span><br><span class="line">在每个 FILE 或是标准输入中查找 PATTERN。</span><br><span class="line">默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。</span><br><span class="line">例如: grep -i 'hello world' menu.h main.c</span><br><span class="line">...</span><br><span class="line">[root@localhost ~]# man grep</span><br><span class="line"></span><br><span class="line">GREP(1)                                                        General Commands Manual                                                        GREP(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       grep, egrep, fgrep - 打印匹配给定模式的行</span><br><span class="line"></span><br><span class="line">总览 SYNOPSIS</span><br><span class="line">       grep [options] PATTERN [FILE...]</span><br><span class="line">       grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br><span class="line"></span><br><span class="line">描述 DESCRIPTION</span><br><span class="line">       Grep    搜索以    FILE    命名的文件输入   (或者是标准输入，如果没有指定文件名，或者给出的文件名是   -   的话)，寻找含有与给定的模式   PATTERN</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left">类别</th><th align="left">监控命令</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">内存瓶颈</td><td align="left">free</td><td align="left">查看内存使用</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">vmstat 3(间隔时间) 100(监控次数)</td><td align="left">查看swap in/out详细定位是否存在性能瓶颈</td><td align="left">推荐使用</td></tr><tr><td align="left"></td><td align="left">sar -r 3</td><td align="left">和free命令类似，查看内存的使用情况，但是不包含swap的情况</td><td align="left"></td></tr><tr><td align="left">cpu瓶颈</td><td align="left">top -H</td><td align="left">按照cpu消耗高低进行排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -Lp 进程号 cu</td><td align="left">查看某个进程的cpu消耗排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/cpuinfo |grep ‘processor’|wc -l</td><td align="left">查看cpu核数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看cpu总体消耗，包括分项消耗如user,system,idle,nice等消耗</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top 然后shift+h:显示java线程，然后shift+M:按照内存使用进行排序；shift+P:按照cpu时间排序;shift+T:按照cpu累计使用时间排序多核cpu，按“1”进入top视图</td><td align="left">专项性能排查，多核CPU主要看CUP各个内核的负载情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -u 3(间隔时间)</td><td align="left">查看cpu总体消耗占比</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -q</td><td align="left">查看cpu load</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top -b -n 1 | awk ‘{if (NR&lt;=7)print;else if($8==”D”){print;count++}}END{print “Total status D:”count}’</td><td align="left">计算在cpu load里面的uninterruptedsleep的任务数量 uninterruptedsleep的任务会被计入cpu load，如磁盘堵塞</td><td align="left"></td></tr><tr><td align="left">网络瓶颈</td><td align="left">cat /var/log/messages</td><td align="left">查看内核日志，查看是否丢包</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">watch more /proc/net/dev</td><td align="left">用于定位丢包，错包情况，以便看网络瓶颈</td><td align="left">重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限</td></tr><tr><td align="left"></td><td align="left">sar -n SOCK</td><td align="left">查看网络流量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -na|grep ESTABLISHED|wc -l</td><td align="left">查看tcp连接成功状态的数量</td><td align="left">此命令特别消耗cpu，不适合进行长时间监控数据收集</td></tr><tr><td align="left"></td><td align="left">netstat -na|awk’{print $6}’|sort |uniq -c |sort -nr</td><td align="left">看tcp各个状态数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -i</td><td align="left">查看网络错误</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ss state ESTABLISHED| wc -l</td><td align="left">更高效地统计tcp连接状态为ESTABLISHED的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/net/snmp</td><td align="left">查看和分析240秒内网络包量，流量，错包，丢包</td><td align="left">用于计算重传率<code>tcpetr=RetransSegs/OutSegs</code></td></tr><tr><td align="left"></td><td align="left">ping $ip</td><td align="left">测试网络性能</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">traceroute $ip</td><td align="left">查看路由经过的地址</td><td align="left">常用于定位网络在各个路由区段的耗时</td></tr><tr><td align="left"></td><td align="left">dig $域名</td><td align="left">查看域名解析地址</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">dmesg</td><td align="left">查看系统内核日志</td><td align="left"></td></tr><tr><td align="left">磁盘瓶颈</td><td align="left">iostat -x -k -d 1</td><td align="left">详细列出磁盘的读写情况</td><td align="left">当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注iowait占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注await，表示磁盘的响应时间以便小于5ms</td></tr><tr><td align="left"></td><td align="left">iostat -x</td><td align="left">查看系统各个磁盘的读写性能</td><td align="left">重点关注await和iowait的cpu占比</td></tr><tr><td align="left"></td><td align="left">iotop</td><td align="left">查看哪个进程在大量读取IO</td><td align="left">一般先通过iostat查看是否存在io瓶颈，再定位哪个进程在大量读取IO</td></tr><tr><td align="left"></td><td align="left">df -hl</td><td align="left">查看磁盘剩余空间</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">du -sh</td><td align="left">查看磁盘使用了多少空间</td><td align="left"></td></tr><tr><td align="left">应用瓶颈</td><td align="left">ps -ef</td><td align="left">grep java</td><td align="left">查看某个进程的id号</td></tr><tr><td align="left"></td><td align="left">ps -ef | grep httpd| wc -l</td><td align="left">查看特定进程的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat ***.log | grep ***Exception| wc -l</td><td align="left">统计日志文件中包含特定异常数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstack -l pid</td><td align="left">用于查看线程是否存在死锁</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">awk’{print $8}’ 2017-05-22-access_log|egrep ‘301|302’| wc -l</td><td align="left">统计log中301、302状态码的行数，$8表示第八列是状态码，可以根据实际情况更改</td><td align="left">常用于应用故障定位</td></tr><tr><td align="left"></td><td align="left">grep ‘wholesaleProductDetailNew’ cookie_log | awk ‘{if($10==”200”)}’print}’</td><td align="left">awk ‘print $12’ | more</td><td align="left">打印包含特定数据的12列数据</td></tr><tr><td align="left"></td><td align="left">grep “2017:05:22” cookielog | awk ‘($12&gt;0.3){print 8}’ | sort &gt; 目录地址</td><td align="left">对apache或者nginx访问log进行响应时间排序，$12表示cookie log中的12列表示响应时间 用于排查是否是由于是某些访问超长造成整体的RT变长</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">grep -v ‘HTTP/1.1” 200’</td><td align="left">取出非200响应码的URL</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">pgm -A -f $应用集群名称 “grep “‘301’ log文件地址 | wc -l”</td><td align="left">查看整个集群的log中301状态码的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -efL | grep [PID] | wc -l</td><td align="left">查看某个进程创建的线程数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">find / -type f -name “*.log” | xargs grep “ERROR”</td><td align="left">统计所有的log文件中，包含Error字符的行</td><td align="left">这个在排查问题过程中比较有用</td></tr><tr><td align="left"></td><td align="left">jstat -gc [pid]</td><td align="left">查看gc情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcnew [pid]</td><td align="left">查看young区的内存使用情况，包括MTT(最大交互次数就被交换到old区)，TT是目前已经交换的次数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcold</td><td align="left">查看old区的内存使用情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -J-d64 -dump:format=b,file=dump.bin PID</td><td align="left">dump出内存快照</td><td align="left">-J-d64防止jmap导致虚拟机crash(jdk6有bug)</td></tr><tr><td align="left"></td><td align="left">-XX:+HeapDumpOnOutOfMemeryError</td><td align="left">在java启动时加入，当出现内存溢出时，存储内存快照</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -histo [pid]</td><td align="left">按照对象内存大小排序</td><td align="left">注意会导致full gc</td></tr><tr><td align="left"></td><td align="left">gcore [pid]</td><td align="left">导出完成的内存快照</td><td align="left">通常和<code>jmap -permstat /opt/**/java gcore.bin</code>一起使用，将core dump转换成heap dump</td></tr><tr><td align="left"></td><td align="left">-XX:HeapDumpPath=/home/logs -Xloggc:/home/log/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</td><td align="left">在Java启动参数中加入，打印gc日志</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">-server -Xms4000m -Xmx4000m -Xmn1500m -Xss256k -XX:PermSize=340m -XX:MaxPermSize=340m -XX:+UseConcMarkSweepGC</td><td align="left">调整JVM堆大小</td><td align="left">xss是栈大小</td></tr></tbody></table><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951442.png" alt="Image"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951481.png" alt="Image"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951399.png" alt="Image"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951517.png" alt="Image"></p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><div class="post-share"><div class="social-share" data-image="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Spring 事务失效的 12 种场景</div></div><div class="info-2"><div class="info-item-1">太坑了！聊聊 Spring 事务失效的 12 种场景前言 对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。 在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。 确实，spring事务用起来贼爽，就用一个简单的注解：@Transactional，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。 但如果你使用不当，它也会坑你于无形。 今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。 一 事务不生效1.访问权限问题众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。 但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如： 123456789@Servicepublic class UserService { @Transactional private...</div></div></div></a><a class="pagination-related" href="/posts/3028893647/" title="SpringBoot 参数校验组件"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">SpringBoot 参数校验组件</div></div><div class="info-2"><div class="info-item-1">一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。 最普通的做法就像下面这样。我们通过 if/else 语句对请求的每一个参数一一校验。 这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。 但是，不太建议这样来写，这样的代码明显违背了 单一职责原则。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！ 实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！ 废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。 不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。 并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/3028893647/" title="SpringBoot 参数校验组件"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">SpringBoot 参数校验组件</div></div><div class="info-2"><div class="info-item-1">一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。 最普通的做法就像下面这样。我们通过 if/else 语句对请求的每一个参数一一校验。 这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。 但是，不太建议这样来写，这样的代码明显违背了 单一职责原则。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！ 实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！ 废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。 不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。 并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-...</div></div></div></a><a class="pagination-related" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">Spring 事务失效的 12 种场景</div></div><div class="info-2"><div class="info-item-1">太坑了！聊聊 Spring 事务失效的 12 种场景前言 对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。 在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。 确实，spring事务用起来贼爽，就用一个简单的注解：@Transactional，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。 但如果你使用不当，它也会坑你于无形。 今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。 一 事务不生效1.访问权限问题众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。 但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如： 123456789@Servicepublic class UserService { @Transactional private...</div></div></div></a><a class="pagination-related" href="/posts/2853285209/" title="为什么要用消息队列？你项目中是怎么用的"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">为什么要用消息队列？你项目中是怎么用的</div></div><div class="info-2"><div class="info-item-1">为什么要用消息队列？你项目中是怎么用的？包含原理+BAT案例实践，看完需要5分钟 本文内容预览： 是什么？为什么？1.1 什么是消息队列1.2 为什么要使用消息队列1.3 引入消息队列的带来了哪些问题 怎么样？2.1 支撑七年双11零故障的RocketMQ2.2 快手万亿级kafka集群的平滑扩容2.3 快手/美团对kafka缓存污染的优化2.4 CMQ在微信红包支付场景下的应用 Part1是什么？为什么？1什么是消息队列说到Java中的队列应该都不会陌生。其具有通过先进先出，或者双端进出的方式进行数据管理；通过阻塞以达到自动平衡负载的功能。 消息队列之所以以队列命名，起初也是因为其功能和操作，和java的本地队列有相似之处。所以，我们可以简单的认为消息队列就是为了满足分布式下各服务之间的数据传输、管理和消费的一种中间服务。 2为什么要使用消息队列问：你们的系统中为什么要引入消息队列？ 我们总归需要知晓消息队列的使用价值，以及自己的业务场景下的实际痛点才能回答为什么要用消息队列这个问题，才能回答系统引入消息队列的价值所在。 系统间解耦以前几天在后台和关注公号的一个大佬讨论...</div></div></div></a><a class="pagination-related" href="/posts/209595582/" title="如何使错误日志更加方便排查问题"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何使错误日志更加方便排查问题</div></div><div class="info-2"><div class="info-item-1">作者 | 琴水玉 来源 | https://cnblogs.com/lovesqcc/p/4319594.html 在程序中打错误日志的主要目标是为更好地排查问题和解决问题提供重要线索和指导。但是在实际中打的错误日志内容和格式变化多样，错误提示上可能残缺不全、没有相关背景、不明其义，使得排查解决问题成为非常不方便或者耗时的操作。而实际上，如果编程的时候稍加用心，就会减少排查问题的很多无用功。 在阐述如何编写有效的错误日志之前， 了解错误是怎么产生的， 非常重要。 错误是如何炼成的 对于当前系统来说， 错误的产生由三个地方引入： 1.上层系统引入的非法参数。对于非法参数引入的错误， 可以通过参数校验和前置条件校验来截获错误； 2.与下层系统交互产生的错误。与下层交互产生的错误， 有两种： a.下层系统处理成功了，但是通信出错了， 这样会导致子系统之间的数据不一致； 对于这种情况， 可以采用超时补偿机制，预先将任务记录下来，通过定时任务在后续将数据订正过来。 更好的设计方案 ？ b.通信成功了，但是下层处理出错了。 对于这种情况， 需要与下层开发人员沟通， 协调子系统之间的交互； ...</div></div></div></a><a class="pagination-related" href="/posts/312572753/" title="如何彻底理解红黑树"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何彻底理解红黑树</div></div><div class="info-2"><div class="info-item-1">作者**：linzworld cnblogs.com/linzworld/p/13720477.html 前言本文主要讲解下最近一直听到的红黑树，看看究竟是什么神仙鬼怪。 二叉树满足以下两个条件的树就是二叉树： 本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 简单地理解，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。 二叉查找树要了解红黑树之前，免不了先看下二叉查找树是什么。 维基百科上的定义二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节...</div></div></div></a><a class="pagination-related" href="/posts/1362641175/" title="服务端如何防止订单重复支付"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">服务端如何防止订单重复支付</div></div><div class="info-2"><div class="info-item-1">服务端如何防止订单重复支付！ 作者：废物大师兄 www.cnblogs.com/cjsblog/p/14516909.html 如图是一个简化的下单流程，首先是提交订单，然后是支付。支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互，支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。 这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好，总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新，这个时候有可能产生投诉，或者用户重复支付。 由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单 为了防止掉单，这里可以这样处理： 1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。 2、支付中心这边要自己定义一个超时时间（...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小白</div><div class="author-info-description">这里是小白的小天地，简单记录自己的编程笔记、学习心得和日常点滴，分享一路成长的思考与收获。</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%93%B6%E9%A2%88"><span class="toc-number">1.</span> <span class="toc-text">内存瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#free"><span class="toc-number">1.1.</span> <span class="toc-text">free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4-swap-space"><span class="toc-number">1.1.1.</span> <span class="toc-text">交换空间(swap space)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vmstat%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">vmstat（推荐）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#procs"><span class="toc-number">1.2.1.</span> <span class="toc-text">procs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memory"><span class="toc-number">1.2.2.</span> <span class="toc-text">memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap"><span class="toc-number">1.2.3.</span> <span class="toc-text">swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io"><span class="toc-number">1.2.4.</span> <span class="toc-text">io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system"><span class="toc-number">1.2.5.</span> <span class="toc-text">system</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU"><span class="toc-number">1.2.6.</span> <span class="toc-text">CPU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sar"><span class="toc-number">1.3.</span> <span class="toc-text">sar</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CPU%E7%93%B6%E9%A2%88"><span class="toc-number">2.</span> <span class="toc-text">CPU瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%BA%E5%99%A8cpu%E6%A0%B8%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">查看机器cpu核数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BCPU%E4%BF%A1%E6%81%AF%EF%BC%88%E5%9E%8B%E5%8F%B7%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">查看CPU信息（型号）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%A9%E7%90%86CPU%E4%B8%AA%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">查看物理CPU个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA%E7%89%A9%E7%90%86CPU%E4%B8%ADcore%E7%9A%84%E4%B8%AA%E6%95%B0-%E5%8D%B3%E6%A0%B8%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">查看每个物理CPU中core的个数(即核数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%80%BB%E8%BE%91CPU%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">查看逻辑CPU的个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#top"><span class="toc-number">2.2.</span> <span class="toc-text">top</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%9C%A8cpu-load%E9%87%8C%E9%9D%A2%E7%9A%84uninterruptedsleep%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%95%B0%E9%87%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">计算在cpu load里面的uninterruptedsleep的任务数量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sar-1"><span class="toc-number">2.3.</span> <span class="toc-text">sar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%BA%BF%E4%B8%8A%E6%9C%80%E8%80%97CPU%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">定位线上最耗CPU的线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.4.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87top%E5%91%BD%E4%BB%A4%E6%89%BE%E5%88%B0%E6%9C%80%E8%80%97%E6%97%B6%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">通过top命令找到最耗时的进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%9C%80%E8%80%97CUP%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">找到进程中最耗CUP的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8Bid%E7%9A%84%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E7%A0%81"><span class="toc-number">2.4.4.</span> <span class="toc-text">获取线程id的十六进制码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88%E4%BF%A1%E6%81%AF"><span class="toc-number">2.4.5.</span> <span class="toc-text">查看线程堆栈信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%93%B6%E9%A2%88"><span class="toc-number">3.</span> <span class="toc-text">网络瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E4%B8%A2%E5%8C%85%EF%BC%8C%E9%94%99%E5%8C%85%E6%83%85%E5%86%B5"><span class="toc-number">3.1.</span> <span class="toc-text">定位丢包，错包情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E7%BB%8F%E8%BF%87%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">查看路由经过的地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E9%94%99%E8%AF%AF"><span class="toc-number">3.3.</span> <span class="toc-text">查看网络错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E9%87%8D%E4%BC%A0%E7%8E%87"><span class="toc-number">3.4.</span> <span class="toc-text">包的重传率</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%93%B6%E9%A2%88"><span class="toc-number">4.</span> <span class="toc-text">磁盘瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.</span> <span class="toc-text">查磁盘空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%89%A9%E4%BD%99%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.1.</span> <span class="toc-text">查看磁盘剩余空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%B7%B2%E4%BD%BF%E7%94%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">4.1.2.</span> <span class="toc-text">查看磁盘已使用空间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">4.2.</span> <span class="toc-text">查看磁盘读写情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E6%80%BB%E4%BD%93%E8%AF%BB%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">4.2.1.</span> <span class="toc-text">查看磁盘总体读写情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E8%AF%A6%E7%BB%86%E8%AF%BB%E5%86%99%E6%83%85%E5%86%B5"><span class="toc-number">4.2.2.</span> <span class="toc-text">查看磁盘详细读写情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%80%E8%80%97IO%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">查看最耗IO的进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%93%B6%E9%A2%88"><span class="toc-number">5.</span> <span class="toc-text">应用瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84PID"><span class="toc-number">5.1.</span> <span class="toc-text">查看某个进程的PID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%B9%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">5.2.</span> <span class="toc-text">查看特定进程的数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%AD%BB%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">查看线程是否存在死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">查看某个进程的线程数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%89%80%E6%9C%89%E7%9A%84log%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E5%8C%85%E5%90%ABError%E5%AD%97%E7%AC%A6%E7%9A%84%E8%A1%8C"><span class="toc-number">5.5.</span> <span class="toc-text">统计所有的log文件中，包含Error字符的行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E6%8C%87%E5%AE%9AJVM%E5%8F%82%E6%95%B0"><span class="toc-number">5.6.</span> <span class="toc-text">应用启动时指定JVM参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2371781713/" title="学习资料推荐">学习资料推荐</a><time datetime="2025-08-10T21:28:35.000Z" title="Created 2025-08-10 13:28:35">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/187821551/" title="SSH问题经验">SSH问题经验</a><time datetime="2025-08-10T07:58:13.000Z" title="Created 2025-08-09 23:58:13">2025-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3028893647/" title="SpringBoot 参数校验组件">SpringBoot 参数校验组件</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1696090382/" title="Java后端线上问题排查常用命令收藏">Java后端线上问题排查常用命令收藏</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景">Spring 事务失效的 12 种场景</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 小白 </span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">京ICP备2023004911号-1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>