<!DOCTYPE html><html lang="zh-cn" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>高并发场景下，到底先更新缓存还是先更新数据库？ | 小白的编程札记</title><meta name="author" content=" 小白 "><meta name="copyright" content=" 小白 "><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高并发场景下，到底先更新缓存还是先更新数据库？1  在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。 为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。  Cache asideCache aside也就是旁路缓存，是比较常用的缓存策略。 （1）读请求常见流程 Cache aside 读请"><meta property="og:type" content="article"><meta property="og:title" content="高并发场景下，到底先更新缓存还是先更新数据库？"><meta property="og:url" content="https://voidbytes.com/posts/3795959674/index.html"><meta property="og:site_name" content="小白的编程札记"><meta property="og:description" content="高并发场景下，到底先更新缓存还是先更新数据库？1  在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。 为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。  Cache asideCache aside也就是旁路缓存，是比较常用的缓存策略。 （1）读请求常见流程 Cache aside 读请"><meta property="og:locale"><meta property="og:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><meta property="article:published_time" content="2023-08-24T08:00:00.000Z"><meta property="article:modified_time" content="2023-08-24T08:00:00.000Z"><meta property="article:author" content=" 小白 "><meta property="article:tag" content="转载"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "高并发场景下，到底先更新缓存还是先更新数据库？",
  "url": "https://voidbytes.com/posts/3795959674/",
  "image": "https://voidbytes.com/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg",
  "datePublished": "2023-08-24T08:00:00.000Z",
  "dateModified": "2023-08-24T08:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": " 小白 ",
      "url": "https://voidbytes.com"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://voidbytes.com/posts/3795959674/index.html"><link rel="preconnect"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="/pluginsSrc/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>(() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-2253275085764952",enable_page_level_ads:"true"})</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3d9a712cb35c03011599a3cbebc08968";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
btf.addGlobalFn('pjaxComplete', () => {
  _hmt.push(['_trackPageview',window.location.pathname])
}, 'baidu_analytics')</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DNRXCK1KS8"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-DNRXCK1KS8')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-DNRXCK1KS8', {'page_path': window.location.pathname})
}, 'google_analytics')</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;038395b9390c4140975c022799210743&quot;}"></script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"No results found for: ${query}","hits_stats":"${hits} articles found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: '/pluginsSrc/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"高并发场景下，到底先更新缓存还是先更新数据库？",isHighlightShrink:!1,isToc:!0,pageType:"post"}</script><meta name="generator" content="Hexo 7.3.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="小白的编程札记" type="application/atom+xml"><link rel="alternate" href="/rss2.xml" title="小白的编程札记" type="application/rss+xml"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://today.voidbytes.com/pic/today.webp)"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">小白的编程札记</span></a><a class="nav-page-title" href="/"><span class="site-name">高并发场景下，到底先更新缓存还是先更新数据库？</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span> Back to Home</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><i class="fa-fw fas fa-subway"></i><span> Travelling</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> Links</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">高并发场景下，到底先更新缓存还是先更新数据库？</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-24T08:00:00.000Z" title="Updated 2023-08-24 00:00:00">2023-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%AC%E8%BD%BD/">转载</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">1.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>5mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:500,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2023-08-24 00:00:00&quot;}" hidden></div><h1 id="高并发场景下，到底先更新缓存还是先更新数据库？"><a href="#高并发场景下，到底先更新缓存还是先更新数据库？" class="headerlink" title="高并发场景下，到底先更新缓存还是先更新数据库？"></a>高并发场景下，到底先更新缓存还是先更新数据库？</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。</p><p>为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510138.png" alt="Image"></p><h2 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h2><p><code>Cache aside</code>也就是<code>旁路缓存</code>，是比较常用的缓存策略。</p><p><strong>（1）<code>读请求</code>常见流程</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510215.png" alt="Image">Cache aside 读请求</p><p>应用首先会判断缓存是否有该数据，缓存命中直接返回数据，缓存未命中即缓存穿透到数据库，从数据库查询数据然后回写到缓存中，最后返回数据给客户端。</p><p><strong>（2）<code>写请求</code>常见流程</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510222.png" alt="Image">Cache aside 写请求</p><p>首先更新数据库，然后从缓存中删除该数据。</p><p>看了写请求的图之后，有些同学可能要问了：为什么要删除缓存，直接更新不就行了？这里涉及到几个坑，我们一步一步踩下去。</p><h2 id="Cache-aside踩坑"><a href="#Cache-aside踩坑" class="headerlink" title="Cache aside踩坑"></a>Cache aside踩坑</h2><p>Cache aside策略如果用错就会遇到深坑，下面我们来逐个踩。</p><p><strong>踩坑一：先更新数据库，再更新缓存</strong></p><p>如果同时有两个<code>写请求</code>需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510240.png" alt="Image">先更新数据库，再更新缓存</p><p>如上图的执行过程：</p><p>（1）<code>写请求1</code>更新数据库，将 age 字段更新为18；</p><p>（2）<code>写请求2</code>更新数据库，将 age 字段更新为20；</p><p>（3）<code>写请求2</code>更新缓存，缓存 age 设置为20；</p><p>（4）<code>写请求1</code>更新缓存，缓存 age 设置为18；</p><p>执行完预期结果是数据库 age 为20，缓存 age 为20，结果缓存 age为18，这就造成了缓存数据不是最新的，出现了脏数据。</p><p><strong>踩坑二：先删缓存，再更新数据库</strong></p><p>如果<code>写请求</code>的处理流程是<code>先删缓存再更新数据库</code>，在一个<code>读请求</code>和一个<code>写请求</code>并发场景下可能会出现数据不一致情况。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246.png" alt="Image">先删缓存，再更新数据库</p><p>如上图的执行过程：</p><p>（1）<code>写请求</code>删除缓存数据；</p><p>（2）<code>读请求</code>查询缓存未击中(Hit Miss)，紧接着查询数据库，将返回的数据回写到缓存中；</p><p>（3）<code>写请求</code>更新数据库。</p><p>整个流程下来发现<code>数据库</code>中age为20，<code>缓存</code>中age为18，缓存和数据库数据不一致，缓存出现了脏数据。</p><p><strong>踩坑三：先更新数据库，再删除缓存</strong></p><p>在实际的系统中针对<code>写请求</code>还是推荐<code>先更新数据库再删除缓存</code>，但是在理论上还是存在问题，以下面这个例子说明。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246-2891910.png" alt="Image">先更新数据库，再删除缓存</p><p>如上图的执行过程：</p><p>（1）<code>读请求</code>先查询缓存，缓存未击中，查询数据库返回数据；</p><p>（2）<code>写请求</code>更新数据库，删除缓存；</p><p>（3）<code>读请求</code>回写缓存；</p><p>整个流程操作下来发现<code>数据库age为20</code>，<code>缓存age为18</code>，即数据库与缓存不一致，导致应用程序从缓存中读到的数据都为旧数据。</p><p>但我们仔细想一下，上述问题发生的概率其实非常低，因为通常数据库更新操作比内存操作耗时多出几个数量级，上图中最后一步回写缓存（set age 18）速度非常快，通常会在更新数据库之前完成。</p><p>如果这种极端场景出现了怎么办？我们得想一个兜底的办法：<code>缓存数据设置过期时间</code>。通常在系统中是可以允许少量的数据短时间不一致的场景出现。</p><h2 id="Read-through"><a href="#Read-through" class="headerlink" title="Read through"></a>Read through</h2><p>在 Cache Aside 更新模式中，应用代码需要维护两个数据源头：一个是缓存，一个是数据库。而在 <code>Read-Through</code> 策略下，应用程序无需管理缓存和数据库，只需要将数据库的同步委托给缓存提供程序 <code>Cache Provider</code> 即可。所有数据交互都是通过<code>抽象缓存层</code>完成的。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510187.png" alt="Image">Read-Through流程</p><p>如上图，应用程序只需要与<code>Cache Provider</code>交互，不用关心是从缓存取还是数据库。</p><p>在进行大量读取时，<code>Read-Through</code> 可以减少数据源上的负载，也对缓存服务的故障具备一定的弹性。如果缓存服务挂了，则缓存提供程序仍然可以通过直接转到数据源来进行操作。</p><p><code>Read-Through 适用于多次请求相同数据的场景</code>，这与 Cache-Aside 策略非常相似，但是二者还是存在一些差别，这里再次强调一下：</p><ul><li>在 Cache-Aside 中，应用程序负责从数据源中获取数据并更新到缓存。</li><li>在 Read-Through 中，此逻辑通常是由独立的缓存提供程序（Cache Provider）支持。</li></ul><h2 id="Write-through"><a href="#Write-through" class="headerlink" title="Write through"></a>Write through</h2><p><code>Write-Through</code> 策略下，当发生数据更新(Write)时，缓存提供程序 <code>Cache Provider</code> 负责更新底层数据源和缓存。</p><p>缓存与数据源保持一致，并且写入时始终通过<code>抽象缓存层</code>到达数据源。</p><p><code>Cache Provider</code>类似一个代理的作用。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230825000426632.png" alt="Image">Write-Through流程</p><h2 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h2><p><code>Write behind</code>在一些地方也被成为<code>Write back</code>， 简单理解就是：应用程序更新数据时只更新缓存， <code>Cache Provider</code>每隔一段时间将数据刷新到数据库中。说白了就是<code>延迟写入</code>。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510270.png" alt="Image">Write behind流程</p><p>如上图，应用程序更新两个数据，Cache Provider 会立即写入缓存中，但是隔一段时间才会批量写入数据库中。</p><p>这种方式有优点也有缺点：</p><ul><li><code>优点</code>是数据写入速度非常快，适用于频繁写的场景。</li><li><code>缺点</code>是缓存和数据库不是强一致性，对一致性要求高的系统慎用。</li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>学了这么多，相信大家对缓存更新的策略都已经有了清晰的认识。最后稍稍总结一下。</p><p>缓存更新的策略主要分为三种：</p><ul><li>Cache aside</li><li>Read/Write through</li><li>Write behind</li></ul><p>Cache aside 通常会先更新数据库，然后再删除缓存，为了兜底通常还会将数据设置缓存时间。</p><p>Read/Write through 一般是由一个 Cache Provider 对外提供读写操作，应用程序不用感知操作的是缓存还是数据库。</p><p>Write behind简单理解就是延迟写入，Cache Provider 每隔一段时间会批量输入数据库，优点是应用程序写入速度非常快。</p></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD/">转载</a></div><div class="post-share"><div class="social-share" data-image="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/187821551/" title="SSH问题经验"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">SSH问题经验</div></div><div class="info-2"><div class="info-item-1">SSH 问题经验Permission denied (publickey,gssapi-keyex,gssapi-with-mic)问题描述ssh 客户端 macbook 上通过ssh-keygen -t rsa生成公钥id_rsa.pub和私钥id_rsa 用键盘复制粘贴到 ssh 服务端的~/.ssh/authorized_keys 然后在客户端上发起连接： 1ssh -i \~/.ssh/id\_rsa heng@服务端IP 报错： 1heng@120.55.54.47: Permission denied (publickey,gssapi-keyex,gssapi-with-mic). lost connection 解法提示是公钥报错，直接复制粘贴有问题，复制粘贴的效果如下： 需要把客户端的公钥文件 scp 到远程的 ssh 服务端上，这里的 - i 是老私钥： 1scp -i \~/.ssh/id\_rsa\_centos \~/.ssh/id\_rsa.pub heng@120.55.54.47:\~/.ssh 也可以在服务端打开密码登录，就不用指定私钥了...</div></div></div></a><a class="pagination-related" href="/posts/3984514586/" title="读 MySQL 源码再看 INSERT 加锁流程"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">读 MySQL 源码再看 INSERT 加锁流程</div></div><div class="info-2"><div class="info-item-1">读 MySQL 源码再看 INSERT 加锁流程有一个问题，我还是彻底被问蒙了。他的问题是这样的： 加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？ 这个问题初看上去很简单，在 RR 隔离级别下，假设要插入的记录不存在，如果先执行select…lock in share mode 语句，很显然会在记录间隙之间加上 GAP 锁，而 insert 语句首先会对记录加插入意向锁，插入意向锁和 GAP 锁冲突，所以不存在幻读；如果先执行 insert 语句后执行 select…lock in share mode 语句，由于 insert 语句在插入记录之后，会对记录加 X 锁，它会阻止 select…lock in share mode 对记录加 S 锁，所以也不存在幻读。两种情况如下所示： 先执行 INSERT 后执行 SELECT： 先执行 SE...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/3028893647/" title="SpringBoot 参数校验组件"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">SpringBoot 参数校验组件</div></div><div class="info-2"><div class="info-item-1">一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。 最普通的做法就像下面这样。我们通过 if/else 语句对请求的每一个参数一一校验。 这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。 但是，不太建议这样来写，这样的代码明显违背了 单一职责原则。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！ 实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！ 废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。 不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。 并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-...</div></div></div></a><a class="pagination-related" href="/posts/1696090382/" title="Java后端线上问题排查常用命令收藏"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">Java后端线上问题排查常用命令收藏</div></div><div class="info-2"><div class="info-item-1">作者：xiaolyuh 本文来源：http://r6d.cn/b97q7 内存瓶颈freefree是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。 free -h -s 3表示每隔三秒输出一次内存情况，命令如下 123456789101112[1014154@cc69dd4c5-4tdb5 ~]$ free total used free shared buff/cache availableMem: 119623656 43052220 45611364 4313760 30960072 70574408Swap: 0 0 0[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3 total used free shared buff/cache availableMem: ...</div></div></div></a><a class="pagination-related" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">Spring 事务失效的 12 种场景</div></div><div class="info-2"><div class="info-item-1">太坑了！聊聊 Spring 事务失效的 12 种场景前言 对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。 在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。 确实，spring事务用起来贼爽，就用一个简单的注解：@Transactional，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。 但如果你使用不当，它也会坑你于无形。 今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。 一 事务不生效1.访问权限问题众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。 但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如： 123456789@Servicepublic class UserService { @Transactional private...</div></div></div></a><a class="pagination-related" href="/posts/2853285209/" title="为什么要用消息队列？你项目中是怎么用的"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">为什么要用消息队列？你项目中是怎么用的</div></div><div class="info-2"><div class="info-item-1">为什么要用消息队列？你项目中是怎么用的？包含原理+BAT案例实践，看完需要5分钟 本文内容预览： 是什么？为什么？1.1 什么是消息队列1.2 为什么要使用消息队列1.3 引入消息队列的带来了哪些问题 怎么样？2.1 支撑七年双11零故障的RocketMQ2.2 快手万亿级kafka集群的平滑扩容2.3 快手/美团对kafka缓存污染的优化2.4 CMQ在微信红包支付场景下的应用 Part1是什么？为什么？1什么是消息队列说到Java中的队列应该都不会陌生。其具有通过先进先出，或者双端进出的方式进行数据管理；通过阻塞以达到自动平衡负载的功能。 消息队列之所以以队列命名，起初也是因为其功能和操作，和java的本地队列有相似之处。所以，我们可以简单的认为消息队列就是为了满足分布式下各服务之间的数据传输、管理和消费的一种中间服务。 2为什么要使用消息队列问：你们的系统中为什么要引入消息队列？ 我们总归需要知晓消息队列的使用价值，以及自己的业务场景下的实际痛点才能回答为什么要用消息队列这个问题，才能回答系统引入消息队列的价值所在。 系统间解耦以前几天在后台和关注公号的一个大佬讨论...</div></div></div></a><a class="pagination-related" href="/posts/209595582/" title="如何使错误日志更加方便排查问题"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何使错误日志更加方便排查问题</div></div><div class="info-2"><div class="info-item-1">作者 | 琴水玉 来源 | https://cnblogs.com/lovesqcc/p/4319594.html 在程序中打错误日志的主要目标是为更好地排查问题和解决问题提供重要线索和指导。但是在实际中打的错误日志内容和格式变化多样，错误提示上可能残缺不全、没有相关背景、不明其义，使得排查解决问题成为非常不方便或者耗时的操作。而实际上，如果编程的时候稍加用心，就会减少排查问题的很多无用功。 在阐述如何编写有效的错误日志之前， 了解错误是怎么产生的， 非常重要。 错误是如何炼成的 对于当前系统来说， 错误的产生由三个地方引入： 1.上层系统引入的非法参数。对于非法参数引入的错误， 可以通过参数校验和前置条件校验来截获错误； 2.与下层系统交互产生的错误。与下层交互产生的错误， 有两种： a.下层系统处理成功了，但是通信出错了， 这样会导致子系统之间的数据不一致； 对于这种情况， 可以采用超时补偿机制，预先将任务记录下来，通过定时任务在后续将数据订正过来。 更好的设计方案 ？ b.通信成功了，但是下层处理出错了。 对于这种情况， 需要与下层开发人员沟通， 协调子系统之间的交互； ...</div></div></div></a><a class="pagination-related" href="/posts/312572753/" title="如何彻底理解红黑树"><div class="cover" style="background:var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-24</div><div class="info-item-2">如何彻底理解红黑树</div></div><div class="info-2"><div class="info-item-1">作者**：linzworld cnblogs.com/linzworld/p/13720477.html 前言本文主要讲解下最近一直听到的红黑树，看看究竟是什么神仙鬼怪。 二叉树满足以下两个条件的树就是二叉树： 本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）； 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2； 简单地理解，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。 二叉查找树要了解红黑树之前，免不了先看下二叉查找树是什么。 维基百科上的定义二叉查找树（英语：Binary Search Tree），也称为二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/34d5bb5d3744e6d1d83703ab0e20da2f_xll.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info-name">小白</div><div class="author-info-description">这里是小白的小天地，简单记录自己的编程笔记、学习心得和日常点滴，分享一路成长的思考与收获。</div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%88%B0%E5%BA%95%E5%85%88%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%E8%BF%98%E6%98%AF%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">高并发场景下，到底先更新缓存还是先更新数据库？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-aside"><span class="toc-number">1.1.</span> <span class="toc-text">Cache aside</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cache-aside%E8%B8%A9%E5%9D%91"><span class="toc-number">1.2.</span> <span class="toc-text">Cache aside踩坑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Read-through"><span class="toc-number">1.3.</span> <span class="toc-text">Read through</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-through"><span class="toc-number">1.4.</span> <span class="toc-text">Write through</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Write-behind"><span class="toc-number">1.5.</span> <span class="toc-text">Write behind</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B"><span class="toc-number">1.6.</span> <span class="toc-text">总结一下</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/2371781713/" title="学习资料推荐">学习资料推荐</a><time datetime="2025-08-10T21:28:35.000Z" title="Created 2025-08-10 13:28:35">2025-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/187821551/" title="SSH问题经验">SSH问题经验</a><time datetime="2025-08-10T07:58:13.000Z" title="Created 2025-08-09 23:58:13">2025-08-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/3028893647/" title="SpringBoot 参数校验组件">SpringBoot 参数校验组件</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1696090382/" title="Java后端线上问题排查常用命令收藏">Java后端线上问题排查常用命令收藏</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/1040342123/" title="Spring 事务失效的 12 种场景">Spring 事务失效的 12 种场景</a><time datetime="2023-08-24T08:00:00.000Z" title="Created 2023-08-24 00:00:00">2023-08-24</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By 小白 </span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">京ICP备2023004911号-1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/pluginsSrc/instant.page/instantpage.js" type="module"></script><script src="/pluginsSrc/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/pluginsSrc/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"></div><script src="/pluginsSrc/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> Loading Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>