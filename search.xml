<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot 参数校验组件</title>
      <link href="/posts/3028893647/"/>
      <url>/posts/3028893647/</url>
      
        <content type="html"><![CDATA[<h1 id="一坨一坨的-if-else-参数校验，终于被-SpringBoot-参数校验组件整干净了！"><a href="#一坨一坨的-if-else-参数校验，终于被-SpringBoot-参数校验组件整干净了！" class="headerlink" title="一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！"></a>一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！</h1><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</p><p>最普通的做法就像下面这样。我们通过 <code>if/else</code> 语句对请求的每一个参数一一校验。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416078.png" alt="Image"></p><p>这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。</p><p>但是，不太建议这样来写，这样的代码明显违背了 <strong>单一职责原则</strong>。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！</p><p>实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！</p><p>废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。</p><p>不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。</p><p>并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-04-21）</p><p>示例项目源代码地址：<a href="https://github.com/CodingDocs/springboot-guide/tree/master/source-code/bean-validation-demo">https://github.com/CodingDocs/springboot-guide/tree/master/source-code/bean-validation-demo</a> 。</p><h2 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h2><p>如果开发普通 Java 程序的的话，你需要可能需要像下面这样依赖：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416103.png" alt="Image"></p><p>不过，相信大家都是使用的 Spring Boot 框架来做开发。</p><p>基于 Spring Boot 的话，就比较简单了，只需要给项目添加上 <code>spring-boot-starter-web</code> 依赖就够了，它的子依赖包含了我们所需要的东西。另外，我们的示例项目中还使用到了 Lombok。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416150.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416141.png" alt="Image"></p><p>但是！！！Spring Boot 2.3 1 之后，<code>spring-boot-starter-validation</code>已经不包括在了 <code>spring-boot-starter-web</code> 中，需要我们手动加上！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416148.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416122.png" alt="Image"></p><h2 id="验证-Controller-的输入"><a href="#验证-Controller-的输入" class="headerlink" title="验证 Controller 的输入"></a>验证 Controller 的输入</h2><h3 id="验证请求体"><a href="#验证请求体" class="headerlink" title="验证请求体"></a>验证请求体</h3><p>验证请求体即使验证被 <code>@RequestBody</code> 注解标记的方法参数。</p><p><strong><code>PersonController</code></strong></p><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。默认情况下，Spring 会将此异常转换为 HTTP Status 400（错误请求）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416061.png" alt="Image"></p><p><strong><code>PersonRequest</code></strong></p><p>我们使用校验注解对请求的参数进行校验！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416101.png" alt="Image"></p><p>正则表达式说明：</p><ul><li><code>^string</code> : 匹配以 string 开头的字符串</li><li><code>string$</code> ：匹配以 string 结尾的字符串</li><li><code>^string$</code> ：精确匹配 string 字符串</li><li><code>(^Man$|^Woman$|^UGM$)</code> : 值只能在 Man,Woman,UGM 这三个值中选择</li></ul><p><strong><code>GlobalExceptionHandler</code></strong></p><p>自定义异常处理器可以帮助我们捕获异常，并进行一些简单的处理。如果对于下面的处理异常的代码不太理解的话，可以查看这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=1924773784&amp;lang=zh_CN&amp;scene=21#wechat_redirect">《SpringBoot 处理异常的几种常见姿势》</a>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416125.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p>下面我通过 <code>MockMvc</code> 模拟请求 <code>Controller</code> 的方式来验证是否生效。当然了，你也可以通过 <code>Postman</code> 这种工具来验证。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416136.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000458295.png" alt="Image"></p><h3 id="验证请求参数"><a href="#验证请求参数" class="headerlink" title="验证请求参数"></a>验证请求参数</h3><p>验证请求参数（Path Variables 和 Request Parameters）即是验证被 <code>@PathVariable</code> 以及 <code>@RequestParam</code> 标记的方法参数。</p><p><strong><code>PersonController</code></strong></p><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416158.png" alt="Image"></p><p><strong><code>ExceptionHandler</code></strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416151.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416180.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416164.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416169.png" alt="Image"></p><h2 id="验证-Service-中的方法"><a href="#验证-Service-中的方法" class="headerlink" title="验证 Service 中的方法"></a>验证 Service 中的方法</h2><p>我们还可以验证任何 Spring Bean 的输入，而不仅仅是 <code>Controller</code> 级别的输入。通过使用<code>@Validated</code>和<code>@Valid</code>注释的组合即可实现这一需求！</p><p>一般情况下，我们在项目中也更倾向于使用这种方案。</p><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416165.png" alt="Image"></p><p><strong>通过测试验证：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416192.png" alt="Image"></p><p>输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name 不能为空</span><br><span class="line">sex 值不在可选范围</span><br></pre></td></tr></tbody></table></figure><h2 id="Validator-编程方式手动进行参数验证"><a href="#Validator-编程方式手动进行参数验证" class="headerlink" title="Validator 编程方式手动进行参数验证"></a>Validator 编程方式手动进行参数验证</h2><p>某些场景下可能会需要我们手动校验并获得校验结果。</p><p>我们通过 <code>Validator</code> 工厂类获得的 <code>Validator</code> 示例。另外，如果是在 Spring Bean 中的话，还可以通过 <code>@Autowired</code> 直接注入的方式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">Validator validate</span><br></pre></td></tr></tbody></table></figure><p>具体使用情况如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000458311.png" alt="Image"></p><p>输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex 值不在可选范围</span><br><span class="line">name 不能为空</span><br></pre></td></tr></tbody></table></figure><h2 id="自定以-Validator-实用"><a href="#自定以-Validator-实用" class="headerlink" title="自定以 Validator(实用)"></a>自定以 Validator(实用)</h2><p>如果自带的校验注解无法满足你的需求的话，你还可以自定义实现注解。</p><h3 id="案例一-校验特定字段的值是否在可选范围"><a href="#案例一-校验特定字段的值是否在可选范围" class="headerlink" title="案例一:校验特定字段的值是否在可选范围"></a>案例一:校验特定字段的值是否在可选范围</h3><p>比如我们现在多了这样一个需求：<code>PersonRequest</code> 类多了一个 <code>Region</code> 字段，<code>Region</code> 字段只能是<code>China</code>、<code>China-Taiwan</code>、<code>China-HongKong</code>这三个中的一个。</p><p><strong>第一步，你需要创建一个注解 <code>Region</code>。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416180-2891856.png" alt="Image"></p><p><strong>第二步，你需要实现 <code>ConstraintValidator</code>接口，并重写<code>isValid</code> 方法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416185.png" alt="Image"></p><p>现在你就可以使用这个注解：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Region</span><br><span class="line">private String region;</span><br></pre></td></tr></tbody></table></figure><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416183.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416223.png" alt="Image"></p><h3 id="案例二-校验电话号码"><a href="#案例二-校验电话号码" class="headerlink" title="案例二:校验电话号码"></a>案例二:校验电话号码</h3><p>校验我们的电话号码是否合法，这个可以通过正则表达式来做，相关的正则表达式都可以在网上搜到，你甚至可以搜索到针对特定运营商电话号码段的正则表达式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber.java</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416200.png" alt="Image"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumberValidator.java</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416210.png" alt="Image"></p><p>搞定，我们现在就可以使用这个注解了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000539686.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416200-2891856.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416239.png" alt="Image"></p><h2 id="使用验证组"><a href="#使用验证组" class="headerlink" title="使用验证组"></a>使用验证组</h2><p>验证组我们基本是不会用到的，也不太建议在项目中使用，理解起来比较麻烦，写起来也比较麻烦。简单了解即可！</p><p>当我们对对象操作的不同方法有不同的验证规则的时候才会用到验证组。</p><p>我写一个简单的例子，你们就能看明白了！</p><p><strong>1.先创建两个接口，代表不同的验证组</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AddPersonGroup {</span><br><span class="line">}</span><br><span class="line">public interface DeletePersonGroup {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2.使用验证组</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416237.png" alt="Image"></p><p>通过测试验证：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416215.png" alt="Image"></p><p>验证组使用下来的体验就是有点反模式的感觉，让代码的可维护性变差了！尽量不要使用！</p><h2 id="常用校验注解总结"><a href="#常用校验注解总结" class="headerlink" title="常用校验注解总结"></a>常用校验注解总结</h2><p><code>JSR303</code> 定义了 <code>Bean Validation</code>（校验）的标准 <code>validation-api</code>，并没有提供实现。<code>Hibernate Validation</code>是对这个规范/规范的实现 <code>hibernate-validator</code>，并且增加了 <code>@Email</code>、<code>@Length</code>、<code>@Range</code> 等注解。<code>Spring Validation</code> 底层依赖的就是<code>Hibernate Validation</code>。</p><p><strong>JSR 提供的校验注解</strong>:</p><ul><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Min(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code> 被注释的元素的大小必须在指定的范围内</li><li><code>@Digits (integer, fraction)</code> 被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code> 被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li><li><code>@Pattern(regex=,flag=)</code> 被注释的元素必须符合指定的正则表达式</li></ul><p><strong>Hibernate Validator 提供的校验注解</strong>：</p><ul><li><code>@NotBlank(message =)</code> 验证字符串非 null，且长度必须大于 0</li><li><code>@Email</code> 被注释的元素必须是电子邮箱地址</li><li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li><li><code>@NotEmpty</code> 被注释的字符串的必须非空</li><li><code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>经常有小伙伴问到：“<code>@NotNull</code> 和 <code>@Column(nullable = false)</code> 两者有什么区别？”</p><p>我这里简单回答一下：</p><ul><li><code>@NotNull</code>是 JSR 303 Bean 验证批注,它与数据库约束本身无关。</li><li><code>@Column(nullable = false)</code> : 是 JPA 声明列为非空的方法。</li></ul><p>总结来说就是即前者用于验证，而后者则用于指示数据库创建表的时候对表的约束。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端线上问题排查常用命令收藏</title>
      <link href="/posts/1696090382/"/>
      <url>/posts/1696090382/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：xiaolyuh</p><p>本文来源：<a href="http://r6d.cn/b97q7">http://r6d.cn/b97q7</a></p></blockquote><h1 id="内存瓶颈"><a href="#内存瓶颈" class="headerlink" title="内存瓶颈"></a>内存瓶颈</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>free</code>是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p><p><code>free -h -s 3</code>表示每隔三秒输出一次内存情况，命令如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      119623656    43052220    45611364     4313760    30960072    70574408</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Mem</code>：是内存的使用情况。</li><li><code>Swap</code>：是交换空间的使用情况。</li><li><code>total</code>：系统总的可用物理内存和交换空间大小。</li><li><code>used</code>：已经被使用的物理内存和交换空间。</li><li><code>free</code>：还有多少物理内存和交换空间可用使用，是真正尚未被使用的物理内存数量。</li><li><code>shared</code>：被共享使用的物理内存大小。</li><li><code>buff/cache</code>：被 buffer（缓冲区） 和 cache（缓存） 使用的物理内存大小。</li><li><code>available</code>：还可以被应用程序使用的物理内存大小，它是从应用程序的角度看到的可用内存数量，available ≈ free + buffer + cache。</li></ul><h3 id="交换空间-swap-space"><a href="#交换空间-swap-space" class="headerlink" title="交换空间(swap space)"></a>交换空间(swap space)</h3><p>swap space 是磁盘上的一块区域，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p><h2 id="vmstat（推荐）"><a href="#vmstat（推荐）" class="headerlink" title="vmstat（推荐）"></a>vmstat（推荐）</h2><p>vmstat（VirtualMeomoryStatistics，虚拟内存统计）是Linux中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视，推荐使用。</p><p><code>vmstat 5 3</code>表示每隔5秒统计一次，一共统计三次。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ vmstat 5 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 8  0      0 45453212 374768 30763728    0    0    14    99    1    1 11 10 78  0  1</span><br><span class="line">10  0      0 45489232 374768 30763360    0    0     2  1275 95118 97908 13 11 75  0  1</span><br><span class="line"> 6  0      0 45452908 374768 30765148    0    0     0  3996 89924 92073 12 10 78  0  1</span><br></pre></td></tr></tbody></table></figure><h3 id="procs"><a href="#procs" class="headerlink" title="procs"></a>procs</h3><p><code>r</code>：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU。<code>b</code>：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p><code>swpd</code>：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。<code>free</code>：表示当前空闲的物理内存。<code>buff</code>：表示缓冲大小，一般对块设备的读写才需要缓冲 <code>Cache</code>：表示缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><code>si</code>：表示数据由磁盘读入内存；通俗的讲就是每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。<code>so</code>：表示由内存写入磁盘，也就是由内存交换区进入内存的数据大小。</p><blockquote><p><strong>!!</strong> 注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</p></blockquote><h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><p><code>bi</code>：表示由块设备读入数据的总量，即读磁盘，单位kb/s <code>bo</code>：表示写到块设备数据的总量，即写磁盘，单位kb/s</p><blockquote><p><strong>!!</strong> 注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈。</p></blockquote><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>in</code>：表示某一时间间隔内观测到的每秒设备终端数。<code>cs</code>：表示每秒产生的上下文切换次数，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p><blockquote><p><strong>!!</strong> 注意：这两个值越大，则由内核消耗的CPU就越多。</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><code>us</code>：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法。<code>sy</code>：表示系统内核进程消耗的CPU时间百分比，一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈。<code>id</code>：表示CPU处在空间状态的时间百分比。<code>wa</code>：表示IP等待所占用的CPU时间百分比，wa值越高，说明I/O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I/O等待严重，引起I/O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的。</p><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>sar和free类似<code>sar -r 3</code>每隔三秒输出一次内存信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -r 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年04月28日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时40分10秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">15时40分13秒    106800   1314960     92.49      2144    573248   4110864    116.82    563664    498888        36</span><br><span class="line">15时40分16秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br><span class="line">15时40分19秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br></pre></td></tr></tbody></table></figure><h1 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h1><h2 id="查看机器cpu核数"><a href="#查看机器cpu核数" class="headerlink" title="查看机器cpu核数"></a>查看机器cpu核数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </span><br><span class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</span><br></pre></td></tr></tbody></table></figure><h3 id="查看CPU信息（型号）"><a href="#查看CPU信息（型号）" class="headerlink" title="查看CPU信息（型号）"></a>查看CPU信息（型号）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">     32  Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz</span><br></pre></td></tr></tbody></table></figure><h3 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure><h3 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "cpu cores"| uniq</span><br><span class="line">cpu cores       : 2</span><br></pre></td></tr></tbody></table></figure><h3 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "processor"| wc -l</span><br><span class="line">32</span><br></pre></td></tr></tbody></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>在Linux内核的操作系统中，进程是根据虚拟运行时间（由进程优先级、nice值加上实际占用的CPU时间进行动态计算得出）进行动态调度的。在执行进程时，需要从用户态转换到内核态，用户空间不能直接操作内核空间的函数。通常要利用系统调用来完成进程调度，而用户空间到内核空间的转换通常是通过软中断来完成的。例如要进行磁盘操作，用户态需要通过系统调用内核的磁盘操作指令，所以CPU消耗的时间被切分成用户态CPU消耗、系统（内核） CPU 消耗，以及磁盘操作 CPU 消耗。执行进程时，需要经过一系列的操作，进程首先在用户态执行，在执行过程中会进行进程优先级的调整（nice），通过系统调用到内核，再通过内核调用，硬中断、软中断，让硬件执行任务。执行完成之后，再从内核态返回给系统调用，最后系统调用将结果返回给用户态的进程。</p><p>top可以查看CPU总体消耗，包括分项消耗，如User，System，Idle，nice等。<code>Shift + H</code>显示java线程；<code>Shift + M</code>按照内存使用排序；<code>Shift + P</code>按照CPU使用时间（使用率）排序；<code>Shift + T</code>按照CPU累积使用时间排序；多核CPU，进入top视图<code>1</code>，可以看到各各CPU的负载情况。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">top - 15:24:11 up 8 days,  7:52,  1 user,  load average: 5.73, 6.85, 7.33</span><br><span class="line">Tasks:  17 total,   1 running,  16 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 13.9 us,  9.2 sy,  0.0 ni, 76.1 id,  0.1 wa,  0.0 hi,  0.1 si,  0.7 st</span><br><span class="line">KiB Mem : 11962365+total, 50086832 free, 38312808 used, 31224016 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 75402760 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">   300 ymmapp    20   0 17.242g 1.234g  14732 S   2.3  1.1   9:40.38 java</span><br><span class="line">     1 root      20   0   15376   1988   1392 S   0.0  0.0   0:00.06 sh</span><br><span class="line">    11 root      20   0  120660  11416   1132 S   0.0  0.0   0:04.94 python</span><br><span class="line">    54 root      20   0   85328   2240   1652 S   0.0  0.0   0:00.00 su</span><br><span class="line">    55 ymmapp    20   0   17432   1808   1232 S   0.0  0.0   0:00.00 bash</span><br><span class="line">    56 ymmapp    20   0   17556   2156   1460 S   0.0  0.0   0:00.03 control.sh</span><br><span class="line">    57 ymmapp    20   0   11880    740    576 S   0.0  0.0   0:00.00 tee</span><br><span class="line">   115 ymmapp    20   0   17556   2112   1464 S   0.0  0.0   0:00.02 control_new_war</span><br><span class="line">   133 root      20   0  106032   4240   3160 S   0.0  0.0   0:00.03 sshd</span><br><span class="line">   134 ymmapp    20   0   17080   6872   3180 S   0.0  0.0   0:01.82 ops-updater</span><br><span class="line">   147 ymmapp    20   0   17956   2636   1544 S   0.0  0.0   0:00.07 control.sh</span><br><span class="line">  6538 ymmapp    20   0  115656  10532   3408 S   0.0  0.0   0:00.46 beidou-agent</span><br><span class="line">  6785 ymmapp    20   0 2572996  22512   2788 S   0.0  0.0   0:03.44 gatherinfo4dock</span><br><span class="line"> 29241 root      20   0  142148   5712   4340 S   0.0  0.0   0:00.04 sshd</span><br><span class="line"> 29243 1014154   20   0  142148   2296    924 S   0.0  0.0   0:00.00 sshd</span><br><span class="line"> 29244 1014154   20   0   15208   2020   1640 S   0.0  0.0   0:00.00 bash</span><br><span class="line"> 32641 1014154   20   0   57364   2020   1480 R   0.0  0.0   0:00.00 top</span><br></pre></td></tr></tbody></table></figure><p>第一行：<code>15:24:11 up 8 days, 7:52, 1 user, load average: 5.73, 6.85, 7.33</code>：15:24:11 系统时间，up 8 days 运行时间，1 user 当前登录用户数，load average 负载均衡情况，分别表示1分钟，5分钟，15分钟负载情况。</p><p>第二行：<code>Tasks: 17 total, 1 running, 16 sleeping, 0 stopped, 0 zombie</code>：总进程数17，运行数1，休眠 16，停止0，僵尸进程0。</p><p>第三行：<code>%Cpu(s): 13.9 us, 9.2 sy, 0.0 ni, 76.1 id, 0.1 wa, 0.0 hi, 0.1 si, 0.7 st</code>：用户空间CPU占比13.9%，内核空间CPU占比9.2%，改变过优先级的进程CPU占比0%，空闲CPU占比76.1，IO等待占用CPU占比0.1%，硬中断占用CPU占比0%，软中断占用CPU占比0.1%,当前VM中的cpu 时钟被虚拟化偷走的比例0.7%。</p><p>第四和第五行表示内存和swap区域的使用情况。</p><p>第七行表示：</p><ul><li><code>PID</code>: 进程id</li><li><code>USER</code>:进程所有者</li><li><code>PR</code>:进程优先级</li><li><code>NI</code>:nice值。负值表示高优先级，正值表示低优先级</li><li><code>VIRT</code>:虚拟内存，进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li><code>RES</code>:常驻内存，进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li><code>SHR</code>:共享内存，共享内存大小，单位kb</li><li><code>S</code>:进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li><code>%CPU</code>:上次更新到现在的CPU时间占用百分比</li><li><code>%MEM</code>:进程使用的物理内存百分比</li><li><code>TIME+</code>:进程使用的CPU时间总计，单位1/100秒</li><li><code>COMMAND</code>:进程名称（命令名/命令行）</li></ul><h3 id="计算在cpu-load里面的uninterruptedsleep的任务数量"><a href="#计算在cpu-load里面的uninterruptedsleep的任务数量" class="headerlink" title="计算在cpu load里面的uninterruptedsleep的任务数量"></a>计算在cpu load里面的uninterruptedsleep的任务数量</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">[root@localhost ~]# top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">top - 15:35:05 up 1 day, 26 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us, 10.0 sy,  0.0 ni, 87.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   104516 free,   777344 used,   539900 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2071152 free,    25996 used.   456028 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">Total status D:</span><br></pre></td></tr></tbody></table></figure><h2 id="sar-1"><a href="#sar-1" class="headerlink" title="sar"></a>sar</h2><p>通过<code>sar -u 3</code>可以查看CUP总体消耗占比：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -u 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月01日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时18分03秒     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">15时18分06秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分09秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分12秒     all      0.17      0.00      0.17      0.00      0.00     99.66</span><br><span class="line">15时18分15秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">15时18分18秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br></pre></td></tr></tbody></table></figure><ul><li><code>%user</code>：用户空间的CPU使用。</li><li><code>%nice</code>：改变过优先级的进程的CPU使用率。</li><li><code>%system</code>：内核空间的CPU使用率。</li><li><code>%iowait</code>：CPU等待IO的百分比 。</li><li><code>%steal</code>：虚拟机的虚拟机CPU使用的CPU。</li><li><code>%idle</code>：空闲的CPU。</li></ul><p>在以上的显示当中，主要看<code>%iowait</code>和<code>%idle</code>：</p><ul><li>若 <code>%iowait</code>的值过高，表示硬盘存在I/O瓶颈；</li><li>若 <code>%idle</code>的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量；</li><li>若 <code>%idle</code>的值持续低于 10，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</li></ul><h2 id="定位线上最耗CPU的线程"><a href="#定位线上最耗CPU的线程" class="headerlink" title="定位线上最耗CPU的线程"></a>定位线上最耗CPU的线程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>启动一个程序。<code>arthas-demo</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br><span class="line">[root@localhost ~]# curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  3743  100  3743    0     0   3022      0  0:00:01  0:00:01 --:--:--  3023</span><br><span class="line">[root@localhost ~]# java -jar arthas-demo.jar</span><br><span class="line">1813=7*7*37</span><br><span class="line">illegalArgumentCount:  1, number is: -180005, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -111175, need &gt;= 2</span><br><span class="line">18505=5*3701</span><br><span class="line">166691=7*23813</span><br><span class="line">105787=11*59*163</span><br><span class="line">60148=2*2*11*1367</span><br><span class="line">196983=3*3*43*509</span><br><span class="line">illegalArgumentCount:  3, number is: -173479, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  4, number is: -112840, need &gt;= 2</span><br><span class="line">39502=2*19751</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><h3 id="通过top命令找到最耗时的进程"><a href="#通过top命令找到最耗时的进程" class="headerlink" title="通过top命令找到最耗时的进程"></a>通过<code>top</code>命令找到最耗时的进程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 11:11:05 up 20:02,  3 users,  load average: 0.09, 0.07, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.7 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   135868 free,   758508 used,   527384 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2070640 free,    26508 used.   475852 avail Mem</span><br><span class="line">Change delay from 3.0 to</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 98344 root      20   0 2422552  23508  12108 S   0.7  1.7   0:00.32 java</span><br><span class="line">     1 root      20   0  194100   6244   3184 S   0.0  0.4   0:20.41 systemd</span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kthreadd</span><br><span class="line">     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">     6 root      20   0       0      0      0 S   0.0  0.0   0:20.25 ksoftirqd/0</span><br></pre></td></tr></tbody></table></figure><p>找到进程号是98344。</p><h3 id="找到进程中最耗CUP的线程"><a href="#找到进程中最耗CUP的线程" class="headerlink" title="找到进程中最耗CUP的线程"></a>找到进程中最耗CUP的线程</h3><p>使用<code>ps -Lp #pid cu</code>命令，查看某个进程中的线程CPU消耗排序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 98344 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      98344  98344  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 java</span><br><span class="line">root      98344  98345  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:04 java</span><br><span class="line">root      98344  98346  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:01 VM Thread</span><br><span class="line">root      98344  98347  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Reference Handl</span><br><span class="line">root      98344  98348  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Finalizer</span><br><span class="line">root      98344  98349  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Signal Dispatch</span><br><span class="line">root      98344  98350  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:05 C2 CompilerThre</span><br><span class="line">root      98344  98351  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 C1 CompilerThre</span><br><span class="line">root      98344  98352  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Service Thread</span><br><span class="line">root      98344  98353  0.1   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:19 VM Periodic Tas</span><br></pre></td></tr></tbody></table></figure><p>看<code>TIME</code>列可以看出那个线程耗费CUP多，根据<code>LWP</code>列可以看到线程的ID号，但是需要转换成16进制才可以查询线程堆栈信息。</p><h3 id="获取线程id的十六进制码"><a href="#获取线程id的十六进制码" class="headerlink" title="获取线程id的十六进制码"></a>获取线程id的十六进制码</h3><p>使用<code>printf '%x\n' 98345</code>命令做进制转换：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf '%x\n' 98345</span><br><span class="line">18029</span><br></pre></td></tr></tbody></table></figure><h3 id="查看线程堆栈信息"><a href="#查看线程堆栈信息" class="headerlink" title="查看线程堆栈信息"></a>查看线程堆栈信息</h3><p>使用jstack获取堆栈信息<code>jstack 98344 | grep -A 10 18029</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack 98344 | grep -A 10 18029</span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fb88404b800 nid=0x18029 waiting on condition [0x00007fb88caab000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=0 tid=0x00007fb8840f2800 nid=0x1802a runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=0 tid=0x00007fb884154000 nid=0x18031 waiting on condition</span><br></pre></td></tr></tbody></table></figure><p>通过命令我们可以看到这个线程的对应的耗时代码是在<code>demo.MathGame.main(MathGame.java:17)</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">grep -B 5 foo file 显示foo及前5行</span><br><span class="line">grep -A 5 foo file 显示foo及后5行</span><br></pre></td></tr></tbody></table></figure><h1 id="网络瓶颈"><a href="#网络瓶颈" class="headerlink" title="网络瓶颈"></a>网络瓶颈</h1><h2 id="定位丢包，错包情况"><a href="#定位丢包，错包情况" class="headerlink" title="定位丢包，错包情况"></a>定位丢包，错包情况</h2><p><code>watch more /proc/net/dev</code>用于定位丢包，错包情况，以便看网络瓶颈，重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# watch -n 2 more /proc/net/dev</span><br><span class="line">Every 2.0s: more /proc/net/dev                                                                                                                                                   Fri May  1 17:16:55 2020</span><br><span class="line"></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   10025     130    0    0    0     0          0         0    10025     130    0    0    0     0       0          0</span><br><span class="line"> ens33: 759098071  569661    0    0    0     0          0         0 19335572  225551    0    0    0     0       0          0</span><br></pre></td></tr></tbody></table></figure><ul><li>最左边的表示接口的名字，Receive表示收包，Transmit表示发送包；</li><li><code>bytes</code>：表示收发的字节数；</li><li><code>packets</code>：表示收发正确的包量；</li><li><code>errs</code>：表示收发错误的包量；</li><li><code>drop</code>：表示收发丢弃的包量；</li></ul><h2 id="查看路由经过的地址"><a href="#查看路由经过的地址" class="headerlink" title="查看路由经过的地址"></a>查看路由经过的地址</h2><p><code>traceroute ip</code>可以查看路由经过的地址，常用来统计网络在各个路由区段的耗时，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# traceroute 14.215.177.38</span><br><span class="line">traceroute to 14.215.177.38 (14.215.177.38), 30 hops max, 60 byte packets</span><br><span class="line"> 1  CD-HZTK5H2.mshome.net (192.168.137.1)  0.126 ms * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  10.250.112.3 (10.250.112.3)  12.587 ms  12.408 ms  12.317 ms</span><br><span class="line"> 4  172.16.227.230 (172.16.227.230)  2.152 ms  2.040 ms  1.956 ms</span><br><span class="line"> 5  172.16.227.202 (172.16.227.202)  11.884 ms  11.746 ms  12.692 ms</span><br><span class="line"> 6  172.16.227.65 (172.16.227.65)  2.665 ms  3.143 ms  2.923 ms</span><br><span class="line"> 7  171.223.206.217 (171.223.206.217)  2.834 ms  2.752 ms  2.654 ms</span><br><span class="line"> 8  182.150.18.205 (182.150.18.205)  5.145 ms  5.815 ms  5.542 ms</span><br><span class="line"> 9  110.188.6.33 (110.188.6.33)  3.514 ms 171.208.199.185 (171.208.199.185)  3.431 ms 171.208.199.181 (171.208.199.181)  10.768 ms</span><br><span class="line">10  202.97.29.17 (202.97.29.17)  29.574 ms 202.97.30.146 (202.97.30.146)  32.619 ms *</span><br><span class="line">11  113.96.5.126 (113.96.5.126)  36.062 ms 113.96.5.70 (113.96.5.70)  35.940 ms 113.96.4.42 (113.96.4.42)  45.859 ms</span><br><span class="line">12  90.96.135.219.broad.fs.gd.dynamic.163data.com.cn (219.135.96.90)  35.680 ms  35.468 ms  35.304 ms</span><br><span class="line">13  14.215.32.102 (14.215.32.102)  35.135 ms 14.215.32.110 (14.215.32.110)  35.613 ms 14.29.117.242 (14.29.117.242)  54.712 ms</span><br><span class="line">14  * 14.215.32.134 (14.215.32.134)  49.518 ms 14.215.32.122 (14.215.32.122)  47.652 ms</span><br><span class="line">15  * * *</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看网络错误"><a href="#查看网络错误" class="headerlink" title="查看网络错误"></a>查看网络错误</h2><p><code>netstat -i</code>可以查看网络错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33            1500   570291      0      0 0        225897      0      0      0 BMRU</span><br><span class="line">lo              65536      130      0      0 0           130      0      0      0 LRU</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Iface</code>: 网络接口名称;</li><li><code>MTU</code>: 最大传输单元，它限制了数据帧的最大长度，不同的网络类型都有一个上限值，如：以太网的MTU是1500；</li><li><code>RX-OK</code>：接收时，正确的数据包数。</li><li><code>RX-ERR</code>：接收时，产生错误的数据包数。</li><li><code>RX-DRP</code>：接收时，丢弃的数据包数。</li><li><code>RX-OVR</code>：接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</li><li><code>TX-OK</code>：发送时，正确的数据包数。</li><li><code>TX-ERR</code>：发送时，产生错误的数据包数。</li><li><code>TX-DRP</code>：发送时，丢弃的数据包数。</li><li><code>TX-OVR</code>：发送时，由于过速而丢失的数据包数。</li><li><code>Flg</code>：标志，B 已经设置了一个广播地址。L 该接口是一个回送设备。M 接收所有数据包（混乱模式）。N 避免跟踪。O 在该接口上，禁用ARP。P 这是一个点到点链接。R 接口正在运行。U 接口处于“活动”状态。</li></ul><h2 id="包的重传率"><a href="#包的重传率" class="headerlink" title="包的重传率"></a>包的重传率</h2><p><code>cat /proc/net/snmp</code>用来查看和分析240秒内网络包量，流量，错包，丢包。通过<code>RetransSegs</code>和<code>OutSegs</code>来计算重传率<code>tcpetr=RetransSegs/OutSegs</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/net/snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 241708 0 0 0 0 0 238724 225517 15 0 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 149 0 0 50 99 0 0 0 0 0 0 0 0 0 147 0 147 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType11 OutType3</span><br><span class="line">IcmpMsg: 50 99 147</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 376 6 0 0 4 236711 223186 292 0 4 0</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">Udp: 1405 438 0 1896 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0</span><br></pre></td></tr></tbody></table></figure><p>重传率=292/223186≈0.13%</p><ul><li>平均每秒新增TCP连接数：通过/proc/net/snmp文件得到最近240秒内PassiveOpens的增量，除以240得到每秒的平均增量；</li><li>机器的TCP连接数 ：通过/proc/net/snmp文件的CurrEstab得到TCP连接数；</li><li>平均每秒的UDP接收数据报：通过/proc/net/snmp文件得到最近240秒内InDatagrams的增量，除以240得到平均每秒的UDP接收数据报；</li><li>平均每秒的UDP发送数据报：通过/proc/net/snmp文件得到最近240秒内OutDatagrams的增量，除以240得到平均每秒的UDP发送数据报；</li></ul><h1 id="磁盘瓶颈"><a href="#磁盘瓶颈" class="headerlink" title="磁盘瓶颈"></a>磁盘瓶颈</h1><h2 id="查磁盘空间"><a href="#查磁盘空间" class="headerlink" title="查磁盘空间"></a>查磁盘空间</h2><h3 id="查看磁盘剩余空间"><a href="#查看磁盘剩余空间" class="headerlink" title="查看磁盘剩余空间"></a>查看磁盘剩余空间</h3><p>查看磁盘剩余空间使用<code>df -hl</code>命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -hl</span><br><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                       678M     0  678M    0% /dev</span><br><span class="line">tmpfs                          695M     0  695M    0% /dev/shm</span><br><span class="line">tmpfs                          695M   28M  667M    4% /run</span><br><span class="line">tmpfs                          695M     0  695M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos_aubin-root   27G  5.6G   22G   21% /</span><br><span class="line">/dev/sda1                     1014M  211M  804M   21% /boot</span><br></pre></td></tr></tbody></table></figure><h3 id="查看磁盘已使用空间"><a href="#查看磁盘已使用空间" class="headerlink" title="查看磁盘已使用空间"></a>查看磁盘已使用空间</h3><p><code>du -sh</code>命令是查看磁盘已使用空间的情况，这里的“已使用的磁盘空间”意思是指定的文件下的整个文件层次结构所使用的空间，在没给定参数的情况下，<code>du</code>报告当前目录所使用的磁盘空间。其实就是显示文件或目录所占用的磁盘空间的情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -sh</span><br><span class="line">64K  </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-h</code>：输出文件系统分区使用的情况，例如：10KB，10MB，10GB等。</li><li><code>-s</code>：显示文件或整个目录的大小，默认单位是KB。</li></ul><blockquote><p><strong>!!</strong> <code>du</code>的详细信息可以通过 <code>man du</code>查看。</p></blockquote><h2 id="查看磁盘读写情况"><a href="#查看磁盘读写情况" class="headerlink" title="查看磁盘读写情况"></a>查看磁盘读写情况</h2><h3 id="查看磁盘总体读写情况"><a href="#查看磁盘总体读写情况" class="headerlink" title="查看磁盘总体读写情况"></a>查看磁盘总体读写情况</h3><p>通<code>iostat</code>查看磁盘总体的读写情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.17</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda               1.56        30.45        39.61    4659620    6060644</span><br><span class="line">scd0              0.00         0.02         0.00       3102          0</span><br><span class="line">dm-0              1.96        30.01        38.42    4591998    5878155</span><br><span class="line">dm-1              0.09         0.09         0.30      13840      45328</span><br></pre></td></tr></tbody></table></figure><ul><li><code>tps</code>：该设备每秒的传输次数。</li><li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li><li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li><li><code>kB_read</code>：读取的总数据量；</li><li><code>kB_wrtn</code>：写入的总数量数据量；</li></ul><h3 id="查看磁盘详细读写情况"><a href="#查看磁盘详细读写情况" class="headerlink" title="查看磁盘详细读写情况"></a>查看磁盘详细读写情况</h3><p>通过<code>iostat -x 1 3</code>可以看到磁盘详细读写情况，没隔一秒输出一次一共输出3次，当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注<code>iowait</code>占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注<code>await</code>，表示磁盘的响应时间以便小于5ms：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat -x 1 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.16</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01     0.49    0.63    0.95    30.59    39.78    89.58     0.34  214.23   49.16  323.48   8.55   1.34</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.02     0.00    98.48     0.00    1.21    1.21    0.00   0.95   0.00</span><br><span class="line">dm-0              0.00     0.00    0.62    1.35    30.15    38.59    69.70     0.91  460.67   49.12  648.54   6.66   1.31</span><br><span class="line">dm-1              0.00     0.00    0.02    0.07     0.09     0.30     8.52     0.04  442.74   95.43  521.17   6.91   0.06</span><br></pre></td></tr></tbody></table></figure><p><code>avg-cpu</code>表示总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值：</p><ul><li><code>%user</code>：CPU处在用户模式下的时间百分比。</li><li><code>%nice</code>：CPU处在带NICE值的用户模式下的时间百分比。</li><li><code>%system</code>：CPU处在系统模式下的时间百分比。</li><li><code>%iowait</code>：CPU等待输入输出完成时间的百分比，如果%iowait的值过高，表示硬盘存在I/O瓶颈。</li><li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li><code>%idle</code>：CPU空闲时间百分比，如果%idle值高，表示CPU较空闲；如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量；如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。。</li></ul><p><code>Device</code>表示设备信息：</p><ul><li><code>rrqm/s</code>：每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li><li><code>wrqm/s</code>：每秒对该设备的写请求被合并次数</li><li><code>r/s</code>：每秒完成的读次数</li><li><code>w/s</code>：每秒完成的写次数</li><li><code>rkB/s</code>：每秒读数据量(kB为单位)</li><li><code>wkB/s</code>：每秒写数据量(kB为单位)</li><li><code>avgrq-sz</code>：平均每次IO操作的数据量(扇区数为单位)</li><li><code>avgqu-sz</code>：平均等待处理的IO请求队列长度</li><li><code>await</code>：平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li><li><code>svctm</code>：平均每次IO请求的处理时间(毫秒为单位)</li><li><code>%util</code>：一秒中有百分之多少的时间用于 I/O如果%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷。<code>idle</code>小于70% IO压力就较大了，一般读取速度有较多的wait。</li></ul><blockquote><p><strong>!!</strong> <code>iostat -xmd 1 3</code>：新增<code>m</code>选项可以在输出是使用<code>M</code>为单位。</p></blockquote><h2 id="查看最耗IO的进程"><a href="#查看最耗IO的进程" class="headerlink" title="查看最耗IO的进程"></a>查看最耗IO的进程</h2><p>一般先通过<code>iostat</code>查看是否存在io瓶颈，再使用<code>iotop</code>命令来定位那个进程最耗费IO：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">123931 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.02 % [kworker/1:30]</span><br><span class="line"> 94208 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % nautilus-desktop --force [gmain]</span><br><span class="line">     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --system --deserialize 62</span><br><span class="line">     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line"> 94211 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % gvfsd-trash --spawner :1.4 /org/gtk/gvfs/exec_spaw/0</span><br><span class="line">     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line">     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">     7 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]</span><br><span class="line">     9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]</span><br><span class="line">    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>通过<code>iotop -p pid</code>可以查看单个进程的IO情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop -p 124146</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">124146 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % java -jar arthas-demo.jar</span><br></pre></td></tr></tbody></table></figure><h1 id="应用瓶颈"><a href="#应用瓶颈" class="headerlink" title="应用瓶颈"></a>应用瓶颈</h1><h2 id="查看某个进程的PID"><a href="#查看某个进程的PID" class="headerlink" title="查看某个进程的PID"></a>查看某个进程的PID</h2><p>如查看java的进程的pid，<code>ps -ef | grep java</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java</span><br><span class="line">root     124146   1984  0 09:13 pts/0    00:00:06 java -jar arthas-demo.jar</span><br><span class="line">root     125210  98378  0 10:07 pts/1    00:00:00 grep --color=auto java</span><br></pre></td></tr></tbody></table></figure><h2 id="查看特定进程的数量"><a href="#查看特定进程的数量" class="headerlink" title="查看特定进程的数量"></a>查看特定进程的数量</h2><p>如查看java进程的数量,<code>ps -ef | grep java| wc -l</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java| wc -l</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h2 id="查看线程是否存在死锁"><a href="#查看线程是否存在死锁" class="headerlink" title="查看线程是否存在死锁"></a>查看线程是否存在死锁</h2><p>查看线程是否存在死锁，<code>jstack -l pid</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack -l 124146</span><br><span class="line">2020-05-02 10:13:38</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f27f013c000 nid=0x1e4f9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f27f012d000 nid=0x1e4f8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007f27f004b800 nid=0x1e4f3 waiting on condition [0x00007f27f7274000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看某个进程的线程数"><a href="#查看某个进程的线程数" class="headerlink" title="查看某个进程的线程数"></a>查看某个进程的线程数</h2><p><code>ps -efL | grep [PID] | wc -l</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -efL | grep 124146 | wc -l</span><br><span class="line">12</span><br></pre></td></tr></tbody></table></figure><p>查看具体有哪些线程用<code>ps -Lp [pid] cu</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 124146 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     124146 124146  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 java</span><br><span class="line">root     124146 124147  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:01 java</span><br><span class="line">root     124146 124148  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 VM Thread</span><br><span class="line">root     124146 124149  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Reference Handl</span><br><span class="line">root     124146 124150  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Finalizer</span><br><span class="line">root     124146 124151  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Signal Dispatch</span><br><span class="line">root     124146 124152  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C2 CompilerThre</span><br><span class="line">root     124146 124153  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C1 CompilerThre</span><br><span class="line">root     124146 124154  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Service Thread</span><br><span class="line">root     124146 124155  0.1   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:05 VM Periodic Tas</span><br><span class="line">root     124146 125362  0.0   11  2.5 2489116 35724 pts/0   Sl+  10:13   0:00 Attach Listener</span><br></pre></td></tr></tbody></table></figure><h2 id="统计所有的log文件中，包含Error字符的行"><a href="#统计所有的log文件中，包含Error字符的行" class="headerlink" title="统计所有的log文件中，包含Error字符的行"></a>统计所有的log文件中，包含Error字符的行</h2><p><code>find / -type f -name "*.log" | xargs grep "ERROR"</code>，这个在排查问题过程中比较有用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -type f -name "*.log" | xargs grep "ERROR"</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,857 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,859 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 15:23:19,037 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="应用启动时指定JVM参数"><a href="#应用启动时指定JVM参数" class="headerlink" title="应用启动时指定JVM参数"></a>应用启动时指定JVM参数</h2><p><code>java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m arthas-demo.jar</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m  arthas-demo.jar</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=64m; support was removed in 8.0</span><br><span class="line">157518=2*3*3*3*2917</span><br><span class="line">illegalArgumentCount:  1, number is: -187733, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -102156, need &gt;= 2</span><br><span class="line">173379=3*57793</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用linux命令时，如果想看帮助可以使用<code>--help</code>或者<code>man</code>查看帮助信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep --help</span><br><span class="line">用法: grep [选项]... PATTERN [FILE]...</span><br><span class="line">在每个 FILE 或是标准输入中查找 PATTERN。</span><br><span class="line">默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。</span><br><span class="line">例如: grep -i 'hello world' menu.h main.c</span><br><span class="line">...</span><br><span class="line">[root@localhost ~]# man grep</span><br><span class="line"></span><br><span class="line">GREP(1)                                                        General Commands Manual                                                        GREP(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       grep, egrep, fgrep - 打印匹配给定模式的行</span><br><span class="line"></span><br><span class="line">总览 SYNOPSIS</span><br><span class="line">       grep [options] PATTERN [FILE...]</span><br><span class="line">       grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br><span class="line"></span><br><span class="line">描述 DESCRIPTION</span><br><span class="line">       Grep    搜索以    FILE    命名的文件输入   (或者是标准输入，如果没有指定文件名，或者给出的文件名是   -   的话)，寻找含有与给定的模式   PATTERN</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left">类别</th><th align="left">监控命令</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">内存瓶颈</td><td align="left">free</td><td align="left">查看内存使用</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">vmstat 3(间隔时间) 100(监控次数)</td><td align="left">查看swap in/out详细定位是否存在性能瓶颈</td><td align="left">推荐使用</td></tr><tr><td align="left"></td><td align="left">sar -r 3</td><td align="left">和free命令类似，查看内存的使用情况，但是不包含swap的情况</td><td align="left"></td></tr><tr><td align="left">cpu瓶颈</td><td align="left">top -H</td><td align="left">按照cpu消耗高低进行排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -Lp 进程号 cu</td><td align="left">查看某个进程的cpu消耗排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/cpuinfo |grep ‘processor’|wc -l</td><td align="left">查看cpu核数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看cpu总体消耗，包括分项消耗如user,system,idle,nice等消耗</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top 然后shift+h:显示java线程，然后shift+M:按照内存使用进行排序；shift+P:按照cpu时间排序;shift+T:按照cpu累计使用时间排序多核cpu，按“1”进入top视图</td><td align="left">专项性能排查，多核CPU主要看CUP各个内核的负载情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -u 3(间隔时间)</td><td align="left">查看cpu总体消耗占比</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -q</td><td align="left">查看cpu load</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top -b -n 1 | awk ‘{if (NR&lt;=7)print;else if($8==”D”){print;count++}}END{print “Total status D:”count}’</td><td align="left">计算在cpu load里面的uninterruptedsleep的任务数量 uninterruptedsleep的任务会被计入cpu load，如磁盘堵塞</td><td align="left"></td></tr><tr><td align="left">网络瓶颈</td><td align="left">cat /var/log/messages</td><td align="left">查看内核日志，查看是否丢包</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">watch more /proc/net/dev</td><td align="left">用于定位丢包，错包情况，以便看网络瓶颈</td><td align="left">重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限</td></tr><tr><td align="left"></td><td align="left">sar -n SOCK</td><td align="left">查看网络流量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -na|grep ESTABLISHED|wc -l</td><td align="left">查看tcp连接成功状态的数量</td><td align="left">此命令特别消耗cpu，不适合进行长时间监控数据收集</td></tr><tr><td align="left"></td><td align="left">netstat -na|awk’{print $6}’|sort |uniq -c |sort -nr</td><td align="left">看tcp各个状态数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -i</td><td align="left">查看网络错误</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ss state ESTABLISHED| wc -l</td><td align="left">更高效地统计tcp连接状态为ESTABLISHED的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/net/snmp</td><td align="left">查看和分析240秒内网络包量，流量，错包，丢包</td><td align="left">用于计算重传率<code>tcpetr=RetransSegs/OutSegs</code></td></tr><tr><td align="left"></td><td align="left">ping $ip</td><td align="left">测试网络性能</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">traceroute $ip</td><td align="left">查看路由经过的地址</td><td align="left">常用于定位网络在各个路由区段的耗时</td></tr><tr><td align="left"></td><td align="left">dig $域名</td><td align="left">查看域名解析地址</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">dmesg</td><td align="left">查看系统内核日志</td><td align="left"></td></tr><tr><td align="left">磁盘瓶颈</td><td align="left">iostat -x -k -d 1</td><td align="left">详细列出磁盘的读写情况</td><td align="left">当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注iowait占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注await，表示磁盘的响应时间以便小于5ms</td></tr><tr><td align="left"></td><td align="left">iostat -x</td><td align="left">查看系统各个磁盘的读写性能</td><td align="left">重点关注await和iowait的cpu占比</td></tr><tr><td align="left"></td><td align="left">iotop</td><td align="left">查看哪个进程在大量读取IO</td><td align="left">一般先通过iostat查看是否存在io瓶颈，再定位哪个进程在大量读取IO</td></tr><tr><td align="left"></td><td align="left">df -hl</td><td align="left">查看磁盘剩余空间</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">du -sh</td><td align="left">查看磁盘使用了多少空间</td><td align="left"></td></tr><tr><td align="left">应用瓶颈</td><td align="left">ps -ef</td><td align="left">grep java</td><td align="left">查看某个进程的id号</td></tr><tr><td align="left"></td><td align="left">ps -ef | grep httpd| wc -l</td><td align="left">查看特定进程的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat ***.log | grep ***Exception| wc -l</td><td align="left">统计日志文件中包含特定异常数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstack -l pid</td><td align="left">用于查看线程是否存在死锁</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">awk’{print $8}’ 2017-05-22-access_log|egrep ‘301|302’| wc -l</td><td align="left">统计log中301、302状态码的行数，$8表示第八列是状态码，可以根据实际情况更改</td><td align="left">常用于应用故障定位</td></tr><tr><td align="left"></td><td align="left">grep ‘wholesaleProductDetailNew’ cookie_log | awk ‘{if($10==”200”)}’print}’</td><td align="left">awk ‘print $12’ | more</td><td align="left">打印包含特定数据的12列数据</td></tr><tr><td align="left"></td><td align="left">grep “2017:05:22” cookielog | awk ‘($12&gt;0.3){print 8}’ | sort &gt; 目录地址</td><td align="left">对apache或者nginx访问log进行响应时间排序，$12表示cookie log中的12列表示响应时间 用于排查是否是由于是某些访问超长造成整体的RT变长</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">grep -v ‘HTTP/1.1” 200’</td><td align="left">取出非200响应码的URL</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">pgm -A -f $应用集群名称 “grep “‘301’ log文件地址 | wc -l”</td><td align="left">查看整个集群的log中301状态码的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -efL | grep [PID] | wc -l</td><td align="left">查看某个进程创建的线程数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">find / -type f -name “*.log” | xargs grep “ERROR”</td><td align="left">统计所有的log文件中，包含Error字符的行</td><td align="left">这个在排查问题过程中比较有用</td></tr><tr><td align="left"></td><td align="left">jstat -gc [pid]</td><td align="left">查看gc情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcnew [pid]</td><td align="left">查看young区的内存使用情况，包括MTT(最大交互次数就被交换到old区)，TT是目前已经交换的次数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcold</td><td align="left">查看old区的内存使用情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -J-d64 -dump:format=b,file=dump.bin PID</td><td align="left">dump出内存快照</td><td align="left">-J-d64防止jmap导致虚拟机crash(jdk6有bug)</td></tr><tr><td align="left"></td><td align="left">-XX:+HeapDumpOnOutOfMemeryError</td><td align="left">在java启动时加入，当出现内存溢出时，存储内存快照</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -histo [pid]</td><td align="left">按照对象内存大小排序</td><td align="left">注意会导致full gc</td></tr><tr><td align="left"></td><td align="left">gcore [pid]</td><td align="left">导出完成的内存快照</td><td align="left">通常和<code>jmap -permstat /opt/**/java gcore.bin</code>一起使用，将core dump转换成heap dump</td></tr><tr><td align="left"></td><td align="left">-XX:HeapDumpPath=/home/logs -Xloggc:/home/log/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</td><td align="left">在Java启动参数中加入，打印gc日志</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">-server -Xms4000m -Xmx4000m -Xmn1500m -Xss256k -XX:PermSize=340m -XX:MaxPermSize=340m -XX:+UseConcMarkSweepGC</td><td align="left">调整JVM堆大小</td><td align="left">xss是栈大小</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951442.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951481.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951399.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951517.png" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务失效的 12 种场景</title>
      <link href="/posts/1040342123/"/>
      <url>/posts/1040342123/</url>
      
        <content type="html"><![CDATA[<h1 id="太坑了！聊聊-Spring-事务失效的-12-种场景"><a href="#太坑了！聊聊-Spring-事务失效的-12-种场景" class="headerlink" title="太坑了！聊聊 Spring 事务失效的 12 种场景"></a>太坑了！聊聊 Spring 事务失效的 12 种场景</h1><p><strong>前言</strong></p><p>对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。</p><p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p>确实，spring事务用起来贼爽，就用一个简单的注解：<code>@Transactional</code>，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。</p><p>但如果你使用不当，它也会坑你于无形。</p><p>今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1040342123/640-20230824234733952.jpeg" alt="Image"></p><h2 id="一-事务不生效"><a href="#一-事务不生效" class="headerlink" title="一 事务不生效"></a><strong>一 事务不生效</strong></h2><h3 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    private void add(UserModel userModel) {</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法的访问权限被定义成了<code>private</code>，这样会导致事务失效，spring要求被代理方法必须是<code>public</code>的。</p><p>说白了，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {</span><br><span class="line">    // Don't allow no-public methods as required.</span><br><span class="line">    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {</span><br><span class="line">      return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // The method may be on an interface, but we need attributes from the target class.</span><br><span class="line">    // If the target class is null, the method will be unchanged.</span><br><span class="line">    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">    // First try is the method in the target class.</span><br><span class="line">    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">    if (txAttr != null) {</span><br><span class="line">      return txAttr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Second try is the transaction attribute on the target class.</span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {</span><br><span class="line">      return txAttr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (specificMethod != method) {</span><br><span class="line">      // Fallback is to look at the original method.</span><br><span class="line">      txAttr = findTransactionAttribute(method);</span><br><span class="line">      if (txAttr != null) {</span><br><span class="line">        return txAttr;</span><br><span class="line">      }</span><br><span class="line">      // Last fallback is the class of the original method.</span><br><span class="line">      txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">      if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {</span><br><span class="line">        return txAttr;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是<code>public</code>，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2. 方法用final修饰"></a>2. 方法用final修饰</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public final void add(UserModel userModel){</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法被定义成了<code>final</code>的，这样会导致事务失效。</p><p>为什么？</p><p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p><p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p><blockquote><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p></blockquote><h3 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateStatus(UserModel userModel) {</span><br><span class="line">        doSameThing();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。</p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法"><a href="#3-1-新加一个Service方法" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line">   @Autowired</span><br><span class="line">   prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceB.doSave(user);</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> @Servcie</span><br><span class="line"> public class ServiceB {</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor=Exception.class)</span><br><span class="line">    public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2-在该Service类中注入自己"><a href="#3-2-在该Service类中注入自己" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line">   @Autowired</span><br><span class="line">   prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceA.doSave(user);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   @Transactional(rollbackFor=Exception.class)</span><br><span class="line">   public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。。</p><h4 id="3-3-通过AopContent类"><a href="#3-3-通过AopContent类" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   @Transactional(rollbackFor=Exception.class)</span><br><span class="line">   public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。</p><p>如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子，我们可以看到UserService类没有加<code>@Service</code>注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h3 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        new Thread(() -&gt; {</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void doOtherThing() {</span><br><span class="line">        System.out.println("保存role表数据");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line"></span><br><span class="line">  new NamedThreadLocal&lt;&gt;("Transactional resources");</span><br></pre></td></tr></tbody></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="6-表不支持事务"><a href="#6-表不支持事务" class="headerlink" title="6.表不支持事务"></a>6.表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是<code>myisam</code>。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把<code>ENGINE</code>参数设置成<code>MyISAM</code>即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `category` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `one_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `two_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `three_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `four_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin</span><br></pre></td></tr></tbody></table></figure><p>myisam好用，但有个很致命的问题是：<code>不支持事务</code>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><blockquote><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p></blockquote><h3 id="7-未开启事务"><a href="#7-未开启事务" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过<code>DataSourceTransactionManagerAutoConfiguration</code>类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置<code>spring.datasource</code>相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt; </span><br><span class="line">&lt;bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="transactionManager"&gt; </span><br><span class="line">    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">&lt;tx:advice id="advice" transaction-manager="transactionManager"&gt; </span><br><span class="line">    &lt;tx:attributes&gt; </span><br><span class="line">        &lt;tx:method name="*" propagation="REQUIRED"/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt; </span><br><span class="line">&lt;/tx:advice&gt; </span><br><span class="line">&lt;!-- 用切点把事务切进去 --&gt; </span><br><span class="line">&lt;aop:config&gt; </span><br><span class="line">    &lt;aop:pointcut expression="execution(* com.susan.*.*(..))" id="pointcut"/&gt; </span><br><span class="line">    &lt;aop:advisor advice-ref="advice" pointcut-ref="pointcut"/&gt; </span><br><span class="line">&lt;/aop:config&gt; </span><br></pre></td></tr></tbody></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二-事务不回滚"><a href="#二-事务不回滚" class="headerlink" title="二 事务不回滚"></a><strong>二 事务不回滚</strong></h2><h3 id="1-错误的传播特性"><a href="#1-错误的传播特性" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用<code>@Transactional</code>注解时，是可以指定<code>propagation</code>参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><ul><li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li><li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li><li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li><li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li><li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li><li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li><li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li></ul><p>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.NEVER)</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常"><a href="#2-自己吞了异常" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        try {</span><br><span class="line">            saveData(userModel);</span><br><span class="line">            updateData(userModel);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常"><a href="#3-手动抛了别的异常" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        try {</span><br><span class="line">             saveData(userModel);</span><br><span class="line">             updateData(userModel);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            throw new Exception(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。</p><p>因为spring事务，默认情况下只会回滚<code>RuntimeException</code>（运行时异常）和<code>Error</code>（错误），对于普通的Exception（非运行时异常），它不会回滚。</p><h3 id="4-自定义了回滚异常"><a href="#4-自定义了回滚异常" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置<code>rollbackFor</code>参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional(rollbackFor = BusinessException.class)</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">       saveData(userModel);</span><br><span class="line">       updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了"><a href="#5-嵌套事务回滚多了" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        roleService.doOtherThing();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void doOtherThing() {</span><br><span class="line">        System.out.println("保存role表数据");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line"></span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        try {</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三-其他"><a href="#三-其他" class="headerlink" title="三 其他"></a><strong>三 其他</strong></h2><h3 id="1-大事务问题"><a href="#1-大事务问题" class="headerlink" title="1 大事务问题"></a>1 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。</p><p>通常情况下，我们会在方法上<code>@Transactional</code>注解，填加事务功能，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Autowired </span><br><span class="line">    private RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">       query1();</span><br><span class="line">       query2();</span><br><span class="line">       query3();</span><br><span class="line">       roleService.save(userModel);</span><br><span class="line">       update(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line">    </span><br><span class="line">    @Autowired </span><br><span class="line">    private RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void save(UserModel userModel) throws Exception {</span><br><span class="line">       query4();</span><br><span class="line">       query5();</span><br><span class="line">       query6();</span><br><span class="line">       saveData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但<code>@Transactional</code>注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roleService.save(userModel);</span><br><span class="line">update(userModel);</span><br></pre></td></tr></tbody></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveData(userModel);</span><br></pre></td></tr></tbody></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><p>关于大事务问题的危害，可以阅读一下我的另一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;mid=2247485262&amp;idx=1&amp;sn=abe19452e4c13876270f329cc6929be7&amp;chksm=f9800194cef78882e5ad4d8eb00b7e3f745a4159aee6afb1858cc16cae599f8889afa330e17b&amp;token=305097496&amp;lang=zh_CN&amp;scene=21#wechat_redirect">让人头痛的大事务问题到底要如何解决？</a>》，上面有详细的讲解。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1040342123/640-20230824234734012.png" alt="Image"></p><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2.编程式事务"></a>2.编程式事务</h3><p>上面聊的这些内容都是基于<code>@Transactional</code>注解的，主要说的是它的事务问题，我们把这种事务叫做：<code>声明式事务</code>。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：<code>编程式事务</code>。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void save(final User user) {</span><br><span class="line">      queryData1();</span><br><span class="line">      queryData2();</span><br><span class="line">      transactionTemplate.execute((status) =&gt; {</span><br><span class="line">         addData1();</span><br><span class="line">         updateData2();</span><br><span class="line">         return Boolean.TRUE;</span><br><span class="line">      })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于<code>@Transactional</code>注解声明式事务，我更建议大家使用，基于<code>TransactionTemplate</code>的编程式事务。主要原因如下：</p><ol><li>避免由于spring aop问题，导致事务失效的问题。</li><li>能够更小粒度的控制事务的范围，更直观。</li></ol><blockquote><p>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要用消息队列？你项目中是怎么用的</title>
      <link href="/posts/2853285209/"/>
      <url>/posts/2853285209/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用消息队列？你项目中是怎么用的？"><a href="#为什么要用消息队列？你项目中是怎么用的？" class="headerlink" title="为什么要用消息队列？你项目中是怎么用的？"></a>为什么要用消息队列？你项目中是怎么用的？</h1><p>包含原理+BAT案例实践，看完需要5分钟</p><blockquote><p>本文内容预览：</p><ol><li>是什么？为什么？<br>1.1 什么是消息队列<br>1.2 为什么要使用消息队列<br>1.3 引入消息队列的带来了哪些问题</li><li>怎么样？<br>2.1 支撑七年双11零故障的RocketMQ<br>2.2 快手万亿级kafka集群的平滑扩容<br>2.3 快手/美团对kafka缓存污染的优化<br>2.4 CMQ在微信红包支付场景下的应用</li></ol></blockquote><h1 id="Part1是什么？为什么？"><a href="#Part1是什么？为什么？" class="headerlink" title="Part1是什么？为什么？"></a>Part1是什么？为什么？</h1><h2 id="1什么是消息队列"><a href="#1什么是消息队列" class="headerlink" title="1什么是消息队列"></a>1什么是消息队列</h2><p>说到Java中的队列应该都不会陌生。其具有通过先进先出，或者双端进出的方式进行数据管理；通过阻塞以达到自动平衡负载的功能。</p><p>消息队列之所以以队列命名，起初也是因为其功能和操作，和java的本地队列有相似之处。所以，我们可以简单的认为消息队列就是为了满足分布式下各服务之间的数据传输、管理和消费的一种中间服务。</p><h2 id="2为什么要使用消息队列"><a href="#2为什么要使用消息队列" class="headerlink" title="2为什么要使用消息队列"></a>2为什么要使用消息队列</h2><p><strong>问：你们的系统中为什么要引入消息队列？</strong></p><p>我们总归需要知晓消息队列的使用价值，以及自己的业务场景下的实际痛点才能回答为什么要用消息队列这个问题，才能回答系统引入消息队列的价值所在。</p><h3 id="系统间解耦"><a href="#系统间解耦" class="headerlink" title="系统间解耦"></a>系统间解耦</h3><p>以前几天在后台和关注公号的一个大佬讨论的广告流水更新的操作为例：</p><p>广告检索系统，需要感知广告贴的信息变动来更新自己的索引，但实际上检索系统和投放、物料、资产等系统间没有必要依靠接口对感知行为进行强关联，且接口的方式在维护和系统的压力方面不友好，那么，消息队列的作用就显的很重要了，各系统发布各自的消息，谁需要谁订阅，达到目的同时不会增加额外的系统调用压力。（注：builder的接口调用是为了获取最新的信息，此处可以通过压缩等方式进行优化）</p><p>因此，<em>当系统间无实时数据交互要求，但还需要其业务信息时，可以用消息队列来达到系统间解耦的作用，只要发布方定义好消息队列格式，消费方的任何操作均可和发布方无关，减少了不必要的联调和发布冲突等影响。</em></p><h3 id="服务异步化"><a href="#服务异步化" class="headerlink" title="服务异步化"></a>服务异步化</h3><p>最典型的一个例子，就是支付场景下的结果通知功能。</p><p>我们知道，一般情况下不管是app push 还是短信通知，都是比较耗时的操作。所以，没有必要因为这些非核心功能的耗时操作而影响了支付的核心操作，只要我们在支付操作完成之后，将支付结果发到短信中心指定的消息topic下，短信中心自然会接收到此消息并保证通知给用户。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625459.png" alt="Image">图片来源于知乎回答</p><p>因此使用消息队列，让非核心的操作异步化，提高整个业务链路的高效和稳定，是很有效的。</p><h3 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h3><p>这个功能使我们本篇关注的重点，面对特殊场景如秒杀、春晚红包等万亿级流量的脉冲式压力下，一种保护我们系统的服务免于崩溃的有效手段就是消息队列。</p><p>通过消息中心高性能的存储和处理能力，将超过系统处理能力的多余流量暂时存储起来，并在系统处理能力内平缓释放出来，达到削峰的效果。</p><p>比如我们的广告计费系统，面对上万并发的商业贴检索量，数千并发的点击操作，实时接口的方式一定是不合适的，毕竟广告行为和支付行为不一样，支付失败用户还可以重试，但用户的商业贴点击行为是不可回放的，本次流量过去就过去了，因此，需要利用消息队列将扣费请求缓存下来，来保证计费系统的稳定。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还如广播、事务型、最终一致性等特性，也是消息队列经常用到的功能。</p><h2 id="3消息队列会存在哪些问题"><a href="#3消息队列会存在哪些问题" class="headerlink" title="3消息队列会存在哪些问题"></a>3消息队列会存在哪些问题</h2><h3 id="业务上增加响应延迟"><a href="#业务上增加响应延迟" class="headerlink" title="业务上增加响应延迟"></a>业务上增加响应延迟</h3><p>前面提到，消息队列使得业务非核心流程异步化，可以提高整个业务操作的时效性和流畅度，提升用户操作体验。<em>但</em>，也是因为数据进入队列的原因，不可避免的会耽搁消费速度。导致业务生效不及时。</p><p>比如，之前遇到的商品推荐，产品要求推荐列表中不能出现满减秒杀的商品，以消除特殊商品对推荐效果产生影响。除了秒杀，我们还需要感知商品的上下架、黑名单、库存等等，因次，用redis中的bit多个偏移量来维护一个商品的多个状态。然后接收促销组的消息来变更推荐缓存集群中的商品状态，但由于消息的延迟，就有可能导致商品状态变更不及时的情况发生。不过只要权衡之下业务和技术上是可接受的就OK了。</p><h3 id="架构上引入不稳定因素"><a href="#架构上引入不稳定因素" class="headerlink" title="架构上引入不稳定因素"></a>架构上引入不稳定因素</h3><p>消息队列的引入，相当于在原有的分布式服务链路中新增了一个系统，系统复杂度也随之变大了。同时，消息队列的作用要求其具有高性能和高可用。</p><p>所以，面对<strong>怎样部署高可用稳定集群</strong>、<strong>消息发送不成功怎么重试</strong>、<strong>broker数据同步策略怎么设置</strong>、<strong>broker异常导致消息重发怎么幂等</strong>、<strong>消费不成功怎么重试</strong>等等问题，需要中间件团队和业务系统一起努力应对。</p><h1 id="Part2怎么样？"><a href="#Part2怎么样？" class="headerlink" title="Part2怎么样？"></a>Part2怎么样？</h1><h2 id="4支撑七年双11零故障的RocketMQ"><a href="#4支撑七年双11零故障的RocketMQ" class="headerlink" title="4支撑七年双11零故障的RocketMQ"></a>4支撑七年双11零故障的RocketMQ</h2><p>2020 年双十一交易峰值达到 58.3W 笔/秒。RocketMQ为了阿里的交易生态有很多深度定制，这里我们只介绍其中针对高可用的优化。</p><p>个人理解，push消费模式只适合于消费速度远大于生产速度的场景，如果是大流量并发场景，基本还是以Pull消费为主。</p><p>而pull前broker和client间会进行负载均衡建立连接，那么，一旦Client被Hang住,(<em>没有宕就不会rebalance，即时宕机也是默认20s才会rebalance</em>)，就会让broker与该client关联的队列消息无法及时被消费，导致积压。怎么办：<strong>POP</strong>，新的消费模式</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625509.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625443.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625440.png" alt="Image"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><p>POP 消费中并不需要rebalance去分配消费队列，取而代之的是请求所有的 broker 获取消息进行消费。broker 内部会把自身的三个队列的消息根据一定的算法分配给等待的 POPClient。即使 PopClient 2 出现 hang，但内部队列的消息也会让 Pop Client1 和 Pop Client2 进行消费。这样避免了消费堆积。[1]</p><h2 id="5快手万亿级kafka集群的平滑扩容-2"><a href="#5快手万亿级kafka集群的平滑扩容-2" class="headerlink" title="5快手万亿级kafka集群的平滑扩容[2]"></a>5快手万亿级kafka集群的平滑扩容[2]</h2><p>要实现平滑，则需要让producer无感的实现partition迁移。</p><p>大致原理是将待迁移partition的数据和新的partition数据进行同步并持续一段时间，直到消费者全部赶上同步的开始节点，然后再变更路由，删除原partition，完成迁移。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625431.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625455.png" alt="Image"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><p>相同的数据同步思路，在<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000874&amp;idx=1&amp;sn=8b35ff5f06d78edef7ea8fbbac8ab5a6&amp;scene=21#wechat_redirect">facebook的分布式队列</a>灾备方案上也有应用。</p><h2 id="6快手-美团对kafka缓存污染的优化-3"><a href="#6快手-美团对kafka缓存污染的优化-3" class="headerlink" title="6快手/美团对kafka缓存污染的优化[3]"></a>6快手/美团对kafka缓存污染的优化[3]</h2><p>kafka的高性能，来源于顺序文件读写和操作系统缓存pagecache的支持，在单partition，单consumer的场景下，kafka表现的非常优秀。但是，如果同一机器上，存在不同的partition,甚至，消费模式有实时和延迟消费的混合场景，将会出现PageCache资源竞争，导致缓存污染，影响broker的服务的处理效率。</p><h3 id="美团应对实时-延迟消费缓存污染"><a href="#美团应对实时-延迟消费缓存污染" class="headerlink" title="美团应对实时/延迟消费缓存污染"></a>美团应对实时/延迟消费缓存污染</h3><p>将数据按照时间维度分布在不同的设备中，近实时部分的数据缓存在 SSD 中，这样当出现 PageCache 竞争时，实时消费作业从 SSD 中读取数据，保证实时作业不会受到延迟消费作业影响<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625413.png" alt="Image">当消费请求到达 Broker 时，Broker 直接根据其维护的消息偏移量和设备的关系从对应的设备中获取数据并返回，并且在读请求中并不会将 HDD 中读取的数据回刷到 SSD，防止出现缓存污染。同时访问路径明确，不会由于 Cache Miss 而产生的额外访问开销。</p><h3 id="快手应对follower数据同步引起的缓存污染"><a href="#快手应对follower数据同步引起的缓存污染" class="headerlink" title="快手应对follower数据同步引起的缓存污染"></a>快手应对follower数据同步引起的缓存污染</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625508.png" alt="Image">broker 中引入了两个对象：一个是 block cache；另一个是 flush queue。</p><p>Producer 的写入请求在 broker 端首先会被以原 message 的形式写入 flush queue 中，之后再将数据写入到 block cache 的一个 block 中，之后整个请求就结束了。在 flush queue 中的数据会由其他线程异步地写入到磁盘中（会经历 page cache 过程）。保证queue不受follower的影响</p><p>consumer 首先会从 block cache 中检索数据，如果命中，则直接返回。否则，则从磁盘读取数据。这样的读取模式保障了 consumer 的 cache miss 读并不会填充 block cache，从而避免了产生污染。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以看出，解决缓存污染的基本出发点，还是要拆解不同消费速度的任务、或不同的数据生产来源，<em>分而治之</em>的思路避免相互间缓存的影响。</p><h2 id="7CMQ在红包支付场景下的应用-4"><a href="#7CMQ在红包支付场景下的应用-4" class="headerlink" title="7CMQ在红包支付场景下的应用[4]"></a>7CMQ在红包支付场景下的应用[4]</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625526.png" alt="Image">红包操作的背后流程简化为：从 A 帐号中把余额读出来，然后做减法操作，再把结果写回 A 帐号中；然后拆红包对 B 帐号做加法操作，把结果写到 B 帐号中。</p><p>而由于账务系统能承载的压力有限(和账务相关的系统一般都会由于锁、事务等原因影响处理效率)，可能导致入账失败，如果按实时业务逻辑，则需要对拆红包进行实时回滚(回滚需要对A的账户再进行一次加法)，而引入CMQ后，业务链路变成将失败的请求写入CMQ，由CMQ的高可用来保证数据一致，直到账务系统最终入账成功。简化了账务系统由于系统压力而导致的入账失败而导致红包账务回滚带来的额外系统操作。</p><h1 id="Part3总结"><a href="#Part3总结" class="headerlink" title="Part3总结"></a>Part3总结</h1><p>本篇从消息队列的作用出发，从阿里双11、快手、美团、微信红包等案例，就消息队列本身的优化方案和业务对消息队列的高效利用，阐述了消息队列在高并发的优化场景下的作用。如有问题，欢迎留言讨论，相互学习！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]版权声明：本文为CSDN博主「阿里巴巴云原生」的原创文章，遵循CC 4.0 BY-SA版权协议: <em><a href="https://blog.csdn.net/alisystemsoftware/article/details/111314602">https://blog.csdn.net/alisystemsoftware/article/details/111314602</a></em>[2]快手万亿级别 Kafka 集群应用实践与技术演进之路: <em><a href="https://www.infoq.cn/article/Q0o">https://www.infoq.cn/article/Q0o</a></em>QzLQiay31MWiOBJH*[3]美团把 Kafka 作为应用层缓存的实践: <em><a href="https://www.infoq.cn/article/k6dqfqqihpjfepl3y3hs">https://www.infoq.cn/article/k6dqfqqihpjfepl3y3hs</a></em>[4]春晚微信红包案例: <em><a href="https://cloud.tencent.com/document/product/406/4789">https://cloud.tencent.com/document/product/406/4789</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何彻底理解红黑树</title>
      <link href="/posts/312572753/"/>
      <url>/posts/312572753/</url>
      
        <content type="html"><![CDATA[<p><em>作者**：linzworld</em></p><p>cnblogs.com/linzworld/p/13720477.html</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讲解下最近一直听到的<strong>红黑树</strong>，看看究竟是什么神仙鬼怪。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>满足以下两个条件的树就是二叉树：</p><ol><li>本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><p>简单地理解，二叉树（Binary tree）是<strong>每个节点最多只有两个分支</strong>（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.png" alt="图片"></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>要了解红黑树之前，免不了先看下二叉查找树是什么。</p><h3 id="维基百科上的定义"><a href="#维基百科上的定义" class="headerlink" title="维基百科上的定义"></a>维基百科上的定义</h3><p><strong>二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol><h3 id="图示理解"><a href="#图示理解" class="headerlink" title="图示理解"></a>图示理解</h3><p>下图为查找值为29的节点，有以下步骤：</p><ol><li>查看根节点41</li><li>因为41&gt; 29 ,所以查看41的左孩子20</li><li>因为20 &lt; 29 ,所以查看20的右孩子29，发现其正好是要查看的节点。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.gif" alt="图片"></p><h3 id="退化"><a href="#退化" class="headerlink" title="退化"></a>退化</h3><p>二叉查找树有个非常严重的问题，如果数据的插入是从大到小插入的，或者是从小到大插入的话，会导致二叉查找树退化成单链表的形式，俗称“瘸子“。</p><ol><li><p>左瘸子：例如，插入数据依次为{5,4,3,2,1}（从大到小），则如下图所示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810184.gif" alt="图片"></p></li><li><p>右瘸子：例如，插入数据依次为{1,2,3,4,5}（从小到大），则如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810154.gif" alt="图片"></p></li></ol><p>为了解决该问题，出现了一些解决方法，即平衡，能够使得树趋向平衡，这种自平衡的树叫做平衡树。</p><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树(Balance Tree，BT) 指的是，<strong>任意节点的子树的高度差都小于等于1</strong>。常见的符合平衡树的有AVL树（二叉平衡搜索树），B树（多路平衡搜索树，2-3树，2-3-4树中的一种），红黑树等。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>AVL树（由发明者<strong>A</strong>delson-<strong>V</strong>elsky 和 <strong>L</strong>andis 的首字母缩写命名），是<strong>指任意节点的两个子树的高度差不超过1的平衡树</strong>。又称</p><p><strong>自平衡二叉搜索树</strong>。</p><p>AVL树能解决上文二叉查找树中的右瘸子问题，例如，插入数据依次为{1,2,3,4,5}（从小到大），则如下图所示：</p><p><strong>AVL树会对不符合高度差的结构进行调整，从而使得二叉树趋向平衡</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810198.gif" alt="图片"></p><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>2-3树</strong>，是指每个具有子节点的节点（内部节点，internal node）要么有两个子节点和一个数据元素，要么有三个子节点和两个数据元素的自平衡的树，它的所有叶子节点都具有相同的高度。</p><p>简单点讲，2-3树的非叶子节点都具有两个分叉或者三个分叉，所以，称作<strong>2叉-3叉树</strong>更容易理解。</p><p>另外一种说法，<strong>具有两个子节点和一个数据元素的节点又称作2节点</strong>，<strong>具有三个子节点和两个数据元素的节点又称作3节点</strong>，所以，整颗树叫做2-3树。</p><p><strong>所有叶子点都在树的同一层，一样高</strong>。</p><blockquote><p>性质1. 满足二叉搜索树的性质<br>性质2. 节点可以存放一个或两个元素<br>性质3. 每个节点有两个或三个子节点</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810160.png" alt="图片">img</p><h3 id="创建2-3树的规则"><a href="#创建2-3树的规则" class="headerlink" title="创建2-3树的规则"></a>创建2-3树的规则</h3><p>插入操作</p><ol><li>向2-节点中插入元素</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.jpeg" alt="图片">img</p><ol><li>向一颗只含有一个3-节点的树中插入元素</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810138.jpeg" alt="图片">img</p><h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ol><li>2节点：包含两个子节点和一个数据元素</li><li>3节点：包含三个子节点和一个数据元素</li><li>4节点：包含四个子节点和一个数据元素</li></ol><p><strong>2-3-4树</strong>，它的每个非叶子节点，要么是2节点，要么是3节点，要么是4节点，且可以自平衡，所以称作2-3-4树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><p>规则1. 加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上<br>规则2. 四节点可以被分解三个2-节点组成的树，并且分解后新树的根节点需要向上和父节点融合</p></blockquote><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol><li>原本的2-3-4树<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></li><li>对于上图的2-3-4树，插入一个节点17，由于规则1，节点17不会加入节点[16,18,20]的子树，而是与该节点融合。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810213.png" alt="图片"></li><li>由于规则2，节点[16,17,18,20]是一个4节点，将该节点进行拆解成新的树，将18作为子树的根节点进行拆分。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810177.png" alt="图片"></li><li>此时树暂时失去了平衡，我们需要将拆分后的子树的根节点向上进行融合。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810259.png" alt="图片"></li><li>同理可得，由于规则2，节点[6,10,14,18]是一个4节点，将该节点进行拆解成新的树，将14作为子树的根节点进行拆分，完成了2-3-4树的构建。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810181.png" alt="图片"></li></ol><p>总结了下插入节点的过程，无非也就为了符合两条规则，那么，2-3树，2-3-4树都有了，那是不是也有2-3-4-5树，2-3-4-5–…-n树的存在呢？事实上是有的，世人把这一类树称为一个名字：B树。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>B树</strong>，表示的是一类树，它允许一个节点可以有多于两个子节点，同时，也是自平衡的，叶子节点的高度都是相同的。</p><p>所以，为了更好地区分一颗B树到底属于哪一类树，我们给它一个新的属性：<strong>度（Degree）：一个节点能有多少箭头指向其他节点</strong>。</p><p>具有度为3的B树，表示一个节点最多有三个子节点，也就是2-3树的定义。</p><p>具有度为4的B树，表示一个节点最多有四个子节点，也就是2-3-4树的定义。</p><p>度为4的B树的示例图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810241-2891490.png" alt="图片"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>R-B Tree，全称是Red-Black Tree，又称为“<strong>红黑树</strong>”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><h3 id="如何理解红黑树"><a href="#如何理解红黑树" class="headerlink" title="如何理解红黑树"></a>如何理解红黑树</h3><p>一个经典的红黑树如下图所示（省略了叶子节点都是黑色的NIL节点）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810199.png" alt="图片"></p><p>如图2所示，将该红黑树与上文讲到的2-3-4树对比，是否发现，<strong>红黑树就是一个2-3-4树</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810259-2891490.png" alt="图片"></p><ol><li><p>每个节点或者是黑色，或者是红色。</p></li><li><p><strong>根节点是黑色</strong>。</p></li><li><p><strong>每个叶子节点（NIL）是黑色</strong>。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p></li><li><p>如果一个节点是红色的，则它的子节点必须是黑色的。<br>由于红黑树的每个节点都是由2-3-4树转化而来的，从而红色节点不能连续两个出现，不然会出现4节点的情况，导致违反了规则2。而且红黑树的每一个黑节点都是3节点中的最中间的那个值，或者是2节点中其中一个值。</p></li><li><p><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</strong>。<br>原因：红黑树这些黑色节点在2-3-4树中代表的是由1节点的一个2-3-4树，而2-3-4树是同一个子树的深度是相同的，平衡的，所以从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（如下图所示，蓝色代表是黑色节点）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810218.png" alt="图片"></p></li></ol><p>注意：</p><ol><li>特性(3)中的叶子节点，是只为空(NIL或null)的节点。</li><li>特性(5)，<strong>确保没有一条路径会比其他路径长出俩倍</strong>。因而，红黑树是相对是接近平衡的二叉树。</li><li>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为**O(log n)**。</li></ol><blockquote><p>由上面的例子所示，我们只要把红黑树当做是2-3-4树来处理，并且对应的颜色进行改变或者进行左旋右旋的操作，即可达到使得红黑树平衡的目标。</p></blockquote><h3 id="如何保持红黑树的结构"><a href="#如何保持红黑树的结构" class="headerlink" title="如何保持红黑树的结构"></a>如何保持红黑树的结构</h3><p>当我们插入一个新的节点的时候，如何保证红黑树的结构依然能够符合上面的五个特性呢？</p><p>树的旋转分为左旋和右旋，下面借助图来介绍一下左旋和右旋这两种操作。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><h5 id="原本的状态"><a href="#原本的状态" class="headerlink" title="原本的状态"></a>原本的状态</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810220.png" alt="图片"></p><h5 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a>过程图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810272.gif" alt="图片"></p><h5 id="结束图"><a href="#结束图" class="headerlink" title="结束图"></a>结束图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810241.png" alt="图片"></p><p>如上图所示，当在某个目标结点E上，做左旋操作时，我们假设它的右孩子S不是NIL。左旋以S到E之间的链为“支轴”进行，它使S成为该子树的新根，而S的左孩子则成为E的右孩子。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><h5 id="原先状态图"><a href="#原先状态图" class="headerlink" title="原先状态图"></a>原先状态图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810261.png" alt="图片"></p><h5 id="过程图-1"><a href="#过程图-1" class="headerlink" title="过程图"></a>过程图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810336.gif" alt="图片"></p><h5 id="结束图-1"><a href="#结束图-1" class="headerlink" title="结束图"></a>结束图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230825000333375-2893016.png" alt="图片"></p><p>同左旋类似，当在某个目标结点S上，做右旋操作时，我们假设它的右孩子S不是NIL。左旋以S到E之间的链为“支轴”进行，它使S成为该子树的新根，而S的左孩子则成为E的右孩子。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>红黑树的应用比较广泛，主要是用它来存储<strong>有序的数据</strong>，它的时间复杂度是O(<strong>logn</strong>)，效率非常之高。<br>例如，<strong>Java集合中的TreeSet和TreeMap</strong>，C++ STL中的set、map，以及<strong>Linux虚拟内存的管理</strong>，都是通过红黑树去实现的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://visualgo.net/zh">VisuAlgo - 数据结构和算法动态可视化 (Chinese)</a></p><p>《数据结构与算法之美》</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">Red/Black Tree Visualization</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/6105630">(3条消息)教你初步了解红黑树_结构之法 算法之道-CSDN博客</a></p><p><a href="https://juejin.im/post/6873458286998650893#heading-9">了解红黑树的起源，理解红黑树的本质</a></p><p><a href="https://blog.popkx.com/the-principles-and-characteristics-of-linux-learning-21-self-balanced-binary-tree-and-red-black-tree/">linux学习21，自平衡二叉树和红黑树的原理和特点 - 刘冲的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/104031183">动画 | 什么是2-3树？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端如何防止订单重复支付</title>
      <link href="/posts/1362641175/"/>
      <url>/posts/1362641175/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端如何防止订单重复支付！"><a href="#服务端如何防止订单重复支付！" class="headerlink" title="服务端如何防止订单重复支付！"></a>服务端如何防止订单重复支付！</h1><blockquote><p>作者：废物大师兄</p><p><a href="http://www.cnblogs.com/cjsblog/p/14516909.html">www.cnblogs.com/cjsblog/p/14516909.html</a></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1362641175/640-20230824234311056.png" alt="Image"></p><p>如图是一个简化的下单流程，首先是提交订单，然后是支付。支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互，支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。</p><p>这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好，总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新，这个时候有可能产生投诉，或者用户重复支付。</p><p>由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单</p><p>为了防止掉单，这里可以这样处理：</p><p>1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。</p><p>2、支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理</p><p>3、支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）</p><p>4、无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略</p><p>5、业务应用也应做超时主动查询支付结果</p><p>对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫</p><p>为了防止订单重复提交，可以这样处理：</p><p>1、创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作</p><p>附上微信支付最佳实践：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1362641175/640-20230824234311045.png" alt="Image"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使错误日志更加方便排查问题</title>
      <link href="/posts/209595582/"/>
      <url>/posts/209595582/</url>
      
        <content type="html"><![CDATA[<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/209595582/640-20230824234051902.jpeg" alt="Image"></p><p>作者 | 琴水玉</p><p>来源 | <a href="https://cnblogs.com/lovesqcc/p/4319594.html">https://cnblogs.com/lovesqcc/p/4319594.html</a></p><p>在程序中打错误日志的主要目标是为更好地排查问题和解决问题提供重要线索和指导。但是在实际中打的错误日志内容和格式变化多样，错误提示上可能残缺不全、没有相关背景、不明其义，使得排查解决问题成为非常不方便或者耗时的操作。而实际上，如果编程的时候稍加用心，就会减少排查问题的很多无用功。 在阐述如何编写有效的错误日志之前， 了解错误是怎么产生的， 非常重要。</p><p><strong>错误是如何炼成的</strong></p><p>对于当前系统来说， 错误的产生由三个地方引入：</p><p>1.上层系统引入的非法参数。对于非法参数引入的错误， 可以通过参数校验和前置条件校验来截获错误；</p><p>2.与下层系统交互产生的错误。与下层交互产生的错误， 有两种：</p><p>a.下层系统处理成功了，但是通信出错了， 这样会导致子系统之间的数据不一致；</p><p>对于这种情况， 可以采用超时补偿机制，预先将任务记录下来，通过定时任务在后续将数据订正过来。</p><p>更好的设计方案 ？</p><p>b.通信成功了，但是下层处理出错了。</p><p>对于这种情况， 需要与下层开发人员沟通， 协调子系统之间的交互；</p><p>需要根据下层返回的错误码和错误描述做适当的处理或给予合理的提示信息。</p><p>无论哪一种情况， 都要假设下层系统可靠性一般， 做好出错的设计考虑。</p><p>3.本层系统处理出错。</p><p>本层系统产生错误的原因：</p><p><strong>原因一：疏忽导致。</strong> 疏忽是指程序员能力完全可避免此类错误但实际上没做到。比如将 &amp;&amp; 敲成了 &amp; ， == 敲成了 = ；边界错误， 复合逻辑判断错误等。疏忽要么是程序员注意力不够集中， 比如处于疲倦状态、加班通宵、边开会边写程序；要么是急着实现功能，没有顾及程序的健壮性等。</p><p>改进措施：使用代码静态分析工具，通过单元测试行覆盖可有效避免此类问题。</p><p><strong>原因二：错误与异常处理不够周全导致的。</strong> 比如输入问题。计算两个数相加， 不仅要考虑计算溢出问题， 还要考虑输入非法的情形。对于前者，可能通过了解、犯错或经验就可以避免， 而对于后者，则必须加以限定，以使之处于我们的智商能够控制的范围内，比如使用正则表达式过滤掉不合法的输入。对于正则表达式必须进行测试。对于不合法输入， 要给出尽可能详细、易懂、友好的提示信息、原因及建议方案。</p><p>改进措施：尽可能周全地考虑各种错误情形和异常处理。在实现主流程之后，增加一个步骤：仔细推敲可能的各种错误和异常，返回合理错误码和错误描述。每个接口或模块都有效处理好自己的错误和异常，可有效避免因场景交互复杂导致的bug. 譬如，一个业务用例由场景A.B.C交互完成。实际执行A.B成功了，C失败了，这时B需要根据C返回合理的代码和消息进行回滚并返回给A合理的代码和消息，A根据B的返回进行回滚，并返回给客户端合理的代码和消息。这是一种分段回滚的机制，要求每个场景都必须考虑异常情况下的回滚。</p><p><strong>原因三：逻辑耦合紧密导致。</strong> 由于业务逻辑耦合紧密， 随着软件产品一步步发展， 各种逻辑关系错综复杂， 难以看到全局状况， 导致局部修改影响波及到全局范围，造成不可预知的问题。</p><p>改进措施：编写短函数和短方法， 每个函数或方法最好不超过 50 行。编写无状态函数和方法， 只读全局状态， 相同的前提条件总是会输出相同的结果， 不会依赖外部状态而变更自己的行为；定义合理的结构、 接口和逻辑段， 使接口之间的交互尽可能正交、低耦合；对于服务层， 尽可能提供简单、正交的接口；持续重构， 保持应用模块化和松耦合， 理清逻辑依赖关系。对于有大量业务接口相互影响的情况， 必须整理各个业务接口的逻辑流程及相互依赖关系， 从整体上进行优化；对于有大量状态的实体， 也需要梳理相关的业务接口， 整理状态之间的转换关系。</p><p><strong>原因四：算法不正确导致。</strong></p><p>改进措施：首先将算法从应用中分离出来。若算法有多种实现， 可以通过交叉校验的单元测试找出来， 比如排序操作；如果算法具有可逆性质， 可以通过可逆校验的单元测试找出来， 比如加密解密操作。</p><p><strong>原因五：相同类型的参数，传入顺序错误导致。</strong> 比如，modifyFlow(int rx, int tx), 实际调用为 modifyFlow(tx,rx)</p><p>改进措施：尽可能使类型具体化， 该用浮点数就用浮点数， 该用字符串就用字符串， 该用具体对象类型就用具体对象类型；相同类型的参数尽可能错开；如果上述都无法满足， 就必须通过接口测试来验证， 接口参数值务必是不同的。</p><p><strong>原因六：空指针异常。</strong> 空指针异常通常是对象没有正确初始化， 或者使用对象之前没有对对象是否非空做检测。</p><p>改进措施：对于配置对象， 检测其是否成功初始化；对于普通对象， 获取到实体对象使用之前， 检测是否非空。</p><p><strong>原因七：网络通信错误。</strong> 网络通信错误通常是因为网络延迟、阻塞或不通导致的错误。网络通信错误通常是小概率事件， 但小概率事件很可能会导致大面积的故障、 难以复现的BUG。</p><p>改进措施：在前一个子系统的结束点和后一个子系统的入口点分别打 INFO 日志。通过两者的时间差提供一点线索。</p><p><strong>原因八：事务与并发错误。</strong> 事务与并发结合在一起， 很容易产生非常难以定位的错误。</p><p>改进措施：对于程序中的并发操作， 涉及到共享变量及重要状态修改的， 要加 INFO 日志。更有效的做法？？？</p><p><strong>原因九：配置错误。</strong></p><p>改进措施：在启动应用或启动相应配置时， 检测所有的配置项， 打印相应的INFO日志， 确保所有配置都加载成功。</p><p><strong>原因十：业务不熟悉导致的错误。</strong> 在中大型系统， 部分业务逻辑和业务交互都比较复杂， 整个的业务逻辑可能存在于多个开发同学的大脑里， 每个人的认识都不是完整的。这很容易导致业务编码错误。</p><p>改进措施：通过多人讨论和沟通， 设计正确的业务用例， 根据业务用例来编写和实现业务逻辑；最终的业务逻辑和业务用例必须完整存档；在业务接口中注明该业务的前置条件、处理逻辑、后置校验和注意事项；当业务变化时， 需要同步更新业务注释；代码REVIEW。业务注释是业务接口的重要文档， 对业务理解起着重要的缓存作用。</p><p><strong>原因十一：设计问题导致的错误。</strong> 比如同步串行方式会有性能、响应慢的问题， 而并发异步方式可以解决性能、响应慢的问题， 但会带来安全、正确性的隐患。异步方式会导致编程模型的改变， 新增异步消息推送和接收等新的问题。使用缓存能够提高性能， 但是又会存在缓存更新的问题。</p><p>改进措施：编写和仔细评审设计文档。设计文档必须阐述背景、需求、所满足的业务目标、要达到的业务性能指标、可能的影响、设计总体思路、详细方案、预见该方案的优缺点及可能的影响；通过测试和验收， 确保改设计方案确实满足业务目标和业务性能指标。</p><p><strong>原因十二：未知细节问题导致的错误。</strong> 比如缓冲区溢出、 SQL 注入攻击。从功能上看是没有问题的， 但是从恶意使用上看， 是存在漏洞的。再比如， 选择 jackson 库做 JSON 字符串解析， 默认情况下， 当对象新增字段时会导致解析出错。必须在对象上加 @JsonIgnoreProperties(ignoreUnknown = true) 注解才能正确应对变化。如果选用其他 JSON 库就不一定有这个问题。</p><p>改进措施：一方面要通过经验积累， 另一方面， 考虑安全问题和例外情况， 选择成熟的经过严格测试的库。</p><p><strong>原因十三：随时间变化而出现的bug。</strong> 有些解决方案在过去看来是很不错的，但在当前或者未来的情景中可能变得笨拙甚至不中用，也是常见的事情。比如像加密解密算法， 在过去可能认为是完善的， 在破解之后就要慎重使用了。</p><p>改进措施：关注变化以及漏洞修复消息，及时修正过时的代码、库、行为。</p><p><strong>原因十四：硬件相关的错误。</strong> 比如内存泄露， 存储空间不足， OutOfMemoryError 等。</p><p>改进措施：增加对应用系统的 CPU / 内存 / 网络等重要指标的性能监控。</p><p>系统出现的常见错误：</p><p>1.实体在数据库中的记录不存在， 必须指明是哪个实体或实体标识；</p><p>2.实体配置不正确， 必须指明是哪个配置有问题，正确的配置应该是什么；</p><p>3.实体资源不满足条件， 必须指明当前资源是什么，资源要求是什么；</p><p>4.实体操作前置条件不满足， 必须指明需要满足什么前置条件，当前的状态是什么；</p><p>5.实体操作后置校验不满足， 必须指明需要满足什么后置校验， 当前的状态是什么；</p><p>6.性能问题导致超时， 必须指明是什么导致的性能问题，后续如何优化；</p><p>7.多个子系统交互通信出错导致之间的状态或数据不一致？</p><p>一般难以定位的错误会出现在比较底层的地方。因为底层无法预知具体的业务场景， 给出的错误消息都是比较通用的。</p><p>这就要求在业务上层提供尽可能丰富的线索。错误的产生一定是多个系统或层次交互的过程中在某一层栈上不满足前置条件导致。在编程时， 在每一层栈中尽可能确保所有必须的前置条件满足，尽可能避免错误的参数传递到底层， 尽可能地将错误截获在业务层。</p><p>大多数错误都是由多种原因组合产生。但每一种错误必定有其原因。在解决错误之后， 要深入分析错误是如何发生的， 如何避免这些错误再次发生。努力就能成功， 但是： <strong>反思才能进步 ！</strong></p><p><strong>如何编写更容易排查问题的错误日志</strong></p><p>打错误日志的基本原则：</p><p>1.尽可能完整。每一条错误日志都完整描述了：什么场景下发生了什么错误， 什么原因（或者哪些可能原因）， 如何解决（或解决提示）；</p><p>2.尽可能具体。比如 NC 资源不足， 究竟具体指什么资源不足， 是否可以通过程序直接指明；通用错误，比如 VM NOT EXIST ， 要指明在什么场景下发生的，可能便于后续统计的工作。</p><p>3.尽可能直接。最理想的错误日志应该让人在第一直觉下能够知道是什么原因导致，该怎么去解决，而不是还要通过若干步骤去查找真正的原因。</p><p>4.将已有经验集成直接到系统中。所有已经解决过的问题及经验都要尽可能以友好的方式集成到系统中，给新进人员更好的提示，而不是埋藏在其他地方。</p><p>5.排版要整洁有序， 格式统一化规范化。密密麻麻、随笔式的日志看着就揪心， 相当不友好， 也不便于排查问题。</p><p>6.采用多个关键字唯一标识请求，突出显示关键字：时间、实体标识（比如vmname）、操作名称。</p><p>排查问题的基本步骤：</p><p>登录到应用服务器 -&gt; 打开日志文件 -&gt; 定位到错误日志位置 -&gt; 根据错误日志的线索的指导去排查、确认问题和解决问题。</p><p>其中：</p><p>1.从登陆到打开日志文件：由于应用服务器有多台， 要逐一登录上去查看实在不方便。需要编写一个工具放在 AG 上直接在 AG 上查看所有服务器日志， 甚至直接筛选出所需要的错误日志。</p><p>2.定位错误日志位置。目前日志的排版密密麻麻，不易定位到错误日志。一般可以先采用”时间”来定位到错误日志的附近前面的地方， 然后使用 实体关键字 / 操作名称 组合来锁定错误日志地方。根据 requestId 定位错误日志虽然比较符合传统，但是要先找到 requestId , 并且不具有描述性。最好能直接根据时间/内容关键字来定位错误日志位置。</p><p>3.分析错误日志。错误日志的内容最好能够更加直接明了， 能够明确指明与当前要排查的问题特征是吻合的， 并且给出重要线索。</p><p>通常， 程序错误日志的问题就是日志内容是针对当前代码情境才能理解，看上去简洁， 但总是写的不全， 半英文格式；一旦离开代码情境， 就很难知道究竟说的是什么， 非要让人思考一下或者去看看代码才能明白日志说的是什么含义。这不是自己给自己罪受？</p><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ((storageType == StorageType.dfs1 || storageType == StorageType.dfs2)</span><br><span class="line">                &amp;&amp; (zone.hasStorageType(StorageType.io3) || zone.hasStorageType(StorageType.io4))) {</span><br><span class="line">// 进入dfs1 和dfs2 在io3 io4 存储。</span><br><span class="line">} else {</span><br><span class="line">      log.info("zone storage type not support, zone: " + zone.getZoneId() + ", storageType: "</span><br><span class="line">+ storageType.name());</span><br><span class="line">      throw new BizException(DeviceErrorCode.ZONE_STORAGE_TYPE_NOT_SUPPORT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>zone 要支持什么 storage type 才是正确的? Do Not Let Me Think !</p><p>错误日志应该做到：即使离开代码情境，也能清晰地描述发生了什么。</p><p>此外，如果能够直接在错误日志中说明清楚原因， 在做巡检日志的时候也可以省些力气。</p><p>从某种意义上来说， 错误日志也可以是一种非常有益的文档，记录着各种不合法的运行用例。</p><p>目前程序错误日志的内容可能存在如下问题：</p><p><strong>1. 错误日志没有指明错误参数和内容：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception ex){</span><br><span class="line">      log.error("control ip insert failed", ex);</span><br><span class="line">      return new ResultSet&lt;AddControlIpResponse&gt;(</span><br><span class="line">ControlIpErrorCode.ERROR_CONTROL_IP_INSERT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有指明插入失败的 control ip. 如果加上 control ip 关键字， 更容易搜索和锁定错误。</p><p>类似的还有：</p><p>log.error(“Get some errors when insert subnet and its IPs into database. Add subnet or IP failure.”, e);</p><p>没有指明是哪个 subnet 的它下属的哪些 IP. 值得注意的是， 要指明这些要额外做一些事情， 可能会稍微影响性能。这时候需要权衡性能和可调试性。</p><p>解决方案：使用 String.format(“Some msg to ErrorObj: %s”, errobj) 方法指明错误参数及内容。</p><p>这通常要求对 DO 对象编写可读的 toString 方法。</p><p><strong>2. 错误场景不明确：</strong></p><p>log.error(“nc has exist, nc ip” + request.getIp());</p><p>在 createNc 中检测到 NC 已经存在报错。但是日志上没有指明错误场景， 让人猜测，为什么会报NC已存在错误。</p><p>可以改为</p><p>log.error(“nc has exist when want to create nc, please check nc parameters. Given nc ip: “ + request.getIp());</p><p>log.error(“[create nc] nc has exist, please check nc parameters. Given nc ip: “ + request.getIp());</p><p>类似的还有：</p><p>log.error(“not all vm destroyed, nc id “ + request.getNcId());</p><p>改成 log.error(“[delete nc] some vms [%s] in the nc are not destroyed. nc id: %s”, vmNames, request.getNcId());</p><p>解决方案：错误消息加上 when 字句， 或者错误消息前加上 【接口名】, 指明错误场景，直接从错误日志就知道明白了。</p><p>一般能够知道 executor 的可以加上 【接口名】， service 加上 when 字句。</p><p><strong>3. 内容不明确, 或不明其义：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(aliMonitorReporter == null) {</span><br><span class="line">        log.error("aliMonitorReporter is null!");</span><br><span class="line">} else {</span><br><span class="line">       aliMonitorReporter.attach(new ThreadPoolMonitor(namePrefix, asynTaskThreadPool.getThreadPoolExecutor()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改为：log.error(“aliMonitorReporter is null, probably not initialized properly, please check configuration in file xxx.”);</p><p>类似的还有：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (diskWbps == null &amp;&amp; diskRbps == null &amp;&amp; diskWiops == null    &amp;&amp; diskRiops == null) {</span><br><span class="line">      log.error("none of attribute is specified for modifying");</span><br><span class="line">      throw new BizException(DeviceErrorCode.NO_ATTRIBUTE_FOR_MODIFY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改为 log.error(“[modify disk attribute] None of [diskWbps,diskRbps,diskWiops,diskRiops] is specified for disk id:” + diskId);</p><p>解决方案：更清晰贴切地描述错误内容。</p><p><strong>4. 排查问题的引导内容不明确：</strong></p><p>log.error(“get gw group ip segment failed. zkPath: “ + LockResource.getGwGroupIpSegmnetLockPath(request.getGwGroupId()));</p><p>zkPath ? 如何去排查这个问题？我该去找谁？到哪里去查找更具体的线索？</p><p>解决方案：加上相应的背景知识和引导排查措施。</p><p><strong>5. 错误内容不够具体细致：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!ncResourceService.isNcResourceEnough(ncResourceDO,    vmResourceCondition)) {</span><br><span class="line">      log.error("disk space is not enough at vm's nc, nc id:" + vmDO.getNcId());</span><br><span class="line">      throw new BizException(ResourceErrorCode.ERROR_RESOURCE_NOT_ENOUGH);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>究竟是什么资源不够？目前剩余多少？现在需要多少？值得注意的是， 要指明这些要额外做一些事情， 可能会稍微影响性能。这时候需要权衡性能和可调试性。</p><p>解决方案：通过改进程序或程序技巧， 尽可能揭示出具体的差异所在， 减少人工比对的操作。</p><p><strong>6. 半英文句式读起来不够清晰明白，需要思考来拼凑起完整的意思：</strong></p><p>log.warn(“cache status conflict, device id “+deviceDO.getId()+” db status “+deviceDO.getStatus() +”, nc status “+ status);</p><p>改为:</p><p>log.warn(String.format(“[query cache status] device cache status conflicts between regiondb and nc, status of device ‘%s’ in regiondb is %s , but is %s in nc.”, deviceDO.getId(), deviceDO.getStatus(), status));</p><p>解决方案：改为自然可读的英文句式。</p><p>总结起来， 错误日志格式可以为：</p><p>log.error(“[接口名或操作名] [Some Error Msg] happens. [params] [Probably Because]. [Probably need to do].”);</p><p>log.error(String.format(“[接口名或操作名] [Some Error Msg] happens. [%s]. [Probably Because]. [Probably need to do].”, params));</p><p>或</p><p>log.error(“[Some Error Msg] happens to 错误参数或内容 when [in some condition]. [Probably Because]. [Probably need to do].”);</p><p>log.error(String.format(“[Some Error Msg] happens to %s when [in some condition]. [Probably Because]. [Probably need to do].”, parameters));</p><p>[Probably Reason]. [Probably need to do]. 在某些情况下可以省略；在一些重要接口和场景下最好能说明一下。</p><p>每一条错误日志都是独立的，尽可能完整、具体、直接说明何种场景下发生了什么错误，由什么原因导致，要采用什么措施或步骤。</p><p>问题：</p><p>1.String.format 的性能会影响打日志吗？一般来说， 错误日志应该是比较少的， 使用 String.format 的频度并不会太高，不会对应用和日志造成影响。</p><p>2.开发时间非常紧张时， 有时间去斟酌字句吗？建立一个标准化的内容格式，将内容往格式套，可以节省斟酌字句的时间。</p><p>3.什么时候使用 info, warn , error ?</p><p>info 用于打印程序应该出现的正常状态信息， 便于追踪定位；</p><p>warn 表明系统出现轻微的不合理但不影响运行和使用；</p><p>error 表明出现了系统错误和异常，无法正常完成目标操作。</p><p><a href="http://stackoverflow.com/questions/2031163/when-to-use-log-level-warn-vs-error">http://stackoverflow.com/questions/2031163/when-to-use-log-level-warn-vs-error</a></p><p>错误日志是排查问题的重要手段之一。当我们编程实现一项功能时， 通常会考虑可能发生的各种错误及相应原因：</p><p>要排查出相应的原因， 就需要一些关键描述来定位原因。这就会形成三元组：</p><p>错误现象 -&gt; 错误关键描述 -&gt; 最终的错误原因。</p><p>需要针对每一种错误尽可能提供相应的错误关键描述，从而定位到相应的错误原因。</p><p>也就是说，编程的时候，要仔细思考， 哪些描述是非常有利于定位错误原因的， 尽可能将这些描述添加到错误日志中。</p><p>文中没有指出的问题或困难， 请提出你的建议。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列中如何保证消息的顺序性</title>
      <link href="/posts/3216271943/"/>
      <url>/posts/3216271943/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文选自：advanced-java</p><p>作者：yanglbme</p></blockquote><p><strong>问：如何保证消息的顺序性？</strong></p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215423.png" alt="Image"></p><ul><li><p><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。</p><p>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215403.png" alt="Image"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215388.png" alt="Image"></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215350.png" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读 MySQL 源码再看 INSERT 加锁流程</title>
      <link href="/posts/3984514586/"/>
      <url>/posts/3984514586/</url>
      
        <content type="html"><![CDATA[<h1 id="读-MySQL-源码再看-INSERT-加锁流程"><a href="#读-MySQL-源码再看-INSERT-加锁流程" class="headerlink" title="读 MySQL 源码再看 INSERT 加锁流程"></a>读 MySQL 源码再看 INSERT 加锁流程</h1><p>有一个问题，我还是彻底被问蒙了。他的问题是这样的：</p><blockquote><p>加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？</p></blockquote><p>这个问题初看上去很简单，在 RR 隔离级别下，假设要插入的记录不存在，如果先执行select…lock in share mode 语句，很显然会在记录间隙之间加上 GAP 锁，而 insert 语句首先会对记录加插入意向锁，插入意向锁和 GAP 锁冲突，所以不存在幻读；如果先执行 insert 语句后执行 select…lock in share mode 语句，由于 insert 语句在插入记录之后，会对记录加 X 锁，它会阻止 select…lock in share mode 对记录加 S 锁，所以也不存在幻读。两种情况如下所示：</p><p>先执行 INSERT 后执行 SELECT：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826918.jpeg" alt="Image">先执行 SELECT 后执行 INSERT：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826856.jpeg" alt="Image"></p><p>但是我们仔细想一想就会发现哪里有点不对劲，我们知道 insert 语句会先在插入间隙上加上插入意向锁，然后开始写数据，写完数据之后再对记录加上 X 记录锁（这里简化了，关于insert 语句的加锁流程，可以参考我之前写的常见 SQL 语句的加锁分析）。那么问题就来了，如果在 insert 语句加插入意向锁之后，写数据之前，执行了 select…lock in share mode语句，这个时候 GAP 锁和插入意向锁是不冲突的，查询出来的记录数为 0，然后insert 语句写数据，加 X 记录锁，因为记录锁和 GAP 锁也是不冲突的，所以 insert 成功插入了一条数据，这个时候如果事务提交，select…lock in share mode 语句再次执行查询出来的记录数就是 1，岂不是就出现了幻读？</p><p>整个流程如下所示（我们把 insert 语句的执行分成两个阶段，INSERT 1 加插入意向锁，还没写数据，INSERT 2 写数据，加记录锁）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826953.jpeg" alt="Image"></p><p><strong>一、INSERT 加锁的困惑</strong></p><p>在得出上面的结论时，我也感到很惊讶。按理是不可能出现这种情况的，只可能是我对这两个语句的加锁过程还没有想明白。于是我又去复习了一遍 MySQL 官方文档，Locks Set by Different SQL Statements in InnoDB 这篇文档对各个语句的加锁有详细的描述，其中对insert 的加锁过程是这样说的（这应该是网络上介绍 MySQL 加锁机制被引用最多的文档，估计也是被误解最多的文档）：</p><blockquote><p>INSERT sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.<br>Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6 each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.<br>If a duplicate-key error occurs, a shared lock on the duplicate index record is set. This use of a shared lock can result in deadlock should there be multiple sessions trying to insert the same row if another session already has an exclusive lock. This can occur if another session deletes the row.</p></blockquote><p>讲到了 insert 会对插入的这条记录加排他记录锁，在加记录锁之前还会加一种 GAP 锁，叫做插入意向锁，如果出现唯一键冲突，还会加一个共享记录锁。这和我之前的理解是完全一样的，那么究竟是怎么回事呢？难道 MySQL 的 RR 真的会出现幻读现象？</p><p>在 Google 上搜索了很久，并没有找到 MySQL 幻读的问题，百思不得其解之际，遂决定从 MySQL 的源码中一探究竟。</p><h2 id="二、编译-MySQL-源码"><a href="#二、编译-MySQL-源码" class="headerlink" title="二、编译 MySQL 源码"></a><strong>二、编译 MySQL 源码</strong></h2><p>编译 MySQL 的源码非常简单，但是中间也有几个坑，如果能绕过这几个坑，在本地调试 MySQL 是一件很容易的事（当然能调试源码是一回事，能看懂源码又是另一回事了）。</p><p>我的环境是 Windows 10 x64，系统上安装了 Visual Studio 2012，如果你的开发环境和我不一样，编译步骤可能也会不同。</p><p>在开始之前，首先要从官网下载 MySQL 源码：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826818.jpeg" alt="Image"></p><p>这里我选择的是 5.6.40 版本，操作系统下拉列表里选 Source Code，OS Version 选择 Windows（Architecture Independent），然后就可以下载打包好的 zip 源码了。</p><p>将源码解压缩到 D:\mysql-5.6.40 目录，在编译之前，还需要再安装几个必要软件：</p><ul><li><strong>CMake</strong>：CMake 本身并不是编译工具，它是通过编写一种平台无关的 CMakeList.txt 文件来定制编译流程的，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程；</li><li><strong>Bison</strong>：MySQL 在执行 SQL 语句时，必然要对 SQL 语句进行解析，一般来说语法解析器会包含两个模块：词法分析和语法规则。词法分析和语法规则模块有两个较成熟的开源工具 Flex 和 Bison 分别用来解决这两个问题。MySQL 出于性能和灵活考虑，选择了自己完成词法解析部分，语法规则部分使用了 Bison，所以这里我们还要先安装 Bison。Bison 的默认安装路径为 C:\Program Files\GnuWin32，但是千万不要这样，一定要记得选择一个不带空格的目录，譬如 C:\GnuWin32 要不然在后面使用 Visual Studio 编译 MySQL 时会卡死；</li><li>Visual Studio：没什么好说的，Windows 环境下估计没有比它更好的开发工具了吧。</li></ul><p>安装好 CMake 和 Bison 之后，记得要把它们都加到 PATH 环境变量中。做好准备工作，我们就可以开始编译了，首先用 CMake 生成 Visual Studio 的工程文件:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1D:\mysql-5.6.40&gt; mkdir project</span><br><span class="line">2D:\mysql-5.6.40&gt; cd project</span><br><span class="line">3D:\mysql-5.6.40\project&gt; cmake -G "Visual Studio 11 2012 Win64" ..</span><br></pre></td></tr></tbody></table></figure><p>cmake 的-G 参数用于指定生成哪种类型的工程文件，这里是 Visual Studio 2012，可以直接输入 cmake -G 查看支持的工程类型。如果没问题，会在 project 目录下生成一堆文件，其中 MySQL.sln 就是我们要用的工程文件，使用 Visual Studio 打开它。</p><p>打开 MySQL.sln 文件，会在 Solution Explorer 看到 130 个项目，其中有一个叫 ALL_BUILD，这个时候如果直接编译，编译会失败，在这之前，我们还要对代码做点修改：</p><ul><li>首先是 sql\sql_locale.cc 文件，看名字就知道这个文件用于国际化与本土化，这个文件里有各个国家的语言字符，但是这个文件却是 ANSI 编码，所以要将其改成 Unicode 编码；</li><li>打开 sql\mysqld.cc 文件的第 5239 行，将 DBUG_ASSERT(0) 改成DBUG_ASSERT(1)，要不然调试时会触发断言；</li></ul><p>现在我们可以编译整个工程了，选中 ALL_BUILD 项目，Build，然后静静的等待 5 到 10 分钟，如果出现了 Build: 130 succeeded, 0 failed 这样的提示，那么恭喜，你现在可以尽情的调试 MySQL 了。</p><p>我们将 mysqld 设置为 Startup Project，然后加个命令行参数 –console，这样可以在控制台里查看打印的调试信息：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826853.jpeg" alt="Image"></p><p>另外， client\Debug\mysql.exe 这个文件是对应的 MySQL 的客户端，可以直接双击运行，默认使用的用户为 ODBC@localhost，如果要以 root 用户登录，可以执行 mysql.exe -u root，不需要密码。</p><h2 id="三、调试-INSERT-加锁流程"><a href="#三、调试-INSERT-加锁流程" class="headerlink" title="三、调试 INSERT 加锁流程"></a><strong>三、调试 INSERT 加锁流程</strong></h2><p>首先我们创建一个数据库 test，然后创建一个测试表 t，主键为 id，并插入测试数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1use test;</span><br><span class="line">2create table t(id int NOT NULL AUTO_INCREMENT , PRIMARY KEY (id));</span><br><span class="line">3insert into t(id) values(1),(10),(20),(50);</span><br></pre></td></tr></tbody></table></figure><p>然后我们开两个客户端会话，一个会话执行 insert into t(id) value(30)，另一个会话执行select * from t where id = 30 lock in share mode。很显然，如果我们能在 insert 语句加插入意向锁之后写数据之前下个断点，再在另一个会话中执行 select 就可以模拟出这种场景了。</p><p>那么我们来找下 insert 语句是在哪加插入意向锁的。第一次看 MySQL 源码可能会有些不知所措，调着调着就会迷失在深深的调用层级中，我们看 insert 语句的调用堆栈，一开始时还比较容易理解，从 <em>mysql_parse -&gt; mysql_execute_command -&gt; mysql_insert -&gt; write_record -&gt; handler::ha_write_row -&gt; innobase::write_row -&gt; row_insert_for_mysql</em>，这里就进入 InnoDb 引擎了。</p><p>然后继续往下跟：<em>row_ins_step -&gt; row_ins -&gt; row_ins_index_entry_step -&gt; row_ins_index_entry -&gt; row_ins_clust_index_entry -&gt; row_ins_clust_index_entry_low -&gt; btr_cur_optimistic_insert -&gt; btr_cur_ins_lock_and_undo -&gt; lock_rec_insert_check_and_lock。</em></p><p>一路跟下来，都没有发现插入意向锁的踪迹，直到 lock_rec_insert_check_and_lock 这里：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1if (lock_rec_other_has_conflicting(</span><br><span class="line"> 2        static_cast&lt;enum lock_mode&gt;(</span><br><span class="line"> 3            LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION),</span><br><span class="line"> 4        block, next_rec_heap_no, trx)) {</span><br><span class="line"> 5</span><br><span class="line"> 6    /* Note that we may get DB_SUCCESS also here! */</span><br><span class="line"> 7    trx_mutex_enter(trx);</span><br><span class="line"> 8</span><br><span class="line"> 9    err = lock_rec_enqueue_waiting(</span><br><span class="line">10        LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION,</span><br><span class="line">11        block, next_rec_heap_no, index, thr);</span><br><span class="line">12</span><br><span class="line">13    trx_mutex_exit(trx);</span><br><span class="line">14} else {</span><br><span class="line">15    err = DB_SUCCESS;</span><br><span class="line">16}</span><br></pre></td></tr></tbody></table></figure><p>这里是检查是否有和插入意向锁冲突的其他锁，如果有冲突，就将插入意向锁加到锁等待队列中。这很显然是先执行 select … lock in share mode 语句再执行 insert 语句时的情景，插入意向锁和 GAP 冲突。但这不是我们要找的点，于是继续探索，但是可惜的是，直到 insert 执行结束，我都没有找到加插入意向锁的地方。</p><p>跟代码非常辛苦，我担心是因为我跟丢了某块的逻辑导致没看到加锁，于是我看了看加其他锁的地方，发现在 InnoDb 里行锁都是通过调 lock_rec_add_to_queue（没有锁冲突） 或者 lock_rec_enqueue_waiting（有锁冲突，需要等待其他事务释放锁） 来实现的，于是在这两个函数上下断点，执行一条 insert 语句，依然没有断下来，说明 insert 语句没有加任何锁！</p><p>到这里我突然想起之前做过的 insert 加锁的实验，执行 insert 之后，如果没有任何冲突，在show engine innodb status 命令中是看不到任何锁的，这是因为 insert 加的是隐式锁。<strong>什么是隐式锁？隐式锁的意思就是没有锁！</strong></p><p>所以，根本就不存在之前说的先加插入意向锁，再加排他记录锁的说法，在执行 insert 语句时，什么锁都不会加。这就有点意思了，如果 insert 什么锁都不加，那么如果其他事务执行select … lock in share mode，它是如何阻止其他事务加锁的呢？</p><p>答案就在于隐式锁的转换。</p><p>InnoDb 在插入记录时，是不加锁的。如果事务 A 插入记录且未提交，这时事务 B 尝试对这条记录加锁，事务 B 会先去判断记录上保存的事务 id 是否活跃，如果活跃的话，那么就帮助事务 A 去建立一个锁对象，然后自身进入等待事务 A 状态，这就是所谓的隐式锁转换为显式锁。</p><p>我们跟一下执行 select 时的流程，如果 select 需要加锁，则会走：<em>sel_set_rec_lock -&gt; lock_clust_rec_read_check_and_lock -&gt; lock_rec_convert_impl_to_expl，lock_rec_convert_impl_to_expl</em> 函数的核心代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1impl_trx = trx_rw_is_active(trx_id, NULL);</span><br><span class="line"> 2</span><br><span class="line"> 3if (impl_trx != NULL</span><br><span class="line"> 4    &amp;&amp; !lock_rec_has_expl(LOCK_X | LOCK_REC_NOT_GAP, block,</span><br><span class="line"> 5              heap_no, impl_trx)) {</span><br><span class="line"> 6    ulint    type_mode = (LOCK_REC | LOCK_X</span><br><span class="line"> 7                 | LOCK_REC_NOT_GAP);</span><br><span class="line"> 8</span><br><span class="line"> 9    lock_rec_add_to_queue(</span><br><span class="line">10        type_mode, block, heap_no, index,</span><br><span class="line">11        impl_trx, FALSE);</span><br><span class="line">12}</span><br></pre></td></tr></tbody></table></figure><p>首先判断事务是否活跃，然后检查是否已存在排他记录锁，如果事务活跃且不存在锁，则为该事务加上排他记录锁。而本事务的锁是通过 lock_rec_convert_impl_to_expl 之后的lock_rec_lock 函数来加的。</p><p>到这里，这个问题的脉络已经很清晰了：</p><ol><li>执行 insert 语句，判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁；</li><li>执行 select … lock in share mode 语句，判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列；</li></ol><p>所以不存在网友所说的幻读问题。那么事情到此结束了么？并没有。</p><p>细心的你会发现，执行 insert 语句时，从判断是否有锁冲突，到写数据，这两个操作之间还是有时间差的，如果在这之间执行 select … lock in share mode 语句，由于此时记录还不存在，所以也不存在活跃事务，不会触发隐式锁转换，这条语句会返回 0 条记录，并加上 GAP 锁；而 insert 语句继续写数据，不加任何锁，在 insert 事务提交之后，select … lock in share mode 就能查到 1 条记录，这岂不是还有幻读问题吗？</p><p>为了彻底搞清楚这中间的细节，我们在 lock_rec_insert_check_and_lock 检查完锁冲突之后下个断点，然后在另一个事务中执行 select … lock in share mode，如果它能成功返回 0 条记录，加上 GAP 锁，说明就存在幻读。不过事实上，这条 SQL 语句执行的时候卡住了，并不会返回 0 条记录。从 show engine innodb status 的 TRANSACTIONS 里我们看不到任何行锁冲突的信息，但是我们从 RW-LATCH INFO 中却可以看出一些端倪：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 15    </span><br><span class="line"> 2-------------</span><br><span class="line"> 3RW-LATCH INFO</span><br><span class="line"> 4-------------</span><br><span class="line"> 5RW-LOCK: 000002C97F62FC70</span><br><span class="line"> 6Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 879  S-LOCK</span><br><span class="line"> 7RW-LOCK: 000002C976A3B998</span><br><span class="line"> 8Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line"> 9Locked: thread 10304 file d:\mysql-5.6.40\storage\innobase\include\btr0pcur.ic line 518  S-LOCK</span><br><span class="line">10Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line">11Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\row\row0ins.cc line 2339  S-LOCK</span><br><span class="line">12RW-LOCK: 000002C976A3B8A8  Waiters for the lock exist</span><br><span class="line">13Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  X-LOCK</span><br><span class="line">14Total number of rw-locks 16434</span><br><span class="line">15OS WAIT ARRAY INFO: reservation count 10</span><br><span class="line">16--Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore:</span><br><span class="line">17S-lock on RW-latch at 000002C976A3B8A8 created in file buf0buf.cc line 1069</span><br><span class="line">18a writer (thread id 2820) has reserved it in mode  exclusive</span><br><span class="line">19number of readers 0, waiters flag 1, lock_word: 0</span><br><span class="line">20Last time read locked in file btr0cur.cc line 256</span><br><span class="line">21Last time write locked in file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256</span><br><span class="line">22OS WAIT ARRAY INFO: signal count 8</span><br><span class="line">23Mutex spin waits 44, rounds 336, OS waits 7</span><br><span class="line">24RW-shared spins 3, rounds 90, OS waits 3</span><br><span class="line">25RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">26Spin rounds per wait: 7.64 mutex, 30.00 RW-shared, 0.00 RW-excl</span><br><span class="line">27</span><br></pre></td></tr></tbody></table></figure><p>这里列出了 3 个 RW-LOCK：000002C97F62FC70、000002C976A3B998、000002C976A3B8A8。其中可以看到最后一个 RW-LOCK 有其他线程在等待其释放（Waiters for the lock exist）。下面列出了所有等待该锁的线程，Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore，这里的 Thread 10304 就是我们正在执行 select 语句的线程，它卡在了 btr0cur.cc 的 256 行，我们查看 Thread 10304 的堆栈：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826932.jpeg" alt="Image"></p><p>btr0cur.cc 的 256 行位于 btr_cur_latch_leaves 函数，如下所示，通过 btr_block_get 来加锁，看起来像是在访问 InnoDb B+ 树的叶子节点时卡住了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1case BTR_MODIFY_LEAF:</span><br><span class="line">2    mode = latch_mode == BTR_SEARCH_LEAF ? RW_S_LATCH : RW_X_LATCH;</span><br><span class="line">3    get_block = btr_block_get(</span><br><span class="line">4        space, zip_size, page_no, mode, cursor-&gt;index, mtr);</span><br></pre></td></tr></tbody></table></figure><p>这里latch_mode==BTR_SEARCH_LEAF，所以加锁的mode为 RW_S_LATCH。</p><p>这里要介绍一个新的概念，叫做 <strong>Latch</strong>，一般也把它翻译成 “锁”，但它和我们之前接触的行锁表锁（<strong>Lock</strong>）是有区别的。这是一种轻量级的锁，锁定时间一般非常短，它是用来保证并发线程可以安全的操作临界资源，通常没有死锁检测机制。Latch 可以分为两种：MUTEX（互斥量）和 RW-LOCK（读写锁），很显然，这里我们看到的是 RW-LOCK。</p><p>我们回溯一下 select 语句的调用堆栈：<em>ha_innobase::index_read -&gt; row_search_for_mysql -&gt; btr_pcur_open_at_index_side -&gt; btr_cur_latch_leaves</em>，从调用堆栈可以看出 select … lock in share mode 语句在访问索引，那么为什么访问索引会被卡住呢？</p><p>接下来我们看看这个 RW-LOCK 是在哪里加上的？从日志里可以看到 Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256 X-LOCK，所以这个锁是线程 2820 加上的，加锁的位置也在 btr0cur.cc 的 256 行，查看函数引用，很快我们就查到这个锁是在执行 insert 时加上的，函数堆栈为：<em>row_ins_clust_index_entry_low -&gt; btr_cur_search_to_nth_level -&gt; btr_cur_latch_leaves</em>。</p><p>我们看这里的 row_ins_clust_index_entry_low 函数（无关代码已省略）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> 1UNIV_INTERN</span><br><span class="line"> 2dberr_t</span><br><span class="line"> 3row_ins_clust_index_entry_low(</span><br><span class="line"> 4/*==========================*/</span><br><span class="line"> 5    ulint        flags,    /*!&lt; in: undo logging and locking flags */</span><br><span class="line"> 6    ulint        mode,    /*!&lt; in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE,</span><br><span class="line"> 7                depending on whether we wish optimistic or</span><br><span class="line"> 8                pessimistic descent down the index tree */</span><br><span class="line"> 9    dict_index_t*    index,    /*!&lt; in: clustered index */</span><br><span class="line">10    ulint        n_uniq,    /*!&lt; in: 0 or index-&gt;n_uniq */</span><br><span class="line">11    dtuple_t*    entry,    /*!&lt; in/out: index entry to insert */</span><br><span class="line">12    ulint        n_ext,    /*!&lt; in: number of externally stored columns */</span><br><span class="line">13    que_thr_t*    thr)    /*!&lt; in: query thread */</span><br><span class="line">14{</span><br><span class="line">15    /* 开启一个 mini-transaction */</span><br><span class="line">16    mtr_start(&amp;mtr);</span><br><span class="line">17</span><br><span class="line">18    /* 调用 btr_cur_latch_leaves -&gt; btr_block_get 加 RW_X_LATCH */</span><br><span class="line">19    btr_cur_search_to_nth_level(index, 0, entry, PAGE_CUR_LE, mode,</span><br><span class="line">20                    &amp;cursor, 0, __FILE__, __LINE__, &amp;mtr);</span><br><span class="line">21</span><br><span class="line">22    if (mode != BTR_MODIFY_TREE) {</span><br><span class="line">23        /* 不需要修改 BTR_TREE，乐观插入 */</span><br><span class="line">24        err = btr_cur_optimistic_insert(</span><br><span class="line">25            flags, &amp;cursor, &amp;offsets, &amp;offsets_heap,</span><br><span class="line">26            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">27            n_ext, thr, &amp;mtr);</span><br><span class="line">28    } else {</span><br><span class="line">29        /* 需要修改 BTR_TREE，先乐观插入，乐观插入失败则进行悲观插入 */</span><br><span class="line">30        err = btr_cur_optimistic_insert(</span><br><span class="line">31            flags, &amp;cursor,</span><br><span class="line">32            &amp;offsets, &amp;offsets_heap,</span><br><span class="line">33            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">34            n_ext, thr, &amp;mtr);</span><br><span class="line">35        if (err == DB_FAIL) {</span><br><span class="line">36            err = btr_cur_pessimistic_insert(</span><br><span class="line">37                flags, &amp;cursor,</span><br><span class="line">38                &amp;offsets, &amp;offsets_heap,</span><br><span class="line">39                entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">40                n_ext, thr, &amp;mtr);</span><br><span class="line">41        }</span><br><span class="line">42    }</span><br><span class="line">43</span><br><span class="line">44    /* 提交 mini-transaction */</span><br><span class="line">45    mtr_commit(&amp;mtr);</span><br><span class="line">46}</span><br></pre></td></tr></tbody></table></figure><p>这里是执行 insert 语句的关键，可以发现执行插入操作的前后分别有一行代码：mtr_start() 和 mtr_commit()。这被称为 <strong>迷你事务（mini-transaction）</strong>，既然叫做事务，那这个函数的操作肯定是原子性的，事实上确实如此，insert 会在检查锁冲突和写数据之前，会对记录所在的页加一个 RW-X-LATCH 锁，执行完写数据之后再释放该锁（实际上写数据的操作就是写 redo log（重做日志），将脏页加入 flush list，这个后面有时间再深入分析了）。这个锁的释放非常快，但是这个锁足以保证在插入数据的过程中其他事务无法访问记录所在的页。mini-transaction 也可以包含子事务，实际上在 insert 的执行过程中就会加多个 mini-transaction。</p><p>每个 mini-transaction 会遵守下面的几个规则：</p><ul><li>修改一个页需要获得该页的 X-LATCH；</li><li>访问一个页需要获得该页的 S-LATCH 或 X-LATCH；</li><li>持有该页的 LATCH 直到修改或者访问该页的操作完成。</li></ul><p>所以，最后的最后，真相只有一个：insert 和 select … lock in share mode 不会发生幻读。整个流程如下：</p><ol><li>执行 insert 语句，对要操作的页加 RW-X-LATCH，然后判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁，结束后释放 RW-X-LATCH；</li><li>执行 select … lock in share mode 语句，对要操作的页加 RW-S-LATCH，如果页面上存在 RW-X-LATCH 会被阻塞，没有的话则判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列，最后也会释放 RW-S-LATCH；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol><li>Locks Set by Different SQL Statements in InnoDB</li><li>Installing MySQL from Source</li><li>CMake 入门实战</li><li>MySQL源代码：从SQL语句到MySQL内部对象</li><li>MySQL · 源码分析 · 一条insert语句的执行过程</li><li>[MySQL源码] 一条简单insert语句的调用栈</li><li>MySQL5.7 : 对隐式锁转换的优化</li><li>[MySQL学习] Innodb锁系统(4) Insert/Delete 锁处理及死锁示例分析</li><li>InnoDB事务锁之行锁-insert加锁-隐式锁加锁原理</li><li>InnoDB事务锁之行锁-判断是否有隐式锁原理图</li><li>InnoDB事务锁之行锁-隐式锁转换显示锁举例理解原理</li><li>MySQL系列：innodb源码分析之mini transaction</li><li>MySQL - InnoDB mini transation</li><li>MySQL · 引擎特性 · InnoDB redo log漫游</li></ol><h1 id="原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql"><a href="#原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql" class="headerlink" title="原文：https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-"></a>原文：<a href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-">https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-</a></h1><h1 id="source-code-html"><a href="#source-code-html" class="headerlink" title="source-code.html"></a>source-code.html</h1>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发场景下，到底先更新缓存还是先更新数据库？</title>
      <link href="/posts/3795959674/"/>
      <url>/posts/3795959674/</url>
      
        <content type="html"><![CDATA[<h1 id="高并发场景下，到底先更新缓存还是先更新数据库？"><a href="#高并发场景下，到底先更新缓存还是先更新数据库？" class="headerlink" title="高并发场景下，到底先更新缓存还是先更新数据库？"></a>高并发场景下，到底先更新缓存还是先更新数据库？</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。</p><p>为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510138.png" alt="Image"></p><h2 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h2><p><code>Cache aside</code>也就是<code>旁路缓存</code>，是比较常用的缓存策略。</p><p><strong>（1）<code>读请求</code>常见流程</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510215.png" alt="Image">Cache aside 读请求</p><p>应用首先会判断缓存是否有该数据，缓存命中直接返回数据，缓存未命中即缓存穿透到数据库，从数据库查询数据然后回写到缓存中，最后返回数据给客户端。</p><p><strong>（2）<code>写请求</code>常见流程</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510222.png" alt="Image">Cache aside 写请求</p><p>首先更新数据库，然后从缓存中删除该数据。</p><p>看了写请求的图之后，有些同学可能要问了：为什么要删除缓存，直接更新不就行了？这里涉及到几个坑，我们一步一步踩下去。</p><h2 id="Cache-aside踩坑"><a href="#Cache-aside踩坑" class="headerlink" title="Cache aside踩坑"></a>Cache aside踩坑</h2><p>Cache aside策略如果用错就会遇到深坑，下面我们来逐个踩。</p><p><strong>踩坑一：先更新数据库，再更新缓存</strong></p><p>如果同时有两个<code>写请求</code>需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510240.png" alt="Image">先更新数据库，再更新缓存</p><p>如上图的执行过程：</p><p>（1）<code>写请求1</code>更新数据库，将 age 字段更新为18；</p><p>（2）<code>写请求2</code>更新数据库，将 age 字段更新为20；</p><p>（3）<code>写请求2</code>更新缓存，缓存 age 设置为20；</p><p>（4）<code>写请求1</code>更新缓存，缓存 age 设置为18；</p><p>执行完预期结果是数据库 age 为20，缓存 age 为20，结果缓存 age为18，这就造成了缓存数据不是最新的，出现了脏数据。</p><p><strong>踩坑二：先删缓存，再更新数据库</strong></p><p>如果<code>写请求</code>的处理流程是<code>先删缓存再更新数据库</code>，在一个<code>读请求</code>和一个<code>写请求</code>并发场景下可能会出现数据不一致情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246.png" alt="Image">先删缓存，再更新数据库</p><p>如上图的执行过程：</p><p>（1）<code>写请求</code>删除缓存数据；</p><p>（2）<code>读请求</code>查询缓存未击中(Hit Miss)，紧接着查询数据库，将返回的数据回写到缓存中；</p><p>（3）<code>写请求</code>更新数据库。</p><p>整个流程下来发现<code>数据库</code>中age为20，<code>缓存</code>中age为18，缓存和数据库数据不一致，缓存出现了脏数据。</p><p><strong>踩坑三：先更新数据库，再删除缓存</strong></p><p>在实际的系统中针对<code>写请求</code>还是推荐<code>先更新数据库再删除缓存</code>，但是在理论上还是存在问题，以下面这个例子说明。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246-2891910.png" alt="Image">先更新数据库，再删除缓存</p><p>如上图的执行过程：</p><p>（1）<code>读请求</code>先查询缓存，缓存未击中，查询数据库返回数据；</p><p>（2）<code>写请求</code>更新数据库，删除缓存；</p><p>（3）<code>读请求</code>回写缓存；</p><p>整个流程操作下来发现<code>数据库age为20</code>，<code>缓存age为18</code>，即数据库与缓存不一致，导致应用程序从缓存中读到的数据都为旧数据。</p><p>但我们仔细想一下，上述问题发生的概率其实非常低，因为通常数据库更新操作比内存操作耗时多出几个数量级，上图中最后一步回写缓存（set age 18）速度非常快，通常会在更新数据库之前完成。</p><p>如果这种极端场景出现了怎么办？我们得想一个兜底的办法：<code>缓存数据设置过期时间</code>。通常在系统中是可以允许少量的数据短时间不一致的场景出现。</p><h2 id="Read-through"><a href="#Read-through" class="headerlink" title="Read through"></a>Read through</h2><p>在 Cache Aside 更新模式中，应用代码需要维护两个数据源头：一个是缓存，一个是数据库。而在 <code>Read-Through</code> 策略下，应用程序无需管理缓存和数据库，只需要将数据库的同步委托给缓存提供程序 <code>Cache Provider</code> 即可。所有数据交互都是通过<code>抽象缓存层</code>完成的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510187.png" alt="Image">Read-Through流程</p><p>如上图，应用程序只需要与<code>Cache Provider</code>交互，不用关心是从缓存取还是数据库。</p><p>在进行大量读取时，<code>Read-Through</code> 可以减少数据源上的负载，也对缓存服务的故障具备一定的弹性。如果缓存服务挂了，则缓存提供程序仍然可以通过直接转到数据源来进行操作。</p><p><code>Read-Through 适用于多次请求相同数据的场景</code>，这与 Cache-Aside 策略非常相似，但是二者还是存在一些差别，这里再次强调一下：</p><ul><li>在 Cache-Aside 中，应用程序负责从数据源中获取数据并更新到缓存。</li><li>在 Read-Through 中，此逻辑通常是由独立的缓存提供程序（Cache Provider）支持。</li></ul><h2 id="Write-through"><a href="#Write-through" class="headerlink" title="Write through"></a>Write through</h2><p><code>Write-Through</code> 策略下，当发生数据更新(Write)时，缓存提供程序 <code>Cache Provider</code> 负责更新底层数据源和缓存。</p><p>缓存与数据源保持一致，并且写入时始终通过<code>抽象缓存层</code>到达数据源。</p><p><code>Cache Provider</code>类似一个代理的作用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230825000426632.png" alt="Image">Write-Through流程</p><h2 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h2><p><code>Write behind</code>在一些地方也被成为<code>Write back</code>， 简单理解就是：应用程序更新数据时只更新缓存， <code>Cache Provider</code>每隔一段时间将数据刷新到数据库中。说白了就是<code>延迟写入</code>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510270.png" alt="Image">Write behind流程</p><p>如上图，应用程序更新两个数据，Cache Provider 会立即写入缓存中，但是隔一段时间才会批量写入数据库中。</p><p>这种方式有优点也有缺点：</p><ul><li><code>优点</code>是数据写入速度非常快，适用于频繁写的场景。</li><li><code>缺点</code>是缓存和数据库不是强一致性，对一致性要求高的系统慎用。</li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>学了这么多，相信大家对缓存更新的策略都已经有了清晰的认识。最后稍稍总结一下。</p><p>缓存更新的策略主要分为三种：</p><ul><li>Cache aside</li><li>Read/Write through</li><li>Write behind</li></ul><p>Cache aside 通常会先更新数据库，然后再删除缓存，为了兜底通常还会将数据设置缓存时间。</p><p>Read/Write through 一般是由一个 Cache Provider 对外提供读写操作，应用程序不用感知操作的是缓存还是数据库。</p><p>Write behind简单理解就是延迟写入，Cache Provider 每隔一段时间会批量输入数据库，优点是应用程序写入速度非常快。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK监控和故障处理工具总结</title>
      <link href="/posts/4058733264/"/>
      <url>/posts/4058733264/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li>**<code>jstat</code>**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code>：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br></pre></td></tr></tbody></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></tbody></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong><code>jstat</code> 命令使用格式：</strong></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]</span><br></pre></td></tr></tbody></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code>：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code>：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code>：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code>：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code>：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code>：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code>：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code>：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code>：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code>：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br></pre></td></tr></tbody></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGC</span><br></pre></td></tr></tbody></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></tbody></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a><strong><code>jhat</code></strong>: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br></pre></td></tr></tbody></table></figure><p>访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a><strong><code>jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) {</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) {</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) {</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) {</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></tbody></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code> Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span></span><br></pre></td></tr></tbody></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></tbody></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001</span><br></pre></td></tr></tbody></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a>。</p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul><p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li><a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域详解</title>
      <link href="/posts/576968662/"/>
      <url>/posts/576968662/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p><p><strong>JDK 1.7</strong>：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）"></p><p><strong>JDK 1.8</strong>：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/stack-area.png" alt="Java 虚拟机栈"></p><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/local-variables-table.png" alt="局部变量表"></p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/jvmimage-20220331175738692.png"></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/hotspot-heap-structure.png" alt="堆内存结构"></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> （我会在方法区这部分内容详细介绍到）。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>{</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) {</span><br><span class="line">total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">age++;</span><br><span class="line">}</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li>**<code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap size</a>)</li><li>……</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/20210425134508117.png"></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></tbody></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></tbody></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-jdk1.6.png" alt="method-area-jdk1.6"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><p>相关问题：<a href="https://www.zhihu.com/question/57109429/answer/151717241">JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎</a></p><p>最后再来分享一段周志明老师在<a href="https://github.com/fenixsoft/jvm_book">《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误</a> GitHub 仓库的 <a href="https://github.com/fenixsoft/jvm_book/issues/112">issue#112</a> 中说过的话：</p><blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表：<ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li>《自己动手写 Java 虚拟机》</li><li>Chapter 2. The Structure of the Java Virtual Machine：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</a></li><li>JVM 栈帧内部结构-动态链接：<a href="https://chenxitag.com/archives/368">https://chenxitag.com/archives/368</a></li><li>Java 中 new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎：<a href="https://www.zhihu.com/question/55994121/answer/147296098">https://www.zhihu.com/question/55994121/answer/147296098</a></li><li>JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎：<a href="https://www.zhihu.com/question/57109429/answer/151717241">https://www.zhihu.com/question/57109429/answer/151717241</a></li><li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li><li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li><li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收详解（重点）</title>
      <link href="/posts/152633231/"/>
      <url>/posts/152633231/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题：</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/hotspot-heap-structure-20230614222444908.png" alt="堆内存结构"></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><p>关于堆空间结构更详细的介绍，可以回过头看看 <a href="./Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3.md">Java 内存区域详解</a> 这篇文章。</p><h2 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h2><h3 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试以下。</p><p>测试代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过以下方式运行：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/25178350.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/run-with-PrintGCDetails.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/28954286.jpg"></p><p>从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。</p><p>假如我们再为 <code>allocation2</code> 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/28128785.jpg"></p><p>给 <code>allocation2</code> 分配内存的时候 Eden 区内存几乎已经被分配完了</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8 官方文档引用：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/image-20210523201742303.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>{</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) {</span><br><span class="line"><span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">total += sizes[age];</span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">age++;</span><br><span class="line">}</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/rf-hotspot-vm-gc.png" alt="R 大的回答"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p></blockquote><h2 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/object-circular-reference.png" alt="对象之间循环引用"></p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/jvm-gc-roots.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p><p>参考：</p><ul><li><a href="https://openjdk.java.net/jeps/421">JEP 421: Deprecate Finalization for Removal</a></li><li><a href="https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg">是时候忘掉 finalize 方法了</a></li></ul></blockquote><h3 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/java-reference-type.png" alt="Java 引用类型总结"></p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong>：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类？"><a href="#如何判断一个类是无用的类？" class="headerlink" title="如何判断一个类是无用的类？"></a>如何判断一个类是无用的类？</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法"></p><p>关于具体是标记可回收对象还是不可回收对象，众说纷纭，两种说法其实都没问题，我个人更倾向于是前者。</p><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/copying-garbage-collection-algorithm.png" alt="复制算法"></p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法"></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/serial-garbage-collector.png" alt="Serial 收集器"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parnew-garbage-collector.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></tbody></table></figure><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">"1.8.0_211"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></tbody></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/serial-garbage-collector.png" alt="Serial 收集器"></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/cms-garbage-collector.png" alt="CMS 收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/g1-garbage-collector.png" alt="G1 收集器"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UseZGC className</span><br></pre></td></tr></tbody></table></figure><p>关于 ZGC 收集器的详细介绍推荐阅读美团技术团队的 <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器 ZGC 的探索与实践</a> 这篇文章。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM线上问题排查和性能调优案例</title>
      <link href="/posts/4053882931/"/>
      <url>/posts/4053882931/</url>
      
        <content type="html"><![CDATA[<p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。</p><p>这篇文章，我会分享一些我看到的相关的案例。</p><p>下面是正文。</p><p><a href="https://juejin.cn/post/7205141492264976445">一次线上 OOM 问题分析 - 艾小仙 - 2023</a></p><ul><li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li><li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li><li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li><li><strong>资料</strong>：<a href="https://heapdump.cn/article/3489050">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</a>。</li></ul><p><a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023</a></p><ul><li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li><li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。</li><li><strong>建议</strong>：正常情况下，<code>-Xmn</code>参数（控制 Young 区的大小）总是应当小于<code>-Xmx</code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li><li><strong>资料</strong>：<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的 JVM 参数总结 - JavaGuide - 2023</a></li></ul><p><a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></p><ul><li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li><li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li><li><strong>建议</strong>：远离 Hibernate。</li><li><strong>资料</strong>：<a href="https://liam.page/2020/07/17/memory-stat-in-TOP/">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</a></li></ul><p><a href="https://www.heapdump.cn/article/1661497">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021</a></p><ul><li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。</li><li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li></ul><p><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></p><p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p><p><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></p><ul><li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li><li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li></ul><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020</a></p><p>这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话带你认识 JVM</title>
      <link href="/posts/314390907/"/>
      <url>/posts/314390907/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来自<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a>投稿，原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050">https://juejin.im/post/5e1505d0f265da5d5d744050</a> 。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来</p><h2 id="一、JVM-的基本介绍"><a href="#一、JVM-的基本介绍" class="headerlink" title="一、JVM 的基本介绍"></a>一、JVM 的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道 JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png"></p><h3 id="1-1-Java-文件是如何被运行的"><a href="#1-1-Java-文件是如何被运行的" class="headerlink" title="1.1 Java 文件是如何被运行的"></a>1.1 Java 文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进 JVM 里面来。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png"></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png"></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java 文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的 5 大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的学生类</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/29046a721c2548e0a0680ec5baf4ea95-new-imageb0b42e5e-8e25-409e-b7b9-6586a39a0b8d.png"></p><p>一个 main 方法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/a3d34d33eab74f6f8743ecf62807445c-new-image08506a9e-5101-4f30-b0bc-3abbcb8f1894.png"></p><p>执行 main 方法的步骤如下:</p><ol><li> 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li> JVM 找到 App 的主程序入口，执行 main 方法</li><li> 这个 main 中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li> 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li> 执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li> 执行 sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载.class 文件的，它们在文件开头会有特定的文件标示，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li> 将 class 文件加载到内存</li><li> 将静态数据结构转化成方法区中运行时的数据结构</li><li> 在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li> 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li> 准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li> 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC 将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li> BootStrap ClassLoader：rt.jar</li><li> Extension ClassLoader: 加载扩展的 jar 包</li><li> App ClassLoader：指定的 classpath 下面的 jar 包</li><li> Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</p><p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，这种用 native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以 Slot 为最小单位，一个 slot 可以存放 32 位以内的数据类型。</p><p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的 slot 的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些 slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><pre><code>MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</code></pre><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h4 id="3-3-7-Eden-年轻代的介绍"><a href="#3-3-7-Eden-年轻代的介绍" class="headerlink" title="3.3.7 Eden 年轻代的介绍"></a>3.3.7 Eden 年轻代的介绍</h4><p>当我们 new 一个对象后，会先放到 Eden 划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里 JVM 的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，有兴趣可以了解一下。</p><p>当 Eden 空间满了之后，会触发一个叫做 Minor GC（就是一个发生在年轻代的 GC）的操作，存活下来的对象移动到 Survivor0 区。<del>Survivor0 区满后触发 Minor GC，就会将存活对象移动到 Survivor1 区</del>，此时还会把 from 和 to 两个指针交换，这样保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为空。经过多次的 Minor GC 后仍然存活的对象（<strong>这里的存活判断是 15 次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是 15，因为 HotSpot 会在对象头中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15</strong>）会移动到老年代。</p><blockquote><p>🐛 修正：当 Eden 区内存空间满了的时候，就会触发 Minor GC，Survivor0 区满不会触发 Minor GC 。</p><p><strong>那 Survivor0 区 的对象什么时候垃圾回收呢？</strong></p><p>假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换。</p></blockquote><p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC，期间会停止所有线程等待 GC 的完成。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p><p>而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png"></p><p>补充说明：关于-XX:TargetSurvivorRatio 参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold 才移动到老年代。可以举个例子：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段（如例子中的年龄 6）后，总占用超过 Survivor 空间*TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代），这时候无需等到 MaxTenuringThreshold 中要求的 15</p><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png"></p><p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java，C#等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p><ol><li> 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li> 方法区中静态变量所引用的对象（静态变量）</li><li> 方法区中常量引用的对象</li><li> 本地方法栈（即 native 修饰的方法）中 JNI 引用的对象（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li> 已启动的且未终止的 Java 线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p><p>finalize()是 Object 类的一个方法、一个对象的 finalize()方法只会被系统自动调用一次，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用 finalize()来进行自救。建议忘掉 Java 程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/c807dab33f8b42329c1910d609e7ed21-new-image565aeab2-6d3e-4c2c-80f6-7a7b0f629fda.png"></p><p>判断一个对象的死亡至少需要两次标记</p><ol><li> 如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</li><li> GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="3-4-1-标记清除算法"><a href="#3-4-1-标记清除算法" class="headerlink" title="3.4.1 标记清除算法"></a>3.4.1 标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要 new 一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和 survivor 一样也是用 from 和 to 两个指针这样的玩法。fromPlace 存满了，就把存活的对象 copy 到另一块 toPlace 上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png"></p><p>不过它们分配的时候也不是按照 1:1 这样进行分配的，就类似于 Eden 和 Survivor 也不是等价分配是一个道理。</p><h4 id="3-4-3-标记整理算法"><a href="#3-4-3-标记整理算法" class="headerlink" title="3.4.3 标记整理算法"></a>3.4.3 标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png"></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-（了解）各种各样的垃圾回收器"><a href="#3-5-（了解）各种各样的垃圾回收器" class="headerlink" title="3.5 （了解）各种各样的垃圾回收器"></a>3.5 （了解）各种各样的垃圾回收器</h3><p>HotSpot VM 中的垃圾回收器，以及适用场景</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png"></p><p>到 jdk8 为止，默认的垃圾收集器是 Parallel Scavenge 和 Parallel Old</p><p>从 jdk9 开始，G1 收集器成为默认的垃圾收集器<br>目前来看，G1 回收器停顿时间最短而且没有明显缺点，非常适合 Web 应用。在 jdk8 中测试 Web 应用，堆内存 6G，新生代 4.5G 的情况下，Parallel Scavenge 回收新生代停顿长达 1.5 秒。G1 回收器回收同样大小的新生代只停顿 0.2 秒。</p><h3 id="3-6-（了解）JVM-的常用参数"><a href="#3-6-（了解）JVM-的常用参数" class="headerlink" title="3.6 （了解）JVM 的常用参数"></a>3.6 （了解）JVM 的常用参数</h3><p>JVM 的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的 1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的 1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or later)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与 jmap -heap 中显示的 New gen 是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun 官方推荐配置为整个堆的 3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的 1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的 1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0 以后每个线程堆栈大小为 1M,以前每个线程堆栈大小为 256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在 3000~5000 左右一般小的应用， 如果栈不是很深， 应该是 128k 够用的 大的应用建议使用 256k。这个选项对性能影响比较大，需要严格的测试。（校长）和 threadstacksize 选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括 Eden 和两个 Survivor 区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4 表示年轻代与年老代所占比值为 1:4,年轻代占整个堆栈的 1/5Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden 区与 Survivor 区的大小比值</td><td></td><td>设置为 8,则两个 Survivor 区与一个 Eden 区的比值为 2:8,一个 Survivor 区占整个年轻代的 1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭 System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用 Parallel ScavengeGC 时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于 CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM 会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及 CMS 方面的参数，这里就不以一一列举了</p><h2 id="四、关于-JVM-调优的一些方面"><a href="#四、关于-JVM-调优的一些方面" class="headerlink" title="四、关于 JVM 调优的一些方面"></a>四、关于 JVM 调优的一些方面</h2><p>根据刚刚涉及的 jvm 的知识点，我们可以尝试对 JVM 进行调优，主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为 64m。所以 java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 fullgc，所以老年代过小的话反而是会增多 fullgc 的）。此值对系统性能影响较大，Sun 官方推荐配置为 java 堆的 3/8。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定 java 堆最大值（默认值是物理内存的 1/4(&lt;1GB)）和初始 java 堆最小值（默认值是物理内存的 1/64(&lt;1GB)）</p><p>默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.，默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于 40%了，JVM 就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于 70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p>注意：此处设置的是 Java 堆大小，也就是新生代大小 + 老年代大小</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/5e7b352c16d74c789c665af46d3a2509-new-imagedd645dae-307d-4572-b6e2-b5a9925a46cd.png"></p><p>设置一个 VM options 的参数</p><pre><code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/fe99e355f4754fa4be7427cb65261f3d-new-imagebb5cf485-99f8-43eb-8809-2a89e6a1768e.png"></p><p>再次启动 main 方法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/300539f6560043dd8a3fe085d28420e6-new-image3c581a2e-196f-4b01-90f1-c27731b4610b.png"></p><p>这里 GC 弹出了一个 Allocation Failure 分配失败，这个事情发生在 PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为 18M，空闲内存为 4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了1M空间给数组"</span>);</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/bdd717d0a3394be7a733760052773374-new-image371b5d59-0020-4091-9874-603c0ab0073d.png"></p><p>此时 free memory 就又缩水了，不过 total memory 是没有变化的。Java 会尽可能将 total mem 的值维持在最小堆内存大小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了10M空间给数组"</span>);</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/0fd7550ae2144adca8ed2ede12d5fb96-new-image0c31ff20-289d-4088-8c67-a846d0c5d1e0.png"></p><p>这时候我们创建了一个 10M 的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的 total memory 已经变成了 15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/4cc44b5d5d1c40c48640ece6a296b1ac-new-image4b57baf6-085b-4150-9c60-ac51b0f815d7.png"></p><p>此时我们手动执行了一次 fullgc，此时 total memory 的内存空间又变回 5.5M 了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的 1/5。在 Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整-Survivor-区和-Eden-区的比值"><a href="#4-3-调整-Survivor-区和-Eden-区的比值" class="headerlink" title="4.3 调整 Survivor 区和 Eden 区的比值"></a>4.3 调整 Survivor 区和 Eden 区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个 Survivor 区和 eden 的比值</p><p>例如：8，表示两个 Survivor:eden=2:8，即一个 Survivor 占年轻代的 1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的 gc，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 java 堆的 3/8，幸存代占新生代的 1/10</p><p>在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具。</p><pre><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></pre><p>一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><pre><code>-XX:PermSize -XX:MaxPermSize</code></pre><p>初始空间（默认为物理内存的 1/64）和最大空间（默认为物理内存的 1/4）。也就是说，jvm 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会 OOM。</p><p>tips：如果堆空间没有用完也抛出了 OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM。</p><h3 id="4-7-JVM-的栈参数调优"><a href="#4-7-JVM-的栈参数调优" class="headerlink" title="4.7 JVM 的栈参数调优"></a>4.7 JVM 的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><pre><code>-XXThreadStackSize：    设置线程栈的大小(0 means use default stack size)</code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供 demo 了</p><h3 id="4-8-可以直接跳过了-JVM-其他参数介绍"><a href="#4-8-可以直接跳过了-JVM-其他参数介绍" class="headerlink" title="4.8 (可以直接跳过了)JVM 其他参数介绍"></a>4.8 (可以直接跳过了)JVM 其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><pre><code>-XXThreadStackSize：    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><pre><code>-XX:+UseFastAccessorMethods：    设置原始类型的快速优化</code></pre><h4 id="4-8-3-设置关闭手动-GC"><a href="#4-8-3-设置关闭手动-GC" class="headerlink" title="4.8.3 设置关闭手动 GC"></a>4.8.3 设置关闭手动 GC</h4><pre><code>-XX:+DisableExplicitGC：    设置关闭System.gc()(这个参数需要严格的测试)</code></pre><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><pre><code>-XX:MaxTenuringThreshold    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><pre><code>-XX:+AggressiveOpts</code></pre><p>加快编译速度</p><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><pre><code>-XX:+UseBiasedLocking</code></pre><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><pre><code>-Xnoclassgc</code></pre><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><pre><code>-XX:SoftRefLRUPolicyMSPerMB    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><pre><code>-XX:PretenureSizeThreshold    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre><h4 id="4-8-10-设置-TLAB-占-eden-区的比例"><a href="#4-8-10-设置-TLAB-占-eden-区的比例" class="headerlink" title="4.8.10 设置 TLAB 占 eden 区的比例"></a>4.8.10 设置 TLAB 占 eden 区的比例</h4><pre><code>-XX:TLABWasteTargetPercent    设置TLAB占eden区的百分比，默认值是1% 。</code></pre><h4 id="4-8-11-设置是否优先-YGC"><a href="#4-8-11-设置是否优先-YGC" class="headerlink" title="4.8.11 设置是否优先 YGC"></a>4.8.11 设置是否优先 YGC</h4><pre><code>-XX:+CollectGen0First    设置FullGC时是否先YGC，默认值是false。</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java 核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的JVM参数总结</title>
      <link href="/posts/1352723613/"/>
      <url>/posts/1352723613/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 JavaGuide 翻译自 <a href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parameters</a>，并对文章进行了大量的完善补充。</p><p>JDK 版本：1.8</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在本篇文章中，你将掌握最常用的 JVM 参数配置。</p><h2 id="2-堆内存相关"><a href="#2-堆内存相关" class="headerlink" title="2.堆内存相关"></a>2.堆内存相关</h2><blockquote><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1352723613/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="内存区域常见配置参数"></p><h3 id="2-1-显式指定堆内存–Xms和-Xmx"><a href="#2-1-显式指定堆内存–Xms和-Xmx" class="headerlink" title="2.1.显式指定堆内存–Xms和-Xmx"></a>2.1.显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>heap size</strong> 表示要初始化内存的具体大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为**<em>“ g”</em>** (GB)、**<em>“ m”</em><strong>（MB）、</strong><em>“ k”</em>**（KB）。</li></ul><p>举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-显式新生代内存-Young-Generation"><a href="#2-2-显式新生代内存-Young-Generation" class="headerlink" title="2.2.显式新生代内存(Young Generation)"></a>2.2.显式新生代内存(Young Generation)</h3><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">Oracle 官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 _MB_，最大大小为<em>无限制</em>。</p><p>一共有两种指定 新生代内存(Young Generation)大小的方法：</p><p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br></pre></td></tr></tbody></table></figure><p>举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br></pre></td></tr></tbody></table></figure><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p><p>举个栗子 🌰，如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></tbody></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>另外，你还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p><p>比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=1</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-显式指定永久代-元空间的大小"><a href="#2-3-显式指定永久代-元空间的大小" class="headerlink" title="2.3.显式指定永久代/元空间的大小"></a>2.3.显式指定永久代/元空间的大小</h3><p><strong>从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">#方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></tbody></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></tbody></table></figure><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1947">issue#1947</a>）</strong>：</p><p>1、Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p><p>可以参考 Oracle 官方文档 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html">Other Considerations</a> 中提到的：</p><blockquote><p>Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.</p><p>MetaspaceSize 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。</p></blockquote><p>另外，还可以看一下这个试验：<a href="https://mp.weixin.qq.com/s/jqfppqqd98DfAJHZhFbmxA">JVM 参数 MetaspaceSize 的误解</a>。</p><p>2、Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p><p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p><p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MetaspaceGC::initialize</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// Set the high-water mark to MaxMetapaceSize during VM initializaton since</span></span><br><span class="line">  <span class="comment">// we can't do a GC during initialization.</span></span><br><span class="line">  _capacity_until_GC = MaxMetaspaceSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相关阅读：<a href="https://github.com/Snailclimb/JavaGuide/issues/1204">issue 更正：MaxMetaspaceSize 如果不指定大小的话，不会耗尽内存 #1204 </a> 。</p><h2 id="3-垃圾收集相关"><a href="#3-垃圾收集相关" class="headerlink" title="3.垃圾收集相关"></a>3.垃圾收集相关</h2><h3 id="3-1-垃圾回收器"><a href="#3-1-垃圾回收器" class="headerlink" title="3.1.垃圾回收器"></a>3.1.垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集</a>算法至关重要。</p><p>JVM 具有四种类型的 GC 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS 垃圾收集器</li><li>G1 垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></tbody></table></figure><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md">此处</a>。</p><h3 id="3-2-GC-日志记录"><a href="#3-2-GC-日志记录" class="headerlink" title="3.2.GC 日志记录"></a>3.2.GC 日志记录</h3><p>生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 打印对象分布</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line"><span class="comment"># 打印堆数据</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># 打印Reference处理信息</span></span><br><span class="line"><span class="comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span></span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"><span class="comment"># 打印STW时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 开启日志文件分割</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 最多分割几个文件，超过之后从头文件开始写</span></span><br><span class="line">-XX:NumberOfGCLogFiles=14</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></tbody></table></figure><h2 id="4-处理-OOM"><a href="#4-处理-OOM" class="headerlink" title="4.处理 OOM"></a>4.处理 OOM</h2><p>对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。</p><p>这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br><span class="line">-XX:OnOutOfMemoryError=<span class="string">"&lt; cmd args &gt;;&lt; cmd args &gt;"</span></span><br><span class="line">-XX:+UseGCOverheadLimit</span><br></pre></td></tr></tbody></table></figure><p>这里有几点需要注意:</p><ul><li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li><li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li><li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError="shutdown -r"</code> 。</li><li><strong>UseGCOverheadLimit</strong> 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例</li></ul><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><ul><li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li><li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li><li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li><li>``-XX:LargePageSizeInBytes `: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li><li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li><li><code>-XX:SurvivorRatio</code> : eden/survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li><li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li><li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li><li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li><li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a><h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2></li></ul><p>这里推荐了非常多优质的 JVM 实践相关的文章，推荐阅读，尤其是 JVM 性能优化和问题排查相关的文章。</p><ul><li><a href="https://help.aliyun.com/document_detail/148851.html">JVM 参数配置说明 - 阿里云官方文档 - 2022</a></li><li><a href="https://help.aliyun.com/document_detail/383255.html">JVM 内存配置最佳实践 - 阿里云官方文档 - 2022</a></li><li><a href="https://segmentfault.com/a/1190000039806436">求你了，GC 日志打印别再瞎配置了 - 思否 - 2022</a></li><li><a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></li><li><a href="https://heapdump.cn/article/1859160">一次线上 JVM 调优实践，FullGC40 次/天到 10 天一次的优化过程 - HeapDump - 2021</a></li><li><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></li><li><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></li><li><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团队 - 2020</a></li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊 Java 应用的 GC 优化-美团技术团队 - 美团技术团队 - 2017</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器详解</title>
      <link href="/posts/3182538063/"/>
      <url>/posts/3182538063/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下类加载过程"><a href="#回顾一下类加载过程" class="headerlink" title="回顾一下类加载过程"></a>回顾一下类加载过程</h2><p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p><ul><li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li><li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loading-procedure-20230614221433913.png" alt="类加载过程"></p><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h3><p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p><p>根据官方 API 文档的介绍：</p><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.</p><p>Every Class object contains a reference to the ClassLoader that defined it.</p><p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></blockquote><p>从上面的介绍可以看出:</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; {</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> {</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p><h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> {</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h3><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li> **<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li> **<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li> **<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><blockquote><p>🌈 拓展一下：</p><ul><li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.* </code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li></ul></blockquote><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p><p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 父加载器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span> {</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么 获取到 <code>ClassLoader</code> 为<code>null</code>就是 <code>BootstrapClassLoader</code> 加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintClassLoaderTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> PrintClassLoaderTree.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">split</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">"|--"</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needContinue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (needContinue){</span><br><span class="line">            System.out.println(split.toString() + classLoader);</span><br><span class="line">            <span class="keyword">if</span>(classLoader == <span class="literal">null</span>){</span><br><span class="line">                needContinue = <span class="literal">false</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                classLoader = classLoader.getParent();</span><br><span class="line">                split.insert(<span class="number">0</span>, <span class="string">"\t"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果(JDK 8 )：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|--sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    |--sun.misc.Launcher$ExtClassLoader@53bd815b</span><br><span class="line">        |--null</span><br></pre></td></tr></tbody></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li><li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是<code>ExtClassLoader</code>；</li><li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为 null。</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>我们前面也说说了，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resove</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p><p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p>根据官网介绍：</p><blockquote><p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。<br>虚拟机中被称为 “bootstrap class loader”的内置类加载器本身没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 <code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code> 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> {</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p><h3 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (resolve) {</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li></ul><p>🌈 拓展一下：</p><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h3 id="打破双亲委派模型方法"><a href="#打破双亲委派模型方法" class="headerlink" title="打破双亲委派模型方法"></a>打破双亲委派模型方法</h3><p><del>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</del></p><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/871">issue871</a> ）</strong>：自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p></blockquote><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p>Tomcat 的类加载器的层次结构如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构"></p><p>感兴趣的小伙伴可以自行研究一下 Tomcat 类加载器的层次结构，这有助于我们搞懂 Tomcat 隔离 Web 应用的原理，推荐资料是<a href="http://gk.link/a/10Egr">《深入拆解 Tomcat &amp; Jetty》</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2></li><li><p>《深入拆解 Java 虚拟机》</p></li><li><p>深入分析 Java ClassLoader 原理：<a href="https://blog.csdn.net/xyang81/article/details/7292380">https://blog.csdn.net/xyang81/article/details/7292380</a></p></li><li><p>Java 类加载器(ClassLoader)：<a href="http://gityuan.com/2016/01/24/java-classloader/">http://gityuan.com/2016/01/24/java-classloader/</a></p></li><li><p>Class Loaders in Java：<a href="https://www.baeldung.com/java-classloaders">https://www.baeldung.com/java-classloaders</a></p></li><li><p>Class ClassLoader - Oracle 官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html</a></p></li><li><p>老大难的 Java ClassLoader 再不理解就老了：<a href="https://zhuanlan.zhihu.com/p/51374915">https://zhuanlan.zhihu.com/p/51374915</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程详解</title>
      <link href="/posts/407384776/"/>
      <url>/posts/407384776/</url>
      
        <content type="html"><![CDATA[<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。</p><p>这 7 个阶段的顺序如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/class-loading-procedure.png" alt="类加载过程"></p><p>详见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" title="Java Virtual Machine Specification - 5.3. Creation and Loading">Java Virtual Machine Specification - 5.3. Creation and Loading</a>。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取（ <code>ZIP</code>、 <code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如 <code>JSP</code>…）、怎样获取。</p><p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p><blockquote><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容在<a href="https://javaguide.cn/java/jvm/classloader.html" title="类加载器详解">类加载器详解</a>这篇文章中有详细介绍到。阅读本篇文章的时候，大家知道有这么个东西就可以了。</p></blockquote><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。</p><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p><p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p><p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/class-loading-process-verification.png" alt="验证阶段示意图"></p><p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p><blockquote><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p>关于方法区的详细介绍，推荐阅读 <a href="https://javaguide.cn/java/jvm/memory-area.html" title="Java 内存区域详解">Java 内存区域详解</a> 这篇文章。</p></blockquote><p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p><p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li><li>……</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：<a href="https://github.com/fenixsoft/jvm_book/issues/75" title="《深入理解Java虚拟机（第3版）》勘误#75">《深入理解 Java 虚拟机（第 3 版）》勘误#75</a></li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值</strong>：(图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/symbol-reference-and-direct-reference-20230614221246704.png" alt="符号引用和直接引用"></p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p><blockquote><p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname("...")</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，<br>就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745" title="issue745">issue745</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><blockquote><p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662" title="issue#662">issue#662</a>由 <strong><a href="https://github.com/guang19" title="guang19">guang19</a></strong> 补充完善。</p></blockquote><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><p><strong>参考</strong></p><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机》</li><li>《实战 Java 虚拟机》</li><li>Chapter 5. Loading, Linking, and Initializing - Java Virtual Machine Specification：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构详解</title>
      <link href="/posts/2384868174/"/>
      <url>/posts/2384868174/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下字节码"><a href="#回顾一下字节码" class="headerlink" title="回顾一下字节码"></a>回顾一下字节码</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala、JRuby、Kotlin 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/">WinHex</a> 查看。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"></p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><h2 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h2><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p><p><code>ClassFile</code> 的结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile {</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p><p>下面这张图是通过 IDEA 插件 <code>jclasslib</code> 查看的，你可以更直观看到 Class 文件结构。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20210401170711475.png"></p><p>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><h3 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></tbody></table></figure><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="Class-文件版本号（Minor-amp-Major-Version）"><a href="#Class-文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></tbody></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></tbody></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8 编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">５</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">６</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">７</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">８</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_FieldRef_info</td><td align="center">９</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_MethodRef_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodRef_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">标志方法类型</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></tbody></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>类访问和属性修饰符:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p><p>我们定义了一个 <code>Employee</code> 类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p><h3 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></tbody></table></figure><p>Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></tbody></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p><h3 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></tbody></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></tbody></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《实战 Java 虚拟机》</li><li>Chapter 4. The class File Format - Java Virtual Machine Specification:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></li><li>实例分析 JAVA CLASS 的文件结构：<a href="https://coolshell.cn/articles/9229.html">https://coolshell.cn/articles/9229.html</a></li><li>《Java 虚拟机原理图解》 1.2.2、Class 文件中的常量池详解（上）：<a href="https://blog.csdn.net/luanlouis/article/details/39960815">https://blog.csdn.net/luanlouis/article/details/39960815</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/posts/103/"/>
      <url>/posts/103/</url>
      
        <content type="html"><![CDATA[<p>大家好！</p><p>我很高兴在这个美妙的虚空之字的博客世界里与大家相遇。这是我写博客的开端，也是我开始探索代码艺术之旅的起点。</p><p>代码，对我而言，不仅仅是冰冷的指令和函数的堆砌。它们如同音符，在我的手指间奏响优美的旋律。通过编码，我可以创造出令人惊叹的应用程序、网站和工具，将想法变为现实。</p><p>在这个博客中，我将分享我对代码的热爱和探索，以及与之相关的艺术与创造力。我会探讨编程的美妙之处，探索代码中隐藏的诗意，并分享我的创作心得和技巧。</p><p>我希望这个博客能成为一个交流和学习的平台，让我们共同探索代码艺术的无限可能。我鼓励大家在评论区留下你们的想法、问题和建议。我期待与你们的互动，共同成长。</p><p>让我们开始这个令人兴奋的旅程吧！感谢你们的支持和关注。</p><p>愿代码之旅带给我们无尽的创造和惊喜！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
